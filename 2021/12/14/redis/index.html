<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Redis, KTS Blog">
    <meta name="description" content="Nosql1.什么是NOSQLNoSQL(NoSQL=Not Only SQL)：
意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。
NoSQL是一个通用术语，用于指不遵循传统RDBMS模型的任何数据存储——具体来说，">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Redis | KTS Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">KTS Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">KTS Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/images/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Redis</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/" class="post-category">
                                后端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-12-14
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    19.1k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h1><h2 id="1-什么是NOSQL"><a href="#1-什么是NOSQL" class="headerlink" title="1.什么是NOSQL"></a>1.什么是NOSQL</h2><p>NoSQL(NoSQL=Not Only SQL)：</p>
<p>意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p>
<p>NoSQL是一个通用术语，用于指不遵循传统RDBMS模型的任何数据存储——具体来说，数据是非关系型的，它不使用SQL作为主要查询语言。它是用于指试图解决可伸缩性和可用性问题而不是原子性或一致性问题的数据库。</p>
<p>NoSQL可以用描述任何一种数据文件，不具备传统关系型数据库的范式，NoSQL是非关系型设计的Database，主要针对当前互联网时代的复杂数据，不去关注数据间的复杂关系。</p>
<h2 id="2-为什么需要NOSQL"><a href="#2-为什么需要NOSQL" class="headerlink" title="2.为什么需要NOSQL"></a>2.为什么需要NOSQL</h2><p>随着互联网的高速崛起，网站的用户群的增加，访问量的上升，传统数据库上都开始出现了性能瓶颈，web程序不再仅仅专注在功能上，同时也在追求性能。所以NOSQL数据库应运而上，具体表现为对如下三高问题的解决：</p>
<p><strong>High performance - 对数据库高并发读写的需求</strong></p>
<p>web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负</p>
<p>载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就</p>
<p>已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点</p>
<p>击次数，投票计数等，因此这是一个相当普遍的需求。</p>
<p><strong>Huge Storage - 对海量数据的高效率存储和访问的需求</strong></p>
<p>类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户</p>
<p>动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登</p>
<p>录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。</p>
<p><strong>High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求</strong></p>
<p>在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像</p>
<p>web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站</p>
<p>来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来</p>
<p>实现扩展呢？</p>
<h2 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3.NoSQL的四大分类"></a>3.NoSQL的四大分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>举例</th>
<th>典型应用场景</th>
<th>数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>键值（key-value）</strong></td>
<td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td>
<td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等</td>
<td>Key 指向 Value 的键值对，通常用hash table来实现</td>
<td>查找速度快</td>
<td>数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td><strong>列存储数据库</strong></td>
<td>Cassandra, HBase, Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td><strong>文档型数据库</strong></td>
<td>CouchDB, MongoDb</td>
<td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>
<td>Key-Value对应的键值对，Value为结构化数据</td>
<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td>查询性能不高，而且缺乏统一的查询语法。</td>
</tr>
<tr>
<td><strong>图形(Graph)数据库</strong></td>
<td>Neo4J, InfoGrid, Infinite Graph</td>
<td>社交网络，推荐系统等。专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td>
</tr>
</tbody></table>
<p><strong>键值( Key-Value )存储数据库</strong></p>
<p>这一类数据库主要会使用到一个 哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果 DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。 [3]  举例如：Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB.</p>
<p><strong>列存储数据库。</strong></p>
<p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra, HBase, Riak.</p>
<p><strong>文档型数据库</strong></p>
<p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, </p>
<p>MongoDB. 国内也有文档型数据库SequoiaDB，目前已经开源。</p>
<p><strong>图形(Graph)数据库</strong><br>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 [2]  如：Neo4J, InfoGrid, Infinite Graph.</p>
<p>因此，我们总结NoSQL数据库在以下的这几种情况下比较适用：1、数据模型比较简单；2、需要灵活性更强的IT系统；3、对数据库性能要求较高；4、不需要高度的数据一致性；5、对于给定key，比较容易映射复杂值的环境。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yejg1212/p/3584094.html">常见的NoSQL数据库</a></p>
<h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><h2 id="Redis中文文档"><a href="#Redis中文文档" class="headerlink" title="Redis中文文档"></a>Redis中文文档</h2><p><a target="_blank" rel="noopener" href="http://www.redis.cn/">http://www.redis.cn/</a></p>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p>
<p><strong>官网介绍</strong></p>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a target="_blank" rel="noopener" href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a target="_blank" rel="noopener" href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a><strong>Redis特点</strong></h2><p>Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，它的读取速度可高达110000次/s，写速度高达81000次/s。</p>
<p>Redis跟memcache不同的是，储存在Redis中的数据是持久化的，断电或重启后，数据也不会丢失。因为Redis的存储分为内存存储、磁盘存储和log文件三部分，重启后，Redis可以从磁盘重新将数据加载到内存中，这些可以通过配置文件对其进行配置，正因为这样，Redis才能实现持久化。</p>
<p>Redis支持主从模式，可以配置集群，这样更利于支撑起大型的项目，这也是Redis的一大亮点。</p>
<h2 id="Redis应用场景，它能做什么"><a href="#Redis应用场景，它能做什么" class="headerlink" title="Redis应用场景，它能做什么"></a><strong>Redis应用场景，它能做什么</strong></h2><p>众多语言都支持Redis，因为Redis交换数据快，所以在服务器中常用来存储一些需要频繁调取的数据，这样可以大大节省系统直接读取磁盘来获得数据的I/O开销，更重要的是可以极大提升速度。 </p>
<p>拿大型网站来举个例子，比如a网站首页一天有100万人访问，其中有一个板块为推荐新闻。要是直接从数据库查询，那么一天就要多消耗100万次数据库请求。上面已经说过，Redis支持丰富的数据类型，所以这完全可以用Redis来完成，将这种热点数据存到Redis（内存）中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。</p>
<p><strong>具体应用</strong></p>
<p>1，会话缓存（最常用）</p>
<p>2，消息队列，比如支付</p>
<p>3，活动排行榜或计数</p>
<p>4，发布，订阅消息（消息通知）</p>
<p>5，商品列表，评论列表等</p>
<h2 id="Redis下载"><a href="#Redis下载" class="headerlink" title="Redis下载"></a>Redis下载</h2><p>Windows版本</p>
<p><strong>下载地址：</strong><a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases%E3%80%82">https://github.com/tporadowski/redis/releases。</a></p>
<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="Redis性能测试"><a href="#Redis性能测试" class="headerlink" title="Redis性能测试"></a>Redis性能测试</h2><p>redis-benchmark是一个压力测试工具</p>
<p>Redis性能测试工具可选参数如下所示：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>-h</strong></td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>-p</strong></td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>-s</strong></td>
<td align="left">指定服务器 socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>-c</strong></td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>-n</strong></td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>-d</strong></td>
<td align="left">以字节的形式指定 SET/GET 值的数据大小</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>-k</strong></td>
<td align="left">1=keep alive 0=reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>-r</strong></td>
<td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>-P</strong></td>
<td align="left">通过管道传输 <numreq> 请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>-q</strong></td>
<td align="left">强制退出 redis。仅显示 query/sec 值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>–csv</strong></td>
<td align="left">以 CSV 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>-l</strong></td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>-t</strong></td>
<td align="left">仅运行以逗号分隔的测试命令列表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>-I</strong></td>
<td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Redis-benchmark命令的使用示例如下所示。</p>
<ul>
<li><p>如下命令所示，使用100个并发连接、100000个请求检测端口为6379的Redis服务器性能。</p>
<pre class="line-numbers language-none"><code class="language-none">redis-benchmark -h 192.X.X.201 -p 6379 -c 100 -n 100000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>如下命令所示，测试获取大小为100字节的数据包的性能。</p>
<pre class="line-numbers language-none"><code class="language-none">redis-benchmark -h X.X.X.X -p 6379 -q -d 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>如下命令所示，只测试部分操作的性能。</p>
<pre class="line-numbers language-none"><code class="language-none">redis-benchmark -t set,lpush -n 100000 -q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p><img src="C:/Users/WZY/AppData/Roaming/Typora/typora-user-images/image-20210415193636975.png" alt="image-20210415193636975"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis数据存储格式</p>
<p>redis自身是一个Map，其中所有的数据都是采用key : value的形式存储</p>
<p>数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213162305492.png" alt="image-20211213162305492"></p>
<blockquote>
<p> <strong>Redis是单线程的</strong></p>
</blockquote>
<p>Redis是基于内存操作的，CPU不是Redis的瓶颈，机器的内存和网络带宽是瓶颈 </p>
<blockquote>
<p><strong>为什么Redis单线程很快？</strong></p>
</blockquote>
<p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p>
<p>（1）多路 I/O 复用模型</p>
<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
<p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/79470556">为什么说Redis是单线程的以及Redis为什么这么快！</a></p>
<blockquote>
<p><strong>什么是cpu上下文切换?</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p>
<h2 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.<strong>简介</strong></h4><p>　　string 类型是 Redis 中最基本的数据类型，最常用的数据类型，甚至被很多玩家当成 redis 唯一的数据类型去使用。string 类型在 redis 中是二进制安全(binary safe)的,这意味着 string 值关心二进制的字符串，不关心具体格式，你可以用它存储 json 格式或 JPEG 图片格式的字符串。</p>
<ul>
<li><p>存储的数据:单个数据，最简单的数据存储类型，也是最常用的数据存</p>
</li>
<li><p>储类型存储数据的格式:一个存储空间保存一个数据</p>
</li>
<li><p>存储内容:通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p>
</li>
</ul>
<h4 id="2-相关命令及操作"><a href="#2-相关命令及操作" class="headerlink" title="2.相关命令及操作"></a>2.相关命令及操作</h4><p>菜鸟教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-strings.html">https://www.runoob.com/redis/redis-strings.html</a></p>
<ul>
<li><p>string 作为数值操作</p>
<ul>
<li><p>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</p>
</li>
<li><p>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</p>
</li>
<li><p>注意:按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。9223372036854775807 (java中long型数据最大值，Long.MAX_VALUE)</p>
</li>
</ul>
</li>
<li><p>redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</p>
<p><code>setex key seconds value</code></p>
<p><code>psetex key milliseconds value</code></p>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.<strong>简介</strong></h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），像双端队列。</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<ul>
<li>数据存储需求:存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li>需要的存储结构:一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li>list类型:保存多个数据，底层使用双向链表存储结构实现</li>
</ul>
<h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h4><ul>
<li>各种列表，比如twitter的关注列表、粉丝列表等，最新消息排行、每篇文章的评论等也可以用Redis的list结构来实现。</li>
<li>消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出执行。这里的消息队列并没有ack机制，如果消费者把任务给Pop走了又没处理完就死机了怎么办？解决方法之一是加多一个sorted set，分发的时候同时发到list与sorted set，以分发时间为score，用户把任务做完了之后要用ZREM消掉sorted set里的job，并且定时从sorted set中取出超时没有完成的任务，重新放回list。另一个做法是为每个worker多加一个的list，弹出任务时改用RPopLPush，将job同时放到worker自己的list中，完成时用LREM消掉。如果集群管理(如zookeeper)发现worker已经挂掉，就将worker的list内容重新放回主list。</li>
<li>利用LRANGE可以很方便的实现list内容分页的功能。</li>
<li>取最新N个数据的操作：LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。</li>
</ul>
<h4 id="3-Redis-列表命令"><a href="#3-Redis-列表命令" class="headerlink" title="3.Redis 列表命令"></a>3.Redis 列表命令</h4><p>下表列出了列表相关的基本命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-blpop.html">BLPOP key1/key2 timeout</a>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-brpop.html">BRPOP key1/key2 timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a> 通过索引获取列表中的元素</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a> 获取列表长度</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a> 移出并获取列表的第一个元素</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lpush.html">LPUSH key value1 /value2]</a> 将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a> 获取列表指定范围内的元素</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a> 移除列表元素</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a> 通过索引设置列表元素的值</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-rpush.html">RPUSH key value1/value2]</a> 在列表中添加一个或多个值</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td>
</tr>
</tbody></table>
<p>注意：数据从那边进，就从反方向读</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p>set类型:与hash存储结构完全相同，仅存储键，不存储值(nil)，并且值是不允许重复的</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213192425622.png" alt="image-20211213192425622"></p>
<h4 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2.应用场景"></a>2.应用场景</h4><ul>
<li><p>某些需要去重的列表，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
</li>
<li><p>可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。</p>
</li>
<li><p>Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。又比如QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这里也可以把每一个用户的标签都存储在一个集合之中。</p>
</li>
<li><p>权限校验</p>
</li>
<li><p>实现网站访问量统计</p>
<p>公司对旗下新的网站做推广，统计网站的PV(访问量),UV(独立访客) ,IP (独立IP)。</p>
<p>PV:网站被访问次数，可通过刷新页面提高访问量</p>
<p>UV∶网站被不同用户访问的次数，可通过cookie统计访问量，相同用户切换IP地址，UV不变</p>
<p>IP:网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变</p>
</li>
<li><p>黑白名单</p>
</li>
</ul>
<h4 id="3-Redis-集合命令"><a href="#3-Redis-集合命令" class="headerlink" title="3.Redis 集合命令"></a>3.Redis 集合命令</h4><p>下表列出了 Redis 集合基本命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sadd.html">SADD key member1/member2</a> 向集合添加一个或多个成员</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a> 获取集合的成员数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF key1/key2</a> 返回第一个集合与其他集合之间的差异。(差集)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sdiffstore.html">SDIFFSTORE destination key1/key2</a> 返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sinter.html">SINTER key1/key2</a> 返回给定所有集合的交集</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sinterstore.html">SINTERSTORE destination key1/key2</a> 返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a> 返回集合中的所有成员</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a> 移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-srandmember.html">SRANDMEMBER key count</a> 返回集合中一个或多个随机数</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-srem.html">SREM key member1 member2</a> 移除集合中一个或多个成员</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sunion.html">SUNION key1 key2</a> 返回所有给定集合的并集</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sunionstore.html">SUNIONSTORE destination key1/key2</a> 所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">[SSCAN key cursor <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td>
</tr>
</tbody></table>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h4><p>新的存储需求:对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p>
<p>需要的存储结构:一个存储空间保存多个键值对数据</p>
<p>hash类型:底层使用哈希表结构实现数据存储</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213164500961.png" alt="image-20211213164500961"></p>
<p><strong>hash存储结构优化</strong></p>
<p>如果field数量较少，存储结构优化为类数组结构</p>
<p>如果field数量较多，存储结构使用HashMap结构</p>
<p><strong>hash类型数据操作的注意事项</strong></p>
<ul>
<li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现 象。如果数据未获取到,对应的值为(nil)</li>
<li>每个 hash可以存储232-1个键值对</li>
<li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</li>
<li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li>
</ul>
<h4 id="2-Redis-hash-命令"><a href="#2-Redis-hash-命令" class="headerlink" title="2.Redis hash 命令"></a>2.Redis hash 命令</h4><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1/field2</a> 删除一个或多个哈希表字段</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hexists.html">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a> 获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a> 获取所有哈希表中的字段</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a> 获取哈希表中字段的数量</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hmget.html">HMGET key field1 field2]</a> 获取所有给定字段的值</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hmset.html">HMSET key field1 value1 field2 value2 ]</a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a> 将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a> 获取哈希表中所有值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">[HSCAN key cursor <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a> 迭代哈希表中的键值对。</td>
</tr>
</tbody></table>
<h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><p>电商网站购物车设计与实现</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213165621697.png" alt="image-20211213165621697"></p>
<p>业务分析</p>
<ul>
<li><p>仅分析购物车的redis存储模型<br>添加、浏览、更改数量、删除、清空</p>
</li>
<li><p>购物车于数据库间持久化同步(不讨论)</p>
</li>
<li><p>购物车于订单间关系(不讨论)</p>
<p>提交购物车:读取数据生成订单</p>
<p>商家临时价格调整:隶属于订单级别</p>
</li>
<li><p>未登录用户购物车信息存储(不讨论)<br>cookie存储</p>
</li>
</ul>
<p>解决方案</p>
<p>以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息</p>
<p>将商品编号作为field，购买数量作为value进行存储</p>
<p>添加商品:追加全新的field与value</p>
<p>浏览:遍历hash</p>
<p>更改数量:自增/自减，设置value值</p>
<p>删除商品:删除field</p>
<p>清空:删除key</p>
<blockquote>
<p> 当前设计是否加速了购物车的呈现？  答：没有</p>
</blockquote>
<p>当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库</p>
<p>每条购物车中的商品记录保存成两条field</p>
<p>field1专用于保存购买数量</p>
<p>​    命名格式:商品id:nums</p>
<p>​    保存数据:数值</p>
<p>field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等</p>
<p>​    命名格式:商品id:info</p>
<p>​    保存数据: json</p>
<blockquote>
<p>当商品信息对应的json相同时，如何区分？</p>
</blockquote>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213171541638.png" alt="image-20211213171541638"></p>
<p>field2作为独立的hash，专门作为存储信息的hash，类似于外键，field2不在存储信息而是存储信息对应的key，进行二次查找，不过不需要再走数据库，速度有保障。</p>
<h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><h4 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="1.简介"></a>1.简介</h4><p>sorted_set类型:在set的存储结构基础上添加可排序字段</p>
<p>和Set不同的是每个元素都会关联一个 double 类型的分数score。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 </p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213195328194.png" alt="image-20211213195328194"></p>
<p><strong>注意</strong></p>
<ul>
<li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li>
<li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据,score值将被反复覆盖，保留最后一次修改的结果</li>
</ul>
<h4 id="2-Redis-有序集合命令"><a href="#2-Redis-有序集合命令" class="headerlink" title="2.Redis 有序集合命令"></a>2.Redis 有序集合命令</h4><p>下表列出了 redis 有序集合的基本命令:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD key score1 member1 score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a> 获取有序集合的成员数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">ZINTERSTORE destination numkeys key key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrange.html">ZRANGE key start stop WITHSCORES</a> 通过索引区间返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">ZRANGEBYLEX key min max LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">[ZRANGEBYSCORE key min max <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM key member member …]</a> 移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">ZREVRANGE key start stop WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">ZREVRANGEBYSCORE key max min WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a> 返回有序集中，成员的分数值</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">ZUNIONSTORE destination numkeys key key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">[ZSCAN key cursor <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<h4 id="3-应用场景-1"><a href="#3-应用场景-1" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><ul>
<li>实现排行榜</li>
</ul>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。GEO 的数据结构总共有六个命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash,这里着重讲解几个。</p>
<p>1.GEOADD</p>
<pre class="line-numbers language-none"><code class="language-none">GEOADD key longitude latitude member [longitude latitude member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。例子：</p>
<pre class="line-numbers language-none"><code class="language-none">GEOADD china:city 116.416 39.916 beijing 121.433 34.500 shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2.GEOPOS</p>
<pre class="line-numbers language-none"><code class="language-none">GEOPOS key member [member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从键里面返回所有给定位置元素的位置（经度和纬度），例子：</p>
<pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; GEOPOS china:city beijing
1) 1) &quot;116.41600102186203003&quot;
   2) &quot;39.91599925162866924&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>3.GEODIST</p>
<pre class="line-numbers language-none"><code class="language-none">GEODIST key member1 member2 [m|km|ft|mi]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。指定单位的参数 unit 必须是以下单位的其中一个：（默认为m）</p>
<blockquote>
<p>m  表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km
&quot;748.3058&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>4.GEORADIUS</p>
<pre class="line-numbers language-none"><code class="language-none">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。距离单位和上面的一致，其中后面的选项：</p>
<blockquote>
<p>WITHDIST： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致。<br>WITHCOORD： 将位置元素的经度和维度也一并返回。<br>WITHHASH： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。这个选项主要用于底层应用或者调试， 实际中的作用并不大。</p>
</blockquote>
<p>例子：</p>
<pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1500 km withdist withcoord count 3
1) 1) &quot;guangzhou&quot;
   2) &quot;825.2135&quot;
   3) 1) &quot;113.23300212621688843&quot;
      2) &quot;23.16599912261950323&quot;
2) 1) &quot;xianggang&quot;
   2) &quot;959.1250&quot;
   3) 1) &quot;114.09999936819076538&quot;
      2) &quot;22.19999914574732003&quot;
3) 1) &quot;shanghai&quot;
   2) &quot;1185.2226&quot;
   3) 1) &quot;121.43299788236618042&quot;
      2) &quot;34.49999971716130887&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>什么是基数?</strong></p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p><strong>Redis HyperLogLog 命令</strong></p>
<p>下表列出了 redis HyperLogLog 的基本命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hyperloglog-pfadd.html">PFADD key element1 element1 …</a> 添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hyperloglog-pfcount.html">PFCOUNT key1 key2 …</a> 返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">PFMERGE destkey sourcekey1 sourcekey2 …</a> 将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody></table>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p><strong>Bitmaps介绍</strong></p>
<ul>
<li>Redis提供的Bitmaps这个“数据结构”可以实现对位的操作。Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。</li>
<li>可以把Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在bitmaps中叫做偏移量。</li>
<li>单个bitmaps的最大长度是512MB，即2^32个比特位。</li>
<li>bitmaps的最大优势是节省存储空间。例如，在一个以自增id代表不同用户的系统中，我们只需要512MB空间就可以记录40亿用户的某个单一信息（比如，用户是否希望接收新闻邮件）。</li>
<li>有两种类型的位操作：一类是对特定bit位的操作，比如设置/获取某个特定比特位的值。另一类是批量bit位操作，例如在给定范围内统计为1的比特位个数。</li>
<li>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR以及其它位操作。</li>
</ul>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211214152926376.png" alt="image-20211214152926376"></p>
<p>需要注意的是：BitMap 在 Redis 中并不是一个新的数据类型，其底层是 Redis 实现。</p>
<p><strong>Bitmaps使用场景</strong></p>
<blockquote>
<p>各种实时分析(Real time analytics of all kinds)。<br>存储与对象ID关联的布尔信息，要求高效且高性能(Storing space efficient but high performance boolean information associated with object IDs.)。</p>
</blockquote>
<p><strong>Bitmaps常用命令</strong><br>1.设置值</p>
<pre class="line-numbers language-none"><code class="language-none">setbit key offset value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>setbit命令接收两个参数，</p>
<p>第一个参数表示你要操作的是第几个bit位，第二个参数表示你要将这个位设为何值，可选值只有0,1两个。如果所操作的bit位超过了当前字串的长度，reids会自动增大字串长度。</p>
<p>2 .获取值</p>
<pre class="line-numbers language-none"><code class="language-none">getbit key offset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>getbit只是返回特定bit位的值。如果试图获取的bit位在当前字串长度范围外，该命令返回0。</p>
<p>3 .获取Bitmaps指定范围值为1的个数</p>
<pre class="line-numbers language-none"><code class="language-none">bitcount key [start] [end]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>







<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<p>　　</p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p><strong>事务的工作流程</strong></p>
<p><img src="https://s2.loli.net/2021/12/14/anJYeP4diLWFqfI.png" alt="image-20211214145046188"></p>
<p><strong>定义事务的过程中，命令格式输入错误怎么办?</strong><br>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</p>
<p><strong>定义事务的过程中，命令执行出现错误怎么办?</strong></p>
<p>指命令格式正确，但是无法正确的执行。例如对list进行incr操作。Redis会将能正确运行的命令会执行，运行错误的命令不会被执行。</p>
<p>注意:已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</p>
<p><strong>Redis事务没有隔离级别的概念：</strong></p>
<p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
<p><strong>Redis不保证原子性：</strong></p>
<p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h3 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h3><p>下表列出了 redis 事务的相关命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a> 取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a> 执行所有事务块内的命令。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a> 标记一个事务块的开始。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a> 取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">[WATCH key <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-watch.html">key …]</a> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
</tbody></table>
<h3 id="Redis事务实操"><a href="#Redis事务实操" class="headerlink" title="Redis事务实操"></a>Redis事务实操</h3><p><strong>正常执行</strong></p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416204151947-1999193750.png" alt="img"></p>
<p><strong>放弃事务</strong></p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416204558119-2028373874.png" alt="img"></p>
<p><strong>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</strong></p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416205137740-1887538258.png" alt="img"></p>
<p><strong>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</strong></p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416205714294-77806844.png" alt="img"></p>
<h3 id="Redis-锁"><a href="#Redis-锁" class="headerlink" title="Redis-锁"></a>Redis-锁</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>
<p><strong>使用watch</strong></p>
<p>案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416210530600-1167641209.png" alt="img"></p>
<p>案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416211144923-1469436233.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1659331/201904/1659331-20190416211149567-1618751187.png" alt="img"></p>
<p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。</p>
<p>故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>使用setnx设置一个公共锁</p>
<pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">setnx lock-key value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p>
<ul>
<li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li>
<li>对于返回设置失败的，不具有控制权，排队或等待</li>
</ul>
<p>操作完毕通过del操作释放锁</p>
<p><img src="https://s2.loli.net/2021/12/14/UdEKTcNo7QaVlAn.png" alt="image-20211214150404019"></p>
<p>注意：使用分布式锁时，要保证锁住的是同一个key。</p>
<p>假设已经进行了加锁，但是因为宕机或者出现异常未释放锁，就造成了所谓的“死锁”。在 Redis 2.8 的版本后，Redis 就为我们提供了一条组合命令 <code>SET key value ex seconds nx</code>，加锁的同时设置过期时间，避免了死锁。</p>
<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis是Redis官方推荐的Java连接开发工具。</p>
<p>Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。</p>
<p>SpringDataRedis相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用如：SpringCache</p>
<h3 id="Jedis与Lettuce对比"><a href="#Jedis与Lettuce对比" class="headerlink" title="Jedis与Lettuce对比"></a><strong>Jedis与Lettuce对比</strong></h3><p>这两个都是用于提供连接Redis的客户端。</p>
<p>Jedis是直接连接Redis，非线程安全，在性能上，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，资源消耗阶梯式增大，连接成</p>
<p>本就较高了。</p>
<p>Lettuce的连接是基于Netty的，Netty 是一个多线程、事件驱动的 I/O 框架。连接实例可以在多个线程间共享，当多线程使用同一连接实</p>
<p>例时，是线程安全的。</p>
<h3 id="SpringBoot使用Redis"><a href="#SpringBoot使用Redis" class="headerlink" title="SpringBoot使用Redis"></a>SpringBoot使用Redis</h3><ol>
<li><p>导入依赖</p>
</li>
<li><p>添加配置文件</p>
</li>
<li><p>不推荐使用原生配置的RedisTemplate，推荐自定义的RedisTemplate</p>
</li>
<li><p>创建Redis的工具类，RedisUtil，方便操作</p>
</li>
</ol>
<h2 id="Redis依赖"><a href="#Redis依赖" class="headerlink" title="Redis依赖"></a>Redis依赖</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Redis自动配置类"><a href="#Redis自动配置类" class="headerlink" title="Redis自动配置类"></a>Redis自动配置类</h2><p>我们可以在spring-boot-autoConfigure包下查看到各种自动配置类，查找到redis的自动配置类，进入RedisAutoConfiguration，查看源码。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>
    proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisOperations</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">LettuceConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">JedisConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisAutoConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>
        name <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"redisTemplate"</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> template<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>
    <span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span> <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">StringRedisTemplate</span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> template<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通常使用StringRedisTemplate，StringRedisTemplate是RedisTemplate的子类，功能更多。</p>
<h2 id="自定义的RedisTemplate"><a href="#自定义的RedisTemplate" class="headerlink" title="自定义的RedisTemplate"></a>自定义的RedisTemplate</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">myRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnknownHostException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Json序列化配置</span>
        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);方法过期，不建议使用</span>
        om<span class="token punctuation">.</span><span class="token function">activateDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">LaissezFaireSubTypeValidator</span><span class="token punctuation">.</span>instance<span class="token punctuation">,</span> <span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">,</span> <span class="token class-name">JsonTypeInfo<span class="token punctuation">.</span>As</span><span class="token punctuation">.</span>PROPERTY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// String 的序列化</span>
        <span class="token class-name">StringRedisSerializer</span> stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// key采用String的序列化方式</span>
        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// hash的key也采用String的序列化方式</span>
        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// value序列化方式采用jackson</span>
        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// hash的value序列化方式采用jackson</span>
        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> template<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="RedisUtil"><a href="#RedisUtil" class="headerlink" title="RedisUtil"></a>RedisUtil</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.example.util;
import java.io.Serializable;
import java.util.concurrent.TimeUnit;
import javax.annotation.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Component;

@Component
public class RedisUtil &#123;
    private static final Logger logger &#x3D; LoggerFactory.getLogger(RedisUtil.class);

    @Resource
    private RedisTemplate&lt;Serializable, Serializable&gt; redisTemplate;

    &#x2F;**
     * 前缀
     *&#x2F;
    public static final String KEY_PREFIX_VALUE &#x3D; &quot;itstyle:seckill:value:&quot;;


    &#x2F;**
     * 缓存value操作
     *
     * @param k
     * @param v
     * @param time
     * @return
     *&#x2F;
    public boolean cacheValue(String k, Serializable v, long time) &#123;
        String key &#x3D; KEY_PREFIX_VALUE + k;
        try &#123;
            ValueOperations&lt;Serializable, Serializable&gt; valueOps &#x3D; redisTemplate.opsForValue();
            valueOps.set(key, v);
            &#x2F;&#x2F;redisTemplate.opsForValue().set(key, v);
            if (time &gt; 0) redisTemplate.expire(key, time, TimeUnit.SECONDS); &#x2F;&#x2F;设置过期时间
            return true;
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;缓存[&#123;&#125;]失败, value[&#123;&#125;]&quot;, key, v, t);
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 缓存value操作
     *
     * @param k
     * @param v
     * @param time
     * @param unit
     * @return boolean
     *&#x2F;
    public boolean cacheValue(String k, Serializable v, long time, TimeUnit unit) &#123;
        String key &#x3D; KEY_PREFIX_VALUE + k;
        try &#123;
            ValueOperations&lt;Serializable, Serializable&gt; valueOps &#x3D; redisTemplate.opsForValue();
            valueOps.set(key, v);
            if (time &gt; 0) redisTemplate.expire(key, time, unit);
            return true;
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;缓存[&#123;&#125;]失败, value[&#123;&#125;]&quot;, key, v, t);
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 缓存value操作
     *
     * @param k
     * @param v
     * @return
     *&#x2F;
    public boolean cacheValue(String k, Serializable v) &#123;
        &#x2F;&#x2F;-1表示不设置过期时间
        return cacheValue(k, v, -1);
    &#125;

    &#x2F;**
     * 判断缓存是否存在
     *
     * @param k
     * @return
     *&#x2F;
    public boolean containsValueKey(String k) &#123;
        String key &#x3D; KEY_PREFIX_VALUE + k;
        try &#123;
            return redisTemplate.hasKey(key);
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;判断缓存存在失败key[&quot; + key + &quot;, error[&quot; + t + &quot;]&quot;);
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 获取缓存
     *
     * @param k
     * @return
     *&#x2F;
    public Serializable getValue(String k) &#123;
        try &#123;
            ValueOperations&lt;Serializable, Serializable&gt; valueOps &#x3D; redisTemplate.opsForValue();
            return valueOps.get(KEY_PREFIX_VALUE + k);
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;获取缓存失败key[&quot; + KEY_PREFIX_VALUE + k + &quot;, error[&quot; + t + &quot;]&quot;);
        &#125;
        return null;
    &#125;

    &#x2F;**
     * 移除缓存
     *
     * @param k
     * @return
     *&#x2F;
    public boolean removeValue(String k) &#123;
        String key &#x3D; KEY_PREFIX_VALUE + k;
        try &#123;
            redisTemplate.delete(key);
            return true;
        &#125; catch (Throwable t) &#123;
            logger.error(&quot;获取缓存失败key[&quot; + key + &quot;, error[&quot; + t + &quot;]&quot;);
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 递增
     *
     * @param k
     * @param delta 要增加几(大于0)
     * @return
     *&#x2F;
    public long incr(String k, long delta) &#123;
        String key &#x3D; KEY_PREFIX_VALUE + k;
        if (delta &lt; 0) &#123;
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        &#125;
        return redisTemplate.opsForValue().increment(key, delta);
    &#125;

    &#x2F;**
     * 递减
     *
     * @param k     键
     * @param delta 要减少几(小于0)
     * @return
     *&#x2F;
    public long decr(String k, long delta) &#123;
        String key &#x3D; KEY_PREFIX_VALUE + k;
        if (delta &lt; 0) &#123;
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        &#125;
        return redisTemplate.opsForValue().increment(key, -delta);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里有更全的Redis工具类，来自网络：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tom5982160/article/details/83509023">https://blog.csdn.net/tom5982160/article/details/83509023</a></p>
<h1 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h1><h2 id="redis-conf-配置项说明如下："><a href="#redis-conf-配置项说明如下：" class="headerlink" title="redis.conf 配置项说明如下："></a>redis.conf 配置项说明如下：</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="center">配置项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center"><code>daemonize no</code></td>
<td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center"><code>pidfile /var/run/redis.pid</code></td>
<td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center"><code>port 6379</code></td>
<td align="left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td align="left">4</td>
<td align="center"><code>bind 127.0.0.1</code></td>
<td align="left">绑定的主机地址</td>
</tr>
<tr>
<td align="left">5</td>
<td align="center"><code>timeout 300</code></td>
<td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td>
</tr>
<tr>
<td align="left">6</td>
<td align="center"><code>loglevel notice</code></td>
<td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td align="left">7</td>
<td align="center"><code>logfile 路径名（‘’表示控制台输出）</code></td>
<td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td align="left">8</td>
<td align="center"><code>databases 16</code></td>
<td align="left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td>
</tr>
<tr>
<td align="left">9</td>
<td align="center"><code>save 900 1</code> <br /><code>save 300 10</code> <br /><code>save 60 10000</code></td>
<td align="left">快照配置<br />注释掉“save”这一行配置项就可以让保存数据库功能失效<br />设置sedis进行数据库镜像的频率。  <br />900秒（15分钟）内至少1个key值改变（则进行数据库保存–持久化）   <br />300秒（5分钟）内至少10个key值改变（则进行数据库保存–持久化）  <br />60秒（1分钟）内至少10000个key值改变（则进行数据库保存–持久化）</td>
</tr>
<tr>
<td align="left">10</td>
<td align="center"><code>rdbcompression yes</code></td>
<td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td align="left">11</td>
<td align="center"><code>dbfilename dump.rdb</code></td>
<td align="left">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td align="left">12</td>
<td align="center"><code>dir ./</code></td>
<td align="left">指定本地数据库存放目录</td>
</tr>
<tr>
<td align="left">13</td>
<td align="center"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td align="left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td align="left">14</td>
<td align="center"><code>masterauth &lt;master-password&gt;</code></td>
<td align="left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td align="left">15</td>
<td align="center"><code>requirepass psw</code></td>
<td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td align="left">16</td>
<td align="center"><code> maxclients 128</code></td>
<td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td align="left">17</td>
<td align="center"><code>maxmemory &lt;bytes&gt;</code></td>
<td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td align="left">18</td>
<td align="center"><code>appendonly no</code></td>
<td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td align="left">19</td>
<td align="center"><code>appendfilename appendonly.aof</code></td>
<td align="left">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td align="left">20</td>
<td align="center"><code>appendfsync everysec</code></td>
<td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td align="left">21</td>
<td align="center"><code>vm-enabled no</code></td>
<td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td align="left">22</td>
<td align="center"><code>vm-swap-file /tmp/redis.swap</code></td>
<td align="left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td align="left">23</td>
<td align="center"><code>vm-max-memory 0</code></td>
<td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td align="left">24</td>
<td align="center"><code>vm-page-size 32</code></td>
<td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td align="left">25</td>
<td align="center"><code>vm-pages 134217728</code></td>
<td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="center"><code>vm-max-threads 4</code></td>
<td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td>
</tr>
<tr>
<td align="left">27</td>
<td align="center"><code>glueoutputbuf yes</code></td>
<td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td align="left">28</td>
<td align="center"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td>
<td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td align="left">29</td>
<td align="center"><code>activerehashing yes</code></td>
<td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td align="left">30</td>
<td align="center"><code>include /path/to/local.conf</code></td>
<td align="left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
<tr>
<td align="left">31</td>
<td align="center"><code>stop-writes-on-bgsave-error yes</code></td>
<td align="left">当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WYA1993/article/details/83096088">redis.conf</a></p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="什么是Redis持久化"><a href="#什么是Redis持久化" class="headerlink" title="什么是Redis持久化?"></a>什么是Redis持久化?</h2><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，如下所示：</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java5-1566526018.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p><strong>这样做有什么问题呢？</strong></p>
<p>其实，只要稍微有点计算机基础知识的人都知道，存储在内存当中的数据，只要服务器关机(各种原因引起的)，内存中的数据就会消失了，不仅服务器关机会造成数据消失，Redis服务器守护进程退出，内存中的数据也一样会消失。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java1-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p>对于只把Redis当缓存来用的项目来说，数据消失或许问题不大，重新从数据源把数据加载进来就可以了，但如果直接把用户提交的业务数据存储在Redis当中，把Redis作为数据库来使用，在其放存储重要业务数据，那么Redis的内存数据丢失所造成的影响也许是毁灭性。</p>
<p>为了避免内存中数据丢失，Redis提供了对持久化的支持，我们可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java3-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p>Redis提供了RDB和AOF两种不同的数据持久化方式，下面我们就来详细介绍一下这种不同的持久化方式吧。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>了解RDB，先了解什么是快照。</p>
<p>快照技术主要是在操作系统以及存储技术上实现的一种记录某一时间系统状态的技术。近来，Oracle等数据库厂家以及Vmware等虚拟化产品也把这种技术引入各自的数据保护当中。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21749155">https://zhuanlan.zhihu.com/p/21749155</a></p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p>
<h3 id="开启RDB持久化方式"><a href="#开启RDB持久化方式" class="headerlink" title="开启RDB持久化方式"></a>开启RDB持久化方式</h3><p>开启RDB持久化方式很简单，客户端可以通过向Redis服务器发送save或bgsave命令让服务器生成rdb文件，或者通过服务器配置文件指定触发RDB条件。</p>
<h4 id="1-save命令"><a href="#1-save命令" class="headerlink" title="1. save命令"></a>1. save命令</h4><p>save命令是一个同步操作。</p>
<pre class="line-numbers language-none"><code class="language-none"># 同步数据到磁盘上
&gt; save <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java4-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p>当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。</p>
<p>如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令。</p>
<h4 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h4><p>与save命令不同，bgsave命令是一个异步操作。</p>
<pre class="line-numbers language-none"><code class="language-none"># 异步保存数据集到磁盘上
&gt; bgsave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java5-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p>当客户端发服务发出bgsave命令时，Redis服务器主进程会forks一个子进程来数据同步问题，在将数据保存到rdb文件之后，子进程会退出。</p>
<p>所以，与save命令相比，Redis服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。</p>
<h4 id="3-服务器配置自动触发"><a href="#3-服务器配置自动触发" class="headerlink" title="3. 服务器配置自动触发"></a>3. 服务器配置自动触发</h4><p>除了通过客户端发送命令外，还有一种方式，就是在Redis配置文件中的save指定到达触发RDB持久化的条件，比如【多少秒内至少达到多少写操作】就开启RDB数据同步。</p>
<p>例如我们可以在配置文件redis.conf指定如下的选项：</p>
<pre class="line-numbers language-none"><code class="language-none"># 900s内至少达到一条写命令
save 900 1
# 300s内至少达至10条写命令
save 300 10
# 60s内至少达到10000条写命令
save 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后在启动服务器时加载配置文件。</p>
<pre class="line-numbers language-none"><code class="language-none"># 启动服务器加载配置文件
redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</p>
<h3 id="rdb文件"><a href="#rdb文件" class="headerlink" title="rdb文件"></a>rdb文件</h3><p>前面介绍了三种让服务器生成rdb文件的方式，无论是由主进程生成还是子进程来生成，其过程如下：</p>
<ul>
<li>生成临时rdb文件，并写入数据。</li>
<li>完成数据写入，用临时文代替代正式rdb文件。</li>
<li>删除原来的db文件。</li>
</ul>
<p>RDB默认生成的文件名为dump.rdb，当然，我可以通过配置文件进行更加详细配置，比如在单机下启动多个redis服务器进程时，可以通过端口号配置不同的rdb名称，如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none"># 是否压缩rdb文件
rdbcompression yes

# rdb文件的名称
dbfilename redis-6379.rdb

# rdb文件保存目录
dir ~&#x2F;redis&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>RDB的几个优点</strong></p>
<ul>
<li>与AOF方式相比，通过rdb文件恢复数据比较快。</li>
<li>rdb文件非常紧凑，适合于数据备份。</li>
<li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li>
</ul>
<p><strong>RDB的几个缺点</strong></p>
<ul>
<li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li>
<li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li>
<li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Redis的另外一个持久化方式：AOF(Append-only file)。</p>
<p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java9-1566526020.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p><strong>开启AOF持久化方式</strong></p>
<p>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：</p>
<pre class="line-numbers language-none"><code class="language-none"># 开启aof机制
appendonly yes

# aof文件名
appendfilename &quot;appendonly.aof&quot;

# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no
appendfsync always

# 默认不重写aof文件
no-appendfsync-on-rewrite no

# 保存目录
dir ~&#x2F;redis&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>三种写入策略</strong></p>
<p>在上面的配置文件中，我们可以通过appendfsync选项指定写入策略,有三个选项</p>
<pre class="line-numbers language-none"><code class="language-none">appendfsync always
# appendfsync everysec
# appendfsync no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="1-always"><a href="#1-always" class="headerlink" title="1. always"></a>1. always</h4><p>客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</p>
<h4 id="2-everysec"><a href="#2-everysec" class="headerlink" title="2. everysec"></a>2. everysec</h4><p>appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。</p>
<h4 id="3-no"><a href="#3-no" class="headerlink" title="3. no"></a>3. no</h4><p>Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</p>
<h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。</p>
<pre class="line-numbers language-none"><code class="language-none">incr num 1
incr num 2
incr num 3
incr num 4
incr num 5
incr num 6
...
incr num 100000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：</p>
<pre class="line-numbers language-none"><code class="language-none">set num 100000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。</p>
<h3 id="两种重写方式"><a href="#两种重写方式" class="headerlink" title="两种重写方式"></a>两种重写方式</h3><p>通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。</p>
<pre class="line-numbers language-none"><code class="language-none"># 默认不重写aof文件
no-appendfsync-on-rewrite no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 让服务器异步重写追加aof文件命令</span>
<span class="token operator">></span> bgrewriteaof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理，如下所示：</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/java10-1566526020.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p>重写aof文件的好处</p>
<ul>
<li>压缩aof文件，减少磁盘占用量。</li>
<li>将aof的命令压缩为最小命令集，加快了数据恢复的速度。</li>
</ul>
<h3 id="AOF文件损坏"><a href="#AOF文件损坏" class="headerlink" title="AOF文件损坏"></a>AOF文件损坏</h3><p>在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。</p>
<p>1、备份现在aof文件，以防万一。</p>
<p>2、使用redis-check-aof命令修复aof文件，该命令格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none"># 修复aof日志文件
$ redis-check-aof -fix file.aof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>3、重启Redis服务器，加载已经修复的aof文件，恢复数据。</p>
<h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul>
<li>AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li>
</ul>
<h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul>
<li>AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。</li>
<li>恢复数据的速度比RDB慢。</li>
</ul>
<hr>
<h2 id="选择RDB还是AOF呢？"><a href="#选择RDB还是AOF呢？" class="headerlink" title="选择RDB还是AOF呢？"></a>选择RDB还是AOF呢？</h2><p>通过上面的介绍，我们了解了RDB与AOF各自的优点与缺点，到底要如何选择呢？</p>
<p>通过下面的表示，我们可以从几个方面对比一下RDB与AOF,在应用时，要根本自己的实际需求，选择RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行IO操作，会严重影响服务器性能，因此有时候不得不做出选择。</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/08/java10-1566526020-1.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p>
<p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="单机一主两从实现"><a href="#单机一主两从实现" class="headerlink" title="单机一主两从实现"></a>单机一主两从实现</h2><ol>
<li>复制三份相同的配置文件</li>
<li>对配置文件进行修改，修改端口，修改rdb文件，修改日志文件的位置</li>
<li>根据对应的配置文件启动相应的redis服务器（单机情况下，一个端口对应一个服务）</li>
</ol>
<p>如何解决一主多从的情况下主机或从机挂掉，通过集群解决。</p>
<p>主从配置可以通过命令配置，也可以通过配置文件进行主从配置，配置文件时永久配置，命令行配置是暂时的，redis服务重新启动后，需要再次配置。</p>
<p>主机断开连接，从机使用<code>slaveof  no  one</code>命令是自己变成主机，其他节点再手动连接到这个主节点。当主机重新连接后，需要将从机重新连接到主机。</p>
<h2 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave),数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p>Redis的Master和Slave并没有特别不同的地方，Slave也可以拥有自己的Slave，并由此形成主从链。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/907596-20180710175627988-299575978.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411160437949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MjY0MDA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><ol>
<li><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
</li>
<li><p>容灾快速恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
</li>
<li><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
</li>
<li><p>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</p>
</li>
<li><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
</li>
</ol>
<h2 id="Redis主从复制的问题"><a href="#Redis主从复制的问题" class="headerlink" title="Redis主从复制的问题"></a>Redis主从复制的问题</h2><ol>
<li><p>一旦 主节点宕机，从节点 晋升成 主节点，同时需要修改 应用方 的 主节点地址，还需要命令所有 从节点 去 复制 新的主节点，整个过程需要 人工干预。</p>
</li>
<li><p>主节点 的 写能力 受到 单机的限制。</p>
</li>
<li><p>主节点 的 存储能力 受到 单机的限制。</p>
</li>
<li><p>原生复制 的弊端在早期的版本中也会比较突出，比如：Redis 复制中断 后，从节点 会发起 <code>psync</code>。此时如果 同步不成功，则会进行 全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</p>
</li>
</ol>
<h2 id="Redis的全量同步和增量同步"><a href="#Redis的全量同步和增量同步" class="headerlink" title="Redis的全量同步和增量同步"></a>Redis的全量同步和增量同步</h2><ul>
<li>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br>　　1）从服务器连接主服务器，发送SYNC命令；<br>  　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>  　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>  　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>  　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>  　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ul>
<p>　　完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p>
<ul>
<li><p>增量同步<br>　　Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
</li>
<li><p>Redis主从同步策略<br>　　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
</li>
</ul>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis 的 主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，当主节点恢复连接后需要重新通知从节点更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制 来解决这个问题。</p>
<h3 id="Redis-Sentinel的主要功能"><a href="#Redis-Sentinel的主要功能" class="headerlink" title="Redis Sentinel的主要功能"></a>Redis Sentinel的主要功能</h3><p><code>Sentinel</code> 的主要功能包括 <strong>主节点存活检测</strong>、<strong>主从运行情况检测</strong>、<strong>自动故障转移</strong> （<code>failover</code>）、<strong>主从切换</strong>。<code>Redis</code> 的 <code>Sentinel</code> 最小配置是 <strong>一主一从</strong>。</p>
<p><code>Redis</code> 的 <code>Sentinel</code> 系统可以用来管理多个 <code>Redis</code> 服务器，该系统可以执行以下四个任务：</p>
<ul>
<li><strong>监控</strong></li>
</ul>
<p><code>Sentinel</code> 会不断的检查 <strong>主服务器</strong> 和 <strong>从服务器</strong> 是否正常运行。</p>
<ul>
<li><strong>通知</strong></li>
</ul>
<p>当被监控的某个 <code>Redis</code> 服务器出现问题，<code>Sentinel</code> 通过 <code>API</code> <strong>脚本</strong> 向 <strong>管理员</strong> 或者其他的 <strong>应用程序</strong> 发送通知。</p>
<ul>
<li><strong>自动故障转移</strong></li>
</ul>
<p>当 <strong>主节点</strong> 不能正常工作时，<code>Sentinel</code> 会开始一次 <strong>自动的</strong> 故障转移操作，它会将与 <strong>失效主节点</strong> 是 <strong>主从关系</strong> 的其中一个 <strong>从节点</strong> 升级为新的 <strong>主节点</strong>，并且将其他的 <strong>从节点</strong> 指向 <strong>新的主节点</strong>，主节点恢复正常工作后，成为从节点，指向新的主节点。</p>
<ul>
<li><strong>配置提供者</strong></li>
</ul>
<p>在 <code>Redis Sentinel</code> 模式下，<strong>客户端应用</strong> 在初始化时连接的是 <code>Sentinel</code> <strong>节点集合</strong>，从中获取 <strong>主节点</strong> 的信息。</p>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p>
<ul>
<li><strong>主观下线</strong></li>
</ul>
<p><strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</p>
<ul>
<li><strong>客观下线</strong></li>
</ul>
<p><strong>客观下线</strong> 只适用于 <strong>主节点</strong>。如果 <strong>主节点</strong> 出现故障，<code>Sentinel</code> 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。如果超过 <code>&lt;quorum&gt;</code> 个数的节点判定 <strong>主节点</strong> 不可达，则该 <code>Sentinel</code> 节点会判断 <strong>主节点</strong> 为 <strong>客观下线</strong>。</p>
<p><strong>详细博客连接</strong></p>
<p>作者：零壹技术栈<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903663362637832">https://juejin.cn/post/6844903663362637832</a></p>
<h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当查询Redis中没有的数据时，该查询会下沉到数据库层，同时数据库层也没有该数据，当这种情况大量出现或被恶意攻击时，接口的访</p>
<p>问全部透过Redis访问数据库，而数据库中也没有这些数据，我们称这种现象为”缓存穿透”。缓存穿透会穿透Redis的保护，提升底层数据</p>
<p>库的负载压力，同时这类穿透查询没有数据返回也造成了网络和计算资源的浪费。</p>
<p><img src="https://s2.loli.net/2021/12/14/WOfAPsCaLb1JQ7k.png" alt="image-20210421210139942"></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>在接口访问层对用户做校验，如接口传参、登陆状态、n秒内访问接口的次数；</li>
<li>利用布隆过滤器，将数据库层有的数据key存储在位数组中，以判断访问的key在底层数据库中是否存在；</li>
</ul>
<p>第一种解决方案很好理解，这里介绍一下第二种方案，在前一篇文章中我们介绍了Redis的布隆过滤器，我们知道布隆过滤器可以判断key一定不在集合内以及key极有可能在集合内。</p>
<p>基于布隆过滤器，我们可以先将数据库中数据的key存储在布隆过滤器的位数组中，每次客户端查询数据时先访问Redis：</p>
<ul>
<li>如果Redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内；</li>
<li>如果布隆过滤器告诉我们该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作；</li>
<li>如果布隆过滤器告诉我们该key极有可能在底层数据库内存在，那么将查询下推到底层数据库即可；</li>
</ul>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210547359.png" alt="image-20210421210547359"></p>
<p>布隆过滤器有误判率，虽然不能完全避免数据穿透的现象，但已经可以将99.99%的穿透查询给屏蔽在Redis层了，极大的降低了底层数据库的压力，减少了资源浪费。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a><strong>什么是布隆过滤器</strong></h3><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/12594982.html"> Redis布隆过滤器</a></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存穿透从名词上可能很难区分开来，它们的区别是：穿透表示底层数据库没有数据且缓存内也没有数据，击穿表示底层数据</p>
<p>库有数据而缓存内没有数据。当热点数据key从缓存内失效时，大量访问同时请求这个数据，就会将查询下沉到数据库层，此时数据库层</p>
<p>的负载压力会骤增，我们称这种现象为”缓存击穿”。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210107128.png" alt="image-20210421210107128"></p>
<p>解决方案：</p>
<ul>
<li><p>延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口；</p>
</li>
<li><p>利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时</p>
<p>穿过Redis访问底层数据库；</p>
</li>
</ul>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210528642.png" alt="image-20210421210528642"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是缓存击穿的”大面积”版，缓存击穿是数据库缓存到Redis内的热点数据失效导致大量并发查询穿过redis直接击打到底层数据</p>
<p>库，而缓存雪崩是指Redis中大量的key几乎同时过期，然后大量并发查询穿过redis击打到底层数据库上，此时数据库层的负载压力会骤</p>
<p>增，我们称这种现象为”缓存雪崩”。例如微博的热搜。事实上缓存雪崩相比于缓存击穿更容易发生，对于大多数公司来讲，同时超大并发</p>
<p>量访问同一个过时key的场景的确太少见了，而大量key同时过期，大量用户访问这些key的几率相比缓存击穿来说明显更大。</p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210358622.png" alt="image-20210421210358622"></p>
<p><strong>解决方案：</strong></p>
<ul>
<li>在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期；</li>
<li>对于一定要在固定时间让key失效的场景(例如每日12点准时更新所有最新排名)，可以在固定的失效时间时在接口服务端设置随机延时，将请求的时间打散，让一部分查询先将数据缓存起来；</li>
<li>延长热点key的过期时间或者设置永不过期，这一点和缓存击穿中的方案一样；</li>
</ul>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210637280.png" alt="image-20210421210637280"></p>
<p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210648811.png" alt="image-20210421210648811"></p>
<p>相关博客地址：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1666384">https://cloud.tencent.com/developer/article/1666384</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">KTS</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://wzykt.github.io/2021/12/14/redis/">https://wzykt.github.io/2021/12/14/redis/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">KTS</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/01/18/ji-suan-ji-wang-luo-mian-shi-ti-mu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/images/14.jpg" class="responsive-img" alt="在浏览器输入 URL 回车之后发生了什么">
                        
                        <span class="card-title">在浏览器输入 URL 回车之后发生了什么</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TCP-IP/">
                        <span class="chip bg-color">TCP/IP</span>
                    </a>
                    
                    <a href="/tags/HTTP/">
                        <span class="chip bg-color">HTTP</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/12/13/hong-bao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/images/15.jpg" class="responsive-img" alt="抢红包实战案例">
                        
                        <span class="card-title">抢红包实战案例</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%A1%88%E4%BE%8B/" class="post-category">
                                    案例
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">
                        <span class="chip bg-color">分布式锁</span>
                    </a>
                    
                    <a href="/tags/Redis/">
                        <span class="chip bg-color">Redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="song"
                   id="003UkWuI0E8U0l"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <a href="/about" target="_blank">KTS</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "11";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis"></div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
