<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Netty, KTS Blog">
    <meta name="description" content="Netty本文转载自：Netty
一、概述1、什么是NettyNetty is an asynchronous event-driven network application framework
for rapid development">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Netty | KTS Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">KTS Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">KTS Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/images/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Netty</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Netty/">
                                <span class="chip bg-color">Netty</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%BD%AC%E8%BD%BD/" class="post-category">
                                转载
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-29
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    33.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>本文转载自：<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#Netty">Netty</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><pre class="line-numbers language-none"><code class="language-none">Netty is an asynchronous event-driven network application framework
for rapid development of maintainable high performance protocol servers &amp; clients.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>
<h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p>
<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>
</ul>
<p>Netty 对 API 进行增强，使之更易用，如</p>
<ul>
<li>FastThreadLocal =&gt; ThreadLocal</li>
<li>ByteBuf =&gt; ByteBuffer</li>
</ul>
<h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><pre class="line-numbers language-none"><code class="language-none">public class HelloServer &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器
        new ServerBootstrap()
                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector
                .group(new NioEventLoopGroup())
                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现
                .channel(NioServerSocketChannel.class)
                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作
            	&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）
            	&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器
                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;
                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String
                        nioSocketChannel.pipeline().addLast(new StringDecoder());
                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果
                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;
                            @Override
                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;
                                System.out.println(s);
                            &#125;
                        &#125;);
                    &#125;
                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口
                &#125;).bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><pre class="line-numbers language-none"><code class="language-none">public class HelloClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        new Bootstrap()
                .group(new NioEventLoopGroup())
                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现
                .channel(NioSocketChannel.class)
                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）
                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器
                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;
                    @Override
                    protected void initChannel(Channel channel) throws Exception &#123;
                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出
                        channel.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                &#x2F;&#x2F; 指定要连接的服务器和端口
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))
                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect
                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕
                .sync()
                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作
                .channel()
                &#x2F;&#x2F; 写入消息并清空缓冲区
                .writeAndFlush(&quot;hello world&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png" alt="img"></a></p>
<h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul>
<li><p>channel 可以理解为数据的通道</p>
</li>
<li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p>
</li>
<li><p>handler 可以理解为数据的处理工序</p>
<ul>
<li><p>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p>
<ul>
<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>
</ul>
</li>
<li><p>handler 分 Inbound 和 Outbound 两类</p>
<ul>
<li>Inbound 入站</li>
<li>Outbound 出站</li>
</ul>
</li>
</ul>
</li>
<li><p>eventLoop 可以理解为处理数据的工人</p>
<ul>
<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>
<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>
</ul>
</li>
</ul>
<h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p>
<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>
<p>它的继承关系如下</p>
<ul>
<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>继承自 netty 自己的 OrderedEventExecutor<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p><strong>事件循环组</strong> EventLoopGroup</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><pre class="line-numbers language-none"><code class="language-none">public class TestEventLoop &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程
        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);
        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop
        System.out.println(group.next());
        System.out.println(group.next());

        &#x2F;&#x2F; 通过EventLoop执行普通任务
        group.next().execute(()-&gt;&#123;
            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);
        &#125;);

        &#x2F;&#x2F; 通过EventLoop执行定时任务
        group.next().scheduleAtFixedRate(()-&gt;&#123;
            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);
        &#125;, 0, 1, TimeUnit.SECONDS);
        
        &#x2F;&#x2F; 优雅地关闭
        group.shutdownGracefully();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果如下</p>
<pre class="line-numbers language-none"><code class="language-none">io.netty.channel.nio.NioEventLoop@7bb11784
io.netty.channel.nio.NioEventLoop@33a10788
nioEventLoopGroup-2-1 hello
nioEventLoopGroup-2-2 hello2
nioEventLoopGroup-2-2 hello2
nioEventLoopGroup-2-2 hello2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关闭 EventLoopGroup</strong></p>
<p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopServer &#123;
    public static void main(String[] args) &#123;
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf buf &#x3D; (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));

                            &#125;
                        &#125;);
                    &#125;
                &#125;)
                .bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopClient &#123;
    public static void main(String[] args) throws IOException, InterruptedException &#123;
        Channel channel &#x3D; new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        socketChannel.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))
                .sync()
                .channel();
        System.out.println(channel);
        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);
        System.in.read();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;
    public static void main(String[] args) &#123;
        new ServerBootstrap()
            	&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件
                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))
            
				...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>多个客户端分别发送 <code>hello</code> 结果</p>
<pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-3-1 hello1
nioEventLoopGroup-3-2 hello2
nioEventLoopGroup-3-1 hello3
nioEventLoopGroup-3-2 hello4
nioEventLoopGroup-3-2 hello4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件，并且根据轮询的形式保证每个EventLoop都有对应的Channel</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png" alt="img"></a></p>
<h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup
        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();
        
        new ServerBootstrap()
                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理
                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf buf &#x3D; (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));
                                &#x2F;&#x2F; 调用下一个handler
                                ctx.fireChannelRead(msg);
                            &#125;
                        &#125;)
                        &#x2F;&#x2F; 该handler绑定自定义的Group
                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf buf &#x3D; (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));
                            &#125;
                        &#125;);
                    &#125;
                &#125;)
                .bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>启动四个客户端发送数据</p>
<pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-4-1 hello1
defaultEventLoopGroup-2-1 hello1
nioEventLoopGroup-4-2 hello2
defaultEventLoopGroup-2-2 hello2
nioEventLoopGroup-4-1 hello3
defaultEventLoopGroup-2-3 hello3
nioEventLoopGroup-4-2 hello4
defaultEventLoopGroup-2-4 hello4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png" alt="img"></a></p>
<h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>
<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>
<pre class="line-numbers language-none"><code class="language-none">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;
    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);
    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup
    EventExecutor executor &#x3D; next.executor();
    
    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中
    if (executor.inEventLoop()) &#123;
        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务
        next.invokeChannelRead(m);
    &#125; else &#123;
        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行
        executor.execute(new Runnable() &#123;
            public void run() &#123;
                next.invokeChannelRead(m);
            &#125;
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>
</ul>
<h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p>
<ul>
<li>close() 可以用来关闭Channel</li>
<li>closeFuture() 用来处理 Channel 的关闭<ul>
<li>sync 方法作用是同步等待 Channel 关闭</li>
<li>而 addListener 方法是异步等待 Channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法用于添加处理器</li>
<li>write() 方法将数据写入<ul>
<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>
<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>
</ul>
</li>
<li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li>
</ul>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class MyClient &#123;
    public static void main(String[] args) throws IOException, InterruptedException &#123;
        ChannelFuture channelFuture &#x3D; new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        socketChannel.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程
            	&#x2F;&#x2F; NIO线程：NioEventLoop 中的线程
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
        
        &#x2F;&#x2F; 阻塞住，该方法用于等待连接真正建立
        &#x2F;&#x2F;不使用该方法会使当前线程继续向下执行，但是因为链接还未建立，导致下面的channel还没有链接，channel对象存在  
        channelFuture.sync();
        
        &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象
        Channel channel &#x3D; channelFuture.channel();
        channel.writeAndFlush(&quot;hello world&quot;);
        System.in.read();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p>
<p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>
<p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p>
<p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p>
<p><strong>addListener方法</strong></p>
<p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyClient &#123;
    public static void main(String[] args) throws IOException, InterruptedException &#123;
        ChannelFuture channelFuture &#x3D; new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        socketChannel.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程
                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
        
		&#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后
        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法
        channelFuture.addListener(new ChannelFutureListener() &#123;
            @Override
            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;
                Channel channel &#x3D; channelFuture.channel();
                channel.writeAndFlush(&quot;hello world&quot;);
            &#125;
        &#125;);
        System.in.read();
    &#125;
&#125;Cop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ReadClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭
        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();
        
        ChannelFuture channelFuture &#x3D; new Bootstrap()
                .group(group)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        socketChannel.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
        channelFuture.sync();

        Channel channel &#x3D; channelFuture.channel();
        Scanner scanner &#x3D; new Scanner(System.in);

        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送
        new Thread(()-&gt;&#123;
            while (true) &#123;
                String msg &#x3D; scanner.next();
                if (&quot;q&quot;.equals(msg)) &#123;
                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行
                    channel.close();
                    break;
                &#125;
                channel.writeAndFlush(msg);
            &#125;
        &#125;, &quot;inputThread&quot;).start();

        &#x2F;&#x2F; 获得closeFuture对象
        ChannelFuture closeFuture &#x3D; channel.closeFuture();
        System.out.println(&quot;waiting close...&quot;);
        
        &#x2F;&#x2F; 同步等待NIO线程执行完close操作
        &#x2F;&#x2F;sync()阻塞方法
        closeFuture.sync();
        
        &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的
        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);
        
        &#x2F;&#x2F; 关闭EventLoopGroup
        group.shutdownGracefully();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关闭channel</strong></p>
<p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>
<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>
<ul>
<li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得closeFuture对象
ChannelFuture closeFuture &#x3D; channel.closeFuture();

&#x2F;&#x2F; 同步等待NIO线程执行完close操作
closeFuture.sync();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p>
<pre class="line-numbers language-none"><code class="language-none">closeFuture.addListener(new ChannelFutureListener() &#123;
    @Override
    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;
        &#x2F;&#x2F; 等待channel关闭后才执行的操作
        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);
        &#x2F;&#x2F; 关闭EventLoopGroup
        group.shutdownGracefully();
    &#125;
&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>由此可以发现，netty中很多方法都是异步的，针对某些后续操作，不能想当然的在异步方法之后加一些内容，为了保证代码的正确执行，必须保证同步处理或者异步处理。</p>
<h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p>
<p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><pre class="line-numbers language-none"><code class="language-none">public class JdkFuture &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ThreadFactory factory &#x3D; new ThreadFactory() &#123;
            @Override
            public Thread newThread(Runnable r) &#123;
                return new Thread(r, &quot;JdkFuture&quot;);
            &#125;
        &#125;;
        &#x2F;&#x2F; 创建线程池
        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);

        &#x2F;&#x2F; 获得Future对象
        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;

            @Override
            public Integer call() throws Exception &#123;
                TimeUnit.SECONDS.sleep(1);
                return 50;
            &#125;
        &#125;);

        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果
        System.out.println(future.get());
    &#125;
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><pre class="line-numbers language-none"><code class="language-none">public class NettyFuture &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();

        &#x2F;&#x2F; 获得 EventLoop 对象
        EventLoop eventLoop &#x3D; group.next();
        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                return 50;
            &#125;
        &#125;);

        &#x2F;&#x2F; 主线程中获取结果
        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);
        System.out.println(&quot;getNow &quot; + future.getNow());
        System.out.println(&quot;get &quot; + future.get());

        &#x2F;&#x2F; NIO线程中异步获取结果
        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;
            @Override
            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;
                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);
                System.out.println(&quot;getNow &quot; + future.getNow());
            &#125;
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">main 获取结果
getNow null
get 50
nioEventLoopGroup-2-1 获取结果
getNow 50  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p>
<ul>
<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>
<li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>
<li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>
</ul>
<h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p>
<pre class="line-numbers language-none"><code class="language-none">public class NettyPromise &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        &#x2F;&#x2F; 创建EventLoop
        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();
        EventLoop eventLoop &#x3D; group.next();

        &#x2F;&#x2F; 创建Promise对象，用于存放结果
        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);

        new Thread(()-&gt;&#123;
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            &#x2F;&#x2F; 自定义线程向Promise中存放结果
            promise.setSuccess(50);
        &#125;).start();

        &#x2F;&#x2F; 主线程从Promise中获取结果
        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><pre class="line-numbers language-none"><code class="language-none">public class PipeLineServer &#123;
    public static void main(String[] args) &#123;
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler
                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为
    				 	&#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail
                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法
                        &#x2F;&#x2F; 入站时，handler是从head向后调用的
                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);
                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead
                                &#x2F;&#x2F; 将数据传递给下一个handler
                                super.channelRead(ctx, msg);
                            &#125;
                        &#125;);
                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);
                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用
          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));
                                super.channelRead(ctx, msg);
                            &#125;
                        &#125;);
                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法
                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的
                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);
                                super.write(ctx, msg, promise);
                            &#125;
                        &#125;);
                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);
                                super.write(ctx, msg, promise);
                            &#125;
                        &#125;);
                    &#125;
                &#125;)
                .bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果如下</strong></p>
<pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-2-2 Inbound handler 1
nioEventLoopGroup-2-2 Inbound handler 2
nioEventLoopGroup-2-2 Outbound handler 2
nioEventLoopGroup-2-2 Outbound handler 1  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>
<p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p>
<ul>
<li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul>
<li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li>
</ul>
</li>
<li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li>
<li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li>
</ul>
<p><strong>具体结构如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png" alt="img"></a></p>
<p><strong>调用顺序如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png" alt="img"></a></p>
<h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" alt="img"></a></p>
<h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" alt="img"></a></p>
<h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p>
<pre class="line-numbers language-none"><code class="language-none">public class TestEmbeddedChannel &#123;
    public static void main(String[] args) &#123;
        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                System.out.println(&quot;1&quot;);
                super.channelRead(ctx, msg);
            &#125;
        &#125;;

        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                System.out.println(&quot;2&quot;);
                super.channelRead(ctx, msg);
            &#125;
        &#125;;

        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                System.out.println(&quot;3&quot;);
                super.write(ctx, msg, promise);
            &#125;
        &#125;;

        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                System.out.println(&quot;4&quot;);
                super.write(ctx, msg, promise);
            &#125;
        &#125;;

        &#x2F;&#x2F; 用于测试Handler的Channel
        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);
        
        &#x2F;&#x2F; 执行Inbound操作 
        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));
        &#x2F;&#x2F; 执行Outbound操作
        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private static void log(ByteBuf buffer) &#123;
    int length &#x3D; buffer.readableBytes();
    int rows &#x3D; length &#x2F; 16 + (length % 15 &#x3D;&#x3D; 0 ? 0 : 1) + 4;
    StringBuilder buf &#x3D; new StringBuilder(rows * 80 * 2)
        .append(&quot;read index:&quot;).append(buffer.readerIndex())
        .append(&quot; write index:&quot;).append(buffer.writerIndex())
        .append(&quot; capacity:&quot;).append(buffer.capacity())
        .append(NEWLINE);
    appendPrettyHexDump(buf, buffer);
    System.out.println(buf.toString());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建ByteBuf
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);
        ByteBufUtil.log(buffer);

        &#x2F;&#x2F; 向buffer中写入数据
        StringBuilder sb &#x3D; new StringBuilder();
        for(int i &#x3D; 0; i &lt; 20; i++) &#123;
            sb.append(&quot;a&quot;);
        &#125;
        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));

        &#x2F;&#x2F; 查看写入结果
        ByteBufUtil.log(buffer);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">read index:0 write index:0 capacity:16

read index:0 write index:20 capacity:64
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|
|00000010| 61 61 61 61                                     |aaaa            |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p>
<p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p>
<p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p>
<h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p>
<pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p>
<pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p>
<pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<p><strong>验证</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;
    public static void main(String[] args) &#123;
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);
        System.out.println(buffer.getClass());

        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);
        System.out.println(buffer.getClass());

        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);
        System.out.println(buffer.getClass());
    &#125;
&#125;
&#x2F;&#x2F; 使用池化的直接内存
class io.netty.buffer.PooledUnsafeDirectByteBuf
    
&#x2F;&#x2F; 使用池化的堆内存    
class io.netty.buffer.PooledUnsafeHeapByteBuf
    
&#x2F;&#x2F; 使用池化的直接内存    
class io.netty.buffer.PooledUnsafeDirectByteBuf  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可<strong>以通过下面的系统环境变量来设置，也可以作为虚拟机参数传入</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p>
<ul>
<li><p>最大容量与当前容量</p>
<ul>
<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>
<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li>
</ul>
</li>
<li><p>读写操作不同于ByteBuffer只用position进行控制，</p>
<p>ByteBuf分别由读指针和写指针两个指针控制</p>
<p>。进行读写操作时，无需进行模式的切换</p>
<ul>
<li>读指针前的部分被称为废弃部分，是已经读过的内容</li>
<li>读指针与写指针之间的空间称为可读部分</li>
<li>写指针与当前容量之间的空间称为可写部分</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png" alt="img"></a></p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td><strong>用一字节 01|00 代表 true|false</strong></td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 <strong>ByteBuffer</strong></td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td>CharSequence为字符串类（如Stringbuilder）的父类，第二个参数为对应的字符集</td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li>
<li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li>
</ul>
</blockquote>
<p><strong>使用方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建ByteBuf
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);
        ByteBufUtil.log(buffer);

        &#x2F;&#x2F; 向buffer中写入数据
        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
        ByteBufUtil.log(buffer);

        buffer.writeInt(5);
        ByteBufUtil.log(buffer);

        buffer.writeIntLE(6);
        ByteBufUtil.log(buffer);

        buffer.writeLong(7);
        ByteBufUtil.log(buffer);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">read index:0 write index:0 capacity:16

read index:0 write index:4 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04                                     |....            |
+--------+-------------------------------------------------+----------------+

read index:0 write index:8 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 00 00 00 05                         |........        |
+--------+-------------------------------------------------+----------------+

read index:0 write index:12 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |
+--------+-------------------------------------------------+----------------+

read index:0 write index:20 capacity:20
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|
|00000010| 00 00 00 07                                     |....            |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p>
<pre class="line-numbers language-none"><code class="language-none">buffer.writeLong(7);
ByteBufUtil.log(buffer);  
&#x2F;&#x2F; 扩容前
read index:0 write index:12 capacity:16
...

&#x2F;&#x2F; 扩容后
read index:0 write index:20 capacity:20
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|
|00000010| 00 00 00 07                                     |....            |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul>
<li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p>
<ul>
<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li>
</ul>
</li>
<li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p>
<p>n</p>
<ul>
<li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li>
</ul>
</li>
<li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p>
<p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p>
<pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建ByteBuf
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);

        &#x2F;&#x2F; 向buffer中写入数据
        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
        buffer.writeInt(5);

        &#x2F;&#x2F; 读取4个字节
        System.out.println(buffer.readByte());
        System.out.println(buffer.readByte());
        System.out.println(buffer.readByte());
        System.out.println(buffer.readByte());
        ByteBufUtil.log(buffer);

        &#x2F;&#x2F; 通过mark与reset实现重复读取
        buffer.markReaderIndex();
        System.out.println(buffer.readInt());
        ByteBufUtil.log(buffer);

        &#x2F;&#x2F; 恢复到mark标记处
        buffer.resetReaderIndex();
        ByteBufUtil.log(buffer);
    &#125;
&#125;
1
2
3
4
read index:4 write index:8 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 00 00 05                                     |....            |
+--------+-------------------------------------------------+----------------+
5
read index:8 write index:8 capacity:16

read index:4 write index:8 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 00 00 05                                     |....            |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收，放在其他人误调用release 把计数值减为0</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p>
<ul>
<li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p>
</li>
<li><p>入站 ByteBuf 处理原则</p>
<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li>
<li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>
<li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li>
<li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li><p>出站 ByteBuf 处理原则</p>
<ul>
<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li>
</ul>
</li>
<li><p>异常处理原则</p>
<ul>
<li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p>
<pre class="line-numbers language-none"><code class="language-none">while (!buffer.release()) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p>
<p><strong>TailConext中释放ByteBuf的源码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">protected void onUnhandledInboundMessage(Object msg) &#123;
    try &#123;
        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);
    &#125; finally &#123;
        &#x2F;&#x2F; 具体的释放方法
        ReferenceCountUtil.release(msg);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>判断传过来的是否为ByteBuf，是的话才需要释放</p>
<pre class="line-numbers language-none"><code class="language-none">public static boolean release(Object msg) &#123;
	return msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>HeadContext</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HeadContext</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractChannelHandlerContext</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelOutboundHandler</span><span class="token punctuation">,</span> <span class="token class-name">ChannelInboundHandler</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看见出HeadContext实现了ChannelOutboundHandler, ChannelInboundHandler接口，表示可以作为出站和入站。及从Head进Tail出，或者从Head进Head出</p>
<p><img src="D:\Programs\InterviewNotes\image-20211007194810701.png" alt="image-20211007194810701"></p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p>
<p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png" alt="img"></a></p>
<pre class="line-numbers language-none"><code class="language-none">public class TestSlice &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建ByteBuf
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);

        &#x2F;&#x2F; 向buffer中写入数据
        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);

        &#x2F;&#x2F; 将buffer分成两部分
        ByteBuf slice1 &#x3D; buffer.slice(0, 5);
        ByteBuf slice2 &#x3D; buffer.slice(5, 5);

        &#x2F;&#x2F; 需要让分片的buffer引用计数加一
        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用
        slice1.retain();
        slice2.retain();
        
        ByteBufUtil.log(slice1);
        ByteBufUtil.log(slice2);

        &#x2F;&#x2F; 更改原始buffer中的值
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        buffer.setByte(0,5);

        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        ByteBufUtil.log(slice1);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">read index:0 write index:5 capacity:5
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 05                                  |.....           |
+--------+-------------------------------------------------+----------------+
read index:0 write index:5 capacity:5
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 06 07 08 09 0a                                  |.....           |
+--------+-------------------------------------------------+----------------+
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
read index:0 write index:5 capacity:5
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 05 02 03 04 05                                  |.....           |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以<strong>自动扩容</strong></li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如<ul>
<li>slice、duplicate、CompositeByteBuf</li>
</ul>
</li>
</ul>
<h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><pre class="line-numbers language-none"><code class="language-none">public class StudyServer &#123;
    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);
    void start() &#123;
        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();
        try &#123;
            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) &#123;
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 连接建立时会执行该方法，触发active事件
                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());
                            super.channelActive(ctx);
                        &#125;

                        @Override
                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 连接断开时会执行该方法
                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());
                            super.channelInactive(ctx);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);
            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());
            channelFuture.sync();
            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());
            &#x2F;&#x2F; 关闭channel
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;server error&quot;, e);
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
            log.debug(&quot;stopped&quot;);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new StudyServer().start();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class StudyClient &#123;
    static final Logger log &#x3D; LoggerFactory.getLogger(StudyClient.class);
    public static void main(String[] args) &#123;
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    log.debug(&quot;connected...&quot;);
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;sending...&quot;);
                            &#x2F;&#x2F; 每次发送16个字节的数据，共发送10次
                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                                ByteBuf buffer &#x3D; ctx.alloc().buffer();
                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);
                                ctx.writeAndFlush(buffer);
                            &#125;
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>服务器接收结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:53797] READ: 160B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p>
<h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p>
<p><strong>服务器代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调整channel的容量
serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>注意</strong></p>
<blockquote>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p>
</blockquote>
<p><strong>服务器接收结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 36B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000020| 00 01 02 03                                     |....            |
+--------+-------------------------------------------------+----------------+

5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000020| 04 05 06 07 08 09 0a 0b                         |........        |
+--------+-------------------------------------------------+----------------+

5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|
|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|
|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |
+--------+-------------------------------------------------+----------------+

5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000020| 04 05 06 07 08 09 0a 0b                         |........        |
+--------+-------------------------------------------------+----------------+

5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 4B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 0c 0d 0e 0f                                     |....            |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p>
<h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul>
<li>现象<ul>
<li>发送 abc def，接收 abcdef</li>
</ul>
</li>
<li>原因<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul>
<li>现象<ul>
<li>发送 abcdef，接收 abc def</li>
</ul>
</li>
<li>原因<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 小于实际发送数据量</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>
</ul>
</li>
<li>数据链路层<ul>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p>
<p><strong>客户端代码改进</strong></p>
<p>修改channelActive方法</p>
<pre class="line-numbers language-none"><code class="language-none">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
    log.debug(&quot;sending...&quot;);
    ByteBuf buffer &#x3D; ctx.alloc().buffer(16);
    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);
    ctx.writeAndFlush(buffer);
    &#x2F;&#x2F; 使用短链接，每次发送完毕后就断开连接
    ctx.channel().close();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p>
<pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;
    &#x2F;&#x2F; 发送10次
    for (int i &#x3D; 0; i &lt; 10; i++) &#123;
        send();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] ACTIVE

6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+

6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65024] INACTIVE

6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] ACTIVE

6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+

6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65057] INACTIVE

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p>
<h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p>
<p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p>
<pre class="line-numbers language-none"><code class="language-none">ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>客户端代码</strong></p>
<p>客户端发送数据的代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 约定最大长度为16
final int maxLength &#x3D; 16;
&#x2F;&#x2F; 被发送的数据
char c &#x3D; &#39;a&#39;;
&#x2F;&#x2F; 向服务器发送10个报文
for (int i &#x3D; 0; i &lt; 10; i++) &#123;
    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);
    &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充
    byte[] bytes &#x3D; new byte[maxLength];
    &#x2F;&#x2F; 生成长度为0~15的数据
    for (int j &#x3D; 0; j &lt; (int)(Math.random()*(maxLength-1)); j++) &#123;
        bytes[j] &#x3D; (byte) c;
    &#125;
    buffer.writeBytes(bytes);
    c++;
    &#x2F;&#x2F; 将数据发送给服务器
    ctx.writeAndFlush(buffer);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>服务器代码</strong></p>
<p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过定长解码器对粘包数据进行拆分
ch.pipeline().addLast(new FixedLengthFrameDecoder(16));
ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|
+--------+-------------------------------------------------+----------------+

8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|
+--------+-------------------------------------------------+----------------+


8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|
+--------+-------------------------------------------------+----------------+

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p>
<p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p>
<p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p>
<p><strong>以换行符 \n 为分隔符</strong></p>
<p>客户端代码</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 约定最大长度为 64
final int maxLength &#x3D; 64;
&#x2F;&#x2F; 被发送的数据
char c &#x3D; &#39;a&#39;;
for (int i &#x3D; 0; i &lt; 10; i++) &#123;
    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);
    &#x2F;&#x2F; 生成长度为0~62的数据
    Random random &#x3D; new Random();
    StringBuilder sb &#x3D; new StringBuilder();
    for (int j &#x3D; 0; j &lt; (int)(random.nextInt(maxLength-2)); j++) &#123;
        sb.append(c);
    &#125;
    &#x2F;&#x2F; 数据以 \n 结尾
    sb.append(&quot;\n&quot;);
    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));
    c++;
    &#x2F;&#x2F; 将数据发送给服务器
    ctx.writeAndFlush(buffer);
&#125;

或者
    public static StringBuilder makeString(char c, int len) &#123;
        StringBuilder sb &#x3D; new StringBuilder(len + 2);
        for (int i &#x3D; 0; i &lt; len; i++) &#123;
            sb.append(c);
        &#125;
        sb.append(&quot;\n&quot;);
        return sb;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>服务器代码</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \n 为分隔符
&#x2F;&#x2F; 需要指定最大长度
ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));
ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 10B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |
+--------+-------------------------------------------------+----------------+

4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 11B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |
+--------+-------------------------------------------------+----------------+

4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 2B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 63 63                                           |cc              |
+--------+-------------------------------------------------+----------------+

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>以自定义分隔符 \c 为分隔符</strong></p>
<p>客户端代码</p>
<pre class="line-numbers language-none"><code class="language-none">...
    
&#x2F;&#x2F; 数据以 \c 结尾
sb.append(&quot;\\c&quot;);
buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>服务器代码</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将分隔符放入ByteBuf中
ByteBuf bufSet &#x3D; ch.alloc().buffer().writeBytes(&quot;\\c&quot;.getBytes(StandardCharsets.UTF_8));
&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \c 为分隔符
ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));
ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 14B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |
+--------+-------------------------------------------------+----------------+


8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 3B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 62 62                                        |bbb             |
+--------+-------------------------------------------------+----------------+

...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p>
<p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p>
<pre class="line-numbers language-none"><code class="language-none">public LengthFieldBasedFrameDecoder(
    int maxFrameLength,
    int lengthFieldOffset, int lengthFieldLength,
    int lengthAdjustment, int initialBytesToStrip)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数解析</strong></p>
<ul>
<li>maxFrameLength 数据最大长度<ul>
<li>表示数据的最大长度（包括附加信息、长度标识等内容）</li>
</ul>
</li>
<li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul>
<li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li>
</ul>
</li>
<li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul>
<li>数据中用于表示有用数据长度的标识所占的字节数</li>
</ul>
</li>
<li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul>
<li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li>
</ul>
</li>
<li>initialBytesToStrip <strong>数据读取起点</strong><ul>
<li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li>
</ul>
</li>
</ul>
<p><strong>参数图解</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png" alt="img"></a></p>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0
lengthFieldLength   &#x3D; 2
lengthAdjustment    &#x3D; 0
initialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)
  
BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
+--------+----------------+      +--------+----------------+
| Length | Actual Content |-----&gt;| Length | Actual Content |
| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |
+--------+----------------+      +--------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从0开始即为长度标识，长度标识长度为2个字节</p>
<p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0
lengthFieldLength   &#x3D; 2
lengthAdjustment    &#x3D; 0
initialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)
  
BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
+--------+----------------+      +----------------+
| Length | Actual Content |-----&gt;| Actual Content |
| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |
+--------+----------------+      +----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p>
<p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)
lengthFieldLength   &#x3D; 3
lengthAdjustment    &#x3D; 0
initialBytesToStrip &#x3D; 0
  
BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
+----------+----------+----------------+      +----------+----------+----------------+
| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |
|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |
+----------+----------+----------------+      +----------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p>
<p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0
lengthFieldLength   &#x3D; 3
lengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)
initialBytesToStrip &#x3D; 0
  
BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
+----------+----------+----------------+      +----------+----------+----------------+
|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |
| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |
+----------+----------+----------------+      +----------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p>
<p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)
lengthFieldLength   &#x3D; 2
lengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)
initialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)
  
BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
+------+--------+------+----------------+      +------+----------------+
| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |
| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |
+------+--------+------+----------------+      +------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p>
<hr>
<p><strong>使用</strong></p>
<p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p>
<pre class="line-numbers language-none"><code class="language-none">public class EncoderStudy &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 模拟服务器
        &#x2F;&#x2F; 使用EmbeddedChannel测试handler
        EmbeddedChannel channel &#x3D; new EmbeddedChannel(
                &#x2F;&#x2F; 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）
                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 0),
                new LoggingHandler(LogLevel.DEBUG)
        );

        &#x2F;&#x2F; 模拟客户端，写入数据
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();
        send(buffer, &quot;Hello&quot;);
        channel.writeInbound(buffer);
        send(buffer, &quot;World&quot;);
        channel.writeInbound(buffer);
    &#125;

    private static void send(ByteBuf buf, String msg) &#123;
        &#x2F;&#x2F; 得到数据的长度
        int length &#x3D; msg.length();
        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);
        &#x2F;&#x2F; 将数据信息写入buf
        &#x2F;&#x2F; 写入长度标识前的其他信息
        buf.writeByte(0xCA);
        &#x2F;&#x2F; 写入数据长度标识
        buf.writeInt(length);
        &#x2F;&#x2F; 写入长度标识后的其他信息
        buf.writeByte(0xFE);
        &#x2F;&#x2F; 写入具体的数据
        buf.writeBytes(bytes);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |
+--------+-------------------------------------------------+----------------+

146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><p>Netty提供了很多协议的支持。</p>
<h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p>
<p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p>
<h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 该指令一共有3部分，每条指令之后都要添加回车与换行符
*3\r\n
&#x2F;&#x2F; 第一个指令的长度是3
$3\r\n
&#x2F;&#x2F; 第一个指令是set指令
set\r\n
&#x2F;&#x2F; 下面的指令以此类推
$4\r\n
name\r\n
$5\r\n
Nyima\r\n  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>客户端代码如下</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Slf4j
public class RedisClient &#123;
   
    public static void main(String[] args) &#123;
        NioEventLoopGroup group &#x3D;  new NioEventLoopGroup();
        try &#123;
            ChannelFuture channelFuture &#x3D; new Bootstrap()
                    .group(group)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        @Override
                        protected void initChannel(SocketChannel ch) &#123;
                            &#x2F;&#x2F; 打印日志
                            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                                @Override
                                public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                                    &#x2F;&#x2F; 回车与换行符
                                    final byte[] LINE &#x3D; &#123;&#39;\r&#39;,&#39;\n&#39;&#125;;
                                    &#x2F;&#x2F; 获得ByteBuf
                                    ByteBuf buffer &#x3D; ctx.alloc().buffer();
                                    &#x2F;&#x2F; 连接建立后，向Redis中发送一条指令，注意添加回车与换行
                                    &#x2F;&#x2F; set name Nyima
                                    buffer.writeBytes(&quot;*3&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes(&quot;$3&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes(&quot;set&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes(&quot;$4&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes(&quot;name&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes(&quot;$5&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes(&quot;Nyima&quot;.getBytes());
                                    buffer.writeBytes(LINE);
                                    ctx.writeAndFlush(buffer);
                                &#125;

                            &#125;);
                        &#125;
                    &#125;)
                    .connect(new InetSocketAddress(&quot;localhost&quot;, 6379));
            channelFuture.sync();
            &#x2F;&#x2F; 关闭channel
            channelFuture.channel().close().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            &#x2F;&#x2F; 关闭group
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>控制台打印结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0] REGISTERED
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0] CONNECT: &#x2F;127.0.0.1:6379
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] ACTIVE
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] WRITE: 32B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|
|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 77 7a 79 0d 0a |.name..$5..wzy..|
+--------+-------------------------------------------------+----------------+
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] FLUSH
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] CLOSE
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 ! R:&#x2F;127.0.0.1:6379] INACTIVE
[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 ! R:&#x2F;127.0.0.1:6379] UNREGISTERED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Redis中查询执行结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder
&#x2F;&#x2F; Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器
public final class HttpServerCodec extends CombinedChannelDuplexHandler&lt;HttpRequestDecoder, HttpResponseEncoder&gt;
        implements HttpServerUpgradeHandler.SourceCodec  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>服务器代码</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">NioEventLoopGroup</span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span>
                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServerCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 服务器只处理HTTPRequest</span>
                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleChannelInboundHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpRequest</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token annotation punctuation">@Override</span>
                            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">HttpRequest</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token comment">// 获得请求uri</span>
                                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                                <span class="token comment">// 获得完整响应，设置版本号与状态码</span>
                                <span class="token class-name">DefaultFullHttpResponse</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFullHttpResponse</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">protocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpResponseStatus</span><span class="token punctuation">.</span>OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token comment">// 设置响应内容</span>
                                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token string">"&lt;h1>Hello, World!&lt;/h1>"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token comment">// 设置响应体长度，避免浏览器一直接收响应内容</span>
                                response<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span>CONTENT_LENGTH<span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token comment">// 设置响应体</span>
                                response<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeBytes</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

                                <span class="token comment">// 写回响应</span>
                                ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 服务器只处理HTTPRequest
ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得完整响应，设置版本号与状态码
DefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);
&#x2F;&#x2F; 设置响应内容
byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);
&#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容
response.headers().setInt(CONTENT_LENGTH, bytes.length);
&#x2F;&#x2F; 设置响应体
response.content().writeBytes(bytes);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>浏览器</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png" alt="img"></a></p>
<p>控制台</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 请求内容
1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] READ: 688B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET &#x2F;favicon.ico|
|00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP&#x2F;1.1..Host:|
|00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.|
|00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee|
|00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|
....

&#x2F;&#x2F; 响应内容
1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] WRITE: 61B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP&#x2F;1.1 200 OK.|
|00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:|
|00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello|
|00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;&#x2F;h1&gt;   |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul>
<li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p>
</li>
<li><p><strong>版本号</strong>：可以支持协议的升级</p>
</li>
<li><p>序列化算法</p>
<p>：消息正文到底采用哪种序列化反序列化方式</p>
<ul>
<li>如：json、protobuf、hessian、jdk</li>
</ul>
</li>
<li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p>
</li>
<li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p>
</li>
<li><p><strong>正文长度</strong></p>
</li>
<li><p><strong>消息正文</strong></p>
</li>
</ul>
<h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;

    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;
        &#x2F;&#x2F; 设置魔数 4个字节
        out.writeBytes(new byte[]&#123;&#39;N&#39;,&#39;Y&#39;,&#39;I&#39;,&#39;M&#39;&#125;);
        &#x2F;&#x2F; 设置版本号 1个字节
        out.writeByte(1);
        &#x2F;&#x2F; 设置序列化方式 1个字节
        out.writeByte(1);
        &#x2F;&#x2F; 设置指令类型 1个字节
        out.writeByte(msg.getMessageType());
        &#x2F;&#x2F; 设置请求序号 4个字节
        out.writeInt(msg.getSequenceId());
        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据
        out.writeByte(0xff);

        &#x2F;&#x2F; 获得序列化后的msg
        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();
        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);
        oos.writeObject(msg);
        byte[] bytes &#x3D; bos.toByteArray();

        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识
        out.writeInt(bytes.length);
        &#x2F;&#x2F; 设置消息正文
        out.writeBytes(bytes);
    &#125;

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        &#x2F;&#x2F; 获取魔数
        int magic &#x3D; in.readInt();
        &#x2F;&#x2F; 获取版本号
        byte version &#x3D; in.readByte();
        &#x2F;&#x2F; 获得序列化方式
        byte seqType &#x3D; in.readByte();
        &#x2F;&#x2F; 获得指令类型
        byte messageType &#x3D; in.readByte();
        &#x2F;&#x2F; 获得请求序号
        int sequenceId &#x3D; in.readInt();
        &#x2F;&#x2F; 移除补齐字节
        in.readByte();
        &#x2F;&#x2F; 获得正文长度
        int length &#x3D; in.readInt();
        &#x2F;&#x2F; 获得正文
        byte[] bytes &#x3D; new byte[length];
        in.readBytes(bytes, 0, length);
        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));
        Message message &#x3D; (Message) ois.readObject();
		&#x2F;&#x2F; 将信息放入List中，传递给下一个handler
        out.add(message);
        
        &#x2F;&#x2F; 打印获得的信息正文
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(magic);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(version);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(seqType);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(messageType);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(sequenceId);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(length);
        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
        System.out.println(message);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p>
<pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p>
</li>
<li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p>
</li>
</ul>
<p><strong>编写测试类</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class TestCodec &#123;
    static final org.slf4j.Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);
    public static void main(String[] args) throws Exception &#123;
        EmbeddedChannel channel &#x3D; new EmbeddedChannel();
        &#x2F;&#x2F; 添加解码器，避免粘包半包问题
        channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0));
        channel.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
        channel.pipeline().addLast(new MessageCodec());
        LoginRequestMessage user &#x3D; new LoginRequestMessage(&quot;Nyima&quot;, &quot;123&quot;);

        &#x2F;&#x2F; 测试编码与解码
        ByteBuf byteBuf &#x3D; ByteBufAllocator.DEFAULT.buffer();
        new MessageCodec().encode(null, user, byteBuf);
        channel.writeInbound(byteBuf);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li>
<li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li>
</ul>
<p>运行结果</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png" alt="img"></a></p>
<h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p>
<pre class="line-numbers language-none"><code class="language-none">LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);
&#x2F;&#x2F; 不同的channel中使用同一个handler对象，提高复用率
channel1.pipeline().addLast(loggingHandler);
channel2.pipeline().addLast(loggingHandler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p>
<ul>
<li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li>
<li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li>
</ul>
<p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p>
<p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p>
<h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p>
<p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p>
<p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p>
<p><img src="D:\Programs\InterviewNotes\image-20211009114836214.png" alt="image-20211009114836214"></p>
<ul>
<li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png" alt="img"></a></p>
<p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p>
<ul>
<li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li>
</ul>
</li>
</ul>
<p><strong>如果想要共享，需要怎么办呢？</strong></p>
<p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p>
<pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class MessageSharableCodec extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;
    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out) throws Exception &#123;
        ...
    &#125;

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123;
		...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface UserService &#123;

    &#x2F;**
     * 登录
     * @param username 用户名
     * @param password 密码
     * @return 登录成功返回 true, 否则返回 false
     *&#x2F;
    boolean login(String username, String password);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface Session &#123;

    &#x2F;**
     * 绑定会话
     * @param channel 哪个 channel 要绑定会话
     * @param username 会话绑定用户
     *&#x2F;
    void bind(Channel channel, String username);

    &#x2F;**
     * 解绑会话
     * @param channel 哪个 channel 要解绑会话
     *&#x2F;
    void unbind(Channel channel);

    &#x2F;**
     * 获取属性
     * @param channel 哪个 channel
     * @param name 属性名
     * @return 属性值
     *&#x2F;
    Object getAttribute(Channel channel, String name);

    &#x2F;**
     * 设置属性
     * @param channel 哪个 channel
     * @param name 属性名
     * @param value 属性值
     *&#x2F;
    void setAttribute(Channel channel, String name, Object value);

    &#x2F;**
     * 根据用户名获取 channel
     * @param username 用户名
     * @return channel
     *&#x2F;
    Channel getChannel(String username);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface GroupSession &#123;

    &#x2F;**
     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null
     * @param name 组名
     * @param members 成员
     * @return 成功时返回组对象, 失败返回 null
     *&#x2F;
    Group createGroup(String name, Set&lt;String&gt; members);

    &#x2F;**
     * 加入聊天组
     * @param name 组名
     * @param member 成员名
     * @return 如果组不存在返回 null, 否则返回组对象
     *&#x2F;
    Group joinMember(String name, String member);

    &#x2F;**
     * 移除组成员
     * @param name 组名
     * @param member 成员名
     * @return 如果组不存在返回 null, 否则返回组对象
     *&#x2F;
    Group removeMember(String name, String member);

    &#x2F;**
     * 移除聊天组
     * @param name 组名
     * @return 如果组不存在返回 null, 否则返回组对象
     *&#x2F;
    Group removeGroup(String name);

    &#x2F;**
     * 获取组成员
     * @param name 组名
     * @return 成员集合, 如果群不存在或没有成员会返回 empty set
     *&#x2F;
    Set&lt;String&gt; getMembers(String name);

    &#x2F;**
     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回
     * @param name 组名
     * @return 成员 channel 集合
     *&#x2F;
    List&lt;Channel&gt; getMembersChannel(String name);
    
    &#x2F;**
     * 判断群聊是否一被创建
     * @param name 群聊名称
     * @return 是否存在
     *&#x2F;
    boolean isCreated(String name);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png" alt="img"></a></p>
<ul>
<li>client包：存放客户端相关类</li>
<li>message包：存放各种类型的消息</li>
<li>protocol包：存放自定义协议</li>
<li>server包：存放服务器相关类<ul>
<li>service包：存放用户相关类</li>
<li>session包：单聊及群聊相关会话类</li>
</ul>
</li>
</ul>
<h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><pre class="line-numbers language-none"><code class="language-none">public class ChatClient &#123;
    static final Logger log &#x3D; LoggerFactory.getLogger(ChatClient.class);
    public static void main(String[] args) &#123;
        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();
        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);
        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();
        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.group(group);
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProtocolFrameDecoder());
                    ch.pipeline().addLast(loggingHandler);
                    ch.pipeline().addLast(messageSharableCodec);
                &#125;
            &#125;);
            Channel channel &#x3D; bootstrap.connect().sync().channel();
            channel.closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
           group.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><pre class="line-numbers language-none"><code class="language-none">public class ChatServer &#123;
    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);
    public static void main(String[] args) &#123;
        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();
        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);
        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();
        try &#123;
            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();
            bootstrap.group(boss, worker);
            bootstrap.channel(NioServerSocketChannel.class);
            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProtocolFrameDecoder());
                    ch.pipeline().addLast(loggingHandler);
                    ch.pipeline().addLast(messageSharableCodec);
                &#125;
            &#125;);
            Channel channel &#x3D; bootstrap.bind(8080).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p>
<pre class="line-numbers language-none"><code class="language-none">ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
    &#x2F;**
     * 创建连接时执行的处理器，用于执行登陆操作
     *&#x2F;
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        &#x2F;&#x2F; 开辟额外线程，用于用户登陆及后续操作
        new Thread(()-&gt;&#123;
            Scanner scanner &#x3D; new Scanner(System.in);
            System.out.println(&quot;请输入用户名&quot;);
            String username &#x3D; scanner.next();
            System.out.println(&quot;请输入密码&quot;);
            String password &#x3D; scanner.next();
            &#x2F;&#x2F; 创建包含登录信息的请求体
            LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);
            &#x2F;&#x2F; 发送到channel中
            ctx.writeAndFlush(message);
            System.out.println(&quot;等待后续操作...&quot;);
            &#x2F;&#x2F; 阻塞，直到登陆成功后CountDownLatch被设置为0
            try &#123;
                waitLogin.await();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            &#x2F;&#x2F; 执行后续操作
            if (!loginStatus.get()) &#123;
                &#x2F;&#x2F; 登陆失败，关闭channel并返回
                ctx.channel().close();
                return;
            &#125;
            &#x2F;&#x2F; 登录成功后，执行其他操作
            while (true) &#123;
                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
                System.out.println(&quot;send [username] [content]&quot;);
                System.out.println(&quot;gsend [group name] [content]&quot;);
                System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);
                System.out.println(&quot;gmembers [group name]&quot;);
                System.out.println(&quot;gjoin [group name]&quot;);
                System.out.println(&quot;gquit [group name]&quot;);
                System.out.println(&quot;quit&quot;);
                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
                String command &#x3D; scanner.nextLine();
                &#x2F;&#x2F; 获得指令及其参数，并发送对应类型消息
                String[] commands &#x3D; command.split(&quot; &quot;);
                switch (commands[0])&#123;
                    case &quot;send&quot;:
                        ctx.writeAndFlush(new ChatRequestMessage(username, commands[1], commands[2]));
                        break;
                    case &quot;gsend&quot;:
                        ctx.writeAndFlush(new GroupChatRequestMessage(username,commands[1], commands[2]));
                        break;
                    case &quot;gcreate&quot;:
                        &#x2F;&#x2F; 分割，获得群员名
                        String[] members &#x3D; commands[2].split(&quot;,&quot;);
                        Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(members));
                        &#x2F;&#x2F; 把自己加入到群聊中
                        set.add(username);
                        ctx.writeAndFlush(new GroupCreateRequestMessage(commands[1],set));
                        break;
                    case &quot;gmembers&quot;:
                        ctx.writeAndFlush(new GroupMembersRequestMessage(commands[1]));
                        break;
                    case &quot;gjoin&quot;:
                        ctx.writeAndFlush(new GroupJoinRequestMessage(username, commands[1]));
                        break;
                    case &quot;gquit&quot;:
                        ctx.writeAndFlush(new GroupQuitRequestMessage(username, commands[1]));
                        break;
                    case &quot;quit&quot;:
                        ctx.channel().close();
                        return;
                    default:
                        System.out.println(&quot;指令有误，请重新输入&quot;);
                        continue;
                &#125;
            &#125;
        &#125;, &quot;login channel&quot;).start();
    &#125;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        log.debug(&quot;&#123;&#125;&quot;, msg);
        if (msg instanceof LoginResponseMessage) &#123;
            &#x2F;&#x2F; 如果是登录响应信息
            LoginResponseMessage message &#x3D; (LoginResponseMessage) msg;
            boolean isSuccess &#x3D; message.isSuccess();
            &#x2F;&#x2F; 登录成功，设置登陆标记
            if (isSuccess) &#123;
                loginStatus.set(true);
            &#125;
            &#x2F;&#x2F; 登陆后，唤醒登陆线程
            waitLogin.countDown();
        &#125;
    &#125;
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable &#x2F;&#x2F; 必须添加该注解
public class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;
        &#x2F;&#x2F; 获得登录信息
        String username &#x3D; msg.getUsername();
        String password &#x3D; msg.getPassword();
        &#x2F;&#x2F; 校验登录信息
        boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);
        LoginResponseMessage message;
        if (login) &#123;
            message &#x3D; new LoginResponseMessage(true, &quot;登陆成功&quot;);
            &#x2F;&#x2F; 绑定channel与user
            SessionFactory.getSession().bind(ctx.channel(), username);
        &#125; else &#123;
            message &#x3D; new LoginResponseMessage(false, &quot;登陆失败&quot;);
        &#125;
        ctx.writeAndFlush(message);
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理登录请求
LoginRequestMessageHandler loginRequestMessageHandler &#x3D; new LoginRequestMessageHandler();
ch.pipeline().addLast(new LoginRequestMessageHandler());  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p>
<pre class="line-numbers language-none"><code class="language-none">5665 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 1, 0, 279
5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;登陆成功&#39;&#125;
5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;登陆成功&#39;&#125;
success  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>服务器</strong></p>
<pre class="line-numbers language-none"><code class="language-none">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 217
11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username&#x3D;&#39;Nyima&#39;, password&#x3D;&#39;123&#39;&#125;

7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:60572] WRITE: 295B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 4e 59 49 4d 01 01 01 00 00 00 00 ff 00 00 01 17 |NYIM............|
|00000010| ac ed 00 05 73 72 00 31 63 6e 2e 6e 79 69 6d 61 |....sr.1cn.nyima|
|00000020| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes|
|00000030| 73 61 67 65 2e 4c 6f 67 69 6e 52 65 73 70 6f 6e |sage.LoginRespon|
|00000040| 73 65 4d 65 73 73 61 67 65 e2 34 49 24 72 52 f3 |seMessage.4I$rR.|
|00000050| 07 02 00 00 78 72 00 34 63 6e 2e 6e 79 69 6d 61 |....xr.4cn.nyima|
|00000060| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes|
|00000070| 73 61 67 65 2e 41 62 73 74 72 61 63 74 52 65 73 |sage.AbstractRes|
|00000080| 70 6f 6e 73 65 4d 65 73 73 61 67 65 b3 7e 19 32 |ponseMessage.~.2|
|00000090| 9b 88 4d 7b 02 00 02 5a 00 07 73 75 63 63 65 73 |..M&#123;...Z..succes|
|000000a0| 73 4c 00 06 72 65 61 73 6f 6e 74 00 12 4c 6a 61 |sL..reasont..Lja|
|000000b0| 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 78 |va&#x2F;lang&#x2F;String;x|
|000000c0| 72 00 24 63 6e 2e 6e 79 69 6d 61 63 2e 73 74 75 |r.$cn.nyimac.stu|
|000000d0| 64 79 2e 64 61 79 38 2e 6d 65 73 73 61 67 65 2e |dy.day8.message.|
|000000e0| 4d 65 73 73 61 67 65 dd e9 84 b7 21 db 18 52 02 |Message....!..R.|
|000000f0| 00 02 49 00 0b 6d 65 73 73 61 67 65 54 79 70 65 |..I..messageType|
|00000100| 49 00 0a 73 65 71 75 65 6e 63 65 49 64 78 70 00 |I..sequenceIdxp.|
|00000110| 00 00 00 00 00 00 00 01 74 00 0c e7 99 bb e9 99 |........t.......|
|00000120| 86 e6 88 90 e5 8a 9f                            |.......         |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable &#x2F;&#x2F; 必须添加该注解
public class ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception &#123;
        &#x2F;&#x2F; 获得user所在的channel
        Channel channel &#x3D; SessionFactory.getSession().getChannel(msg.getTo());
        &#x2F;&#x2F; 如果双方都在线
        if (channel !&#x3D; null) &#123;
            &#x2F;&#x2F; 通过接收方与服务器之间的channel发送信息
            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));
        &#125; else &#123;
            &#x2F;&#x2F; 通过发送方与服务器之间的channel发送消息
            ctx.writeAndFlush(new ChatResponseMessage(false, &quot;对方用户不存在或离线，发送失败&quot;));
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理单聊请求
ChatRequestMessageHandler chatRequestMessageHandler &#x3D; new ChatRequestMessageHandler();
ch.pipeline().addLast(chatRequestMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>发送方（zhangsan）</p>
<pre class="line-numbers language-none"><code class="language-none">send Nyima hello  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接收方（Nyima）</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 收到zhangsan发来的消息
20230 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;hello&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p>
<pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class GroupCreateMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception &#123;
        &#x2F;&#x2F; 获得要创建的群聊名
        String groupName &#x3D; msg.getGroupName();
        &#x2F;&#x2F; 获得要创建的群聊的成员组
        Set&lt;String&gt; members &#x3D; msg.getMembers();
        &#x2F;&#x2F; 判断该群聊是否创建过，未创建返回null并创建群聊
        Group group &#x3D; GroupSessionFactory.getGroupSession().createGroup(groupName, members);
        if (group &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F; 发送创建成功消息
            GroupCreateResponseMessage groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(true, groupName + &quot;创建成功&quot;);
            ctx.writeAndFlush(groupCreateResponseMessage);
            &#x2F;&#x2F; 获得在线群员的channel，给群员发送入群聊消息
            List&lt;Channel&gt; membersChannel &#x3D; GroupSessionFactory.getGroupSession().getMembersChannel(groupName);
            groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(true, &quot;您已被拉入&quot;+groupName);
            &#x2F;&#x2F; 给每个在线群员发送消息
            for(Channel channel : membersChannel) &#123;
                channel.writeAndFlush(groupCreateResponseMessage);
            &#125;
        &#125; else &#123;
            &#x2F;&#x2F; 发送失败消息
            GroupCreateResponseMessage groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(false, groupName + &quot;已存在&quot;);
            ctx.writeAndFlush(groupCreateResponseMessage);
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理创建群聊请求
GroupCreateMessageHandler groupCreateMessageHandler &#x3D; new GroupCreateMessageHandler();
ch.pipeline().addLast(groupCreateMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>创建者客户端</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 首次创建
gcreate Netty学习 zhangsan,lisi

31649 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;Netty学习创建成功&#39;&#125;
15244 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;您已被拉入Netty学习&#39;&#125;


&#x2F;&#x2F; 再次创建
gcreate Netty学习 zhangsan,lisi
40771 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;Netty学习已存在&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>群员客户端</p>
<pre class="line-numbers language-none"><code class="language-none">28788 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;您已被拉入Netty学习&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class GroupChatMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception &#123;
        String groupName &#x3D; msg.getGroupName();
        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();
        &#x2F;&#x2F; 判断群聊是否存在
        boolean isCreated &#x3D; groupSession.isCreated(groupName);
        if (isCreated) &#123;
            &#x2F;&#x2F; 给群员发送信息
            List&lt;Channel&gt; membersChannel &#x3D; groupSession.getMembersChannel(groupName);
            for(Channel channel : membersChannel) &#123;
                channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));
            &#125;
        &#125; else &#123;
            ctx.writeAndFlush(new GroupChatResponseMessage(false, &quot;群聊不存在&quot;));
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理群聊聊天
GroupChatMessageHandler groupChatMessageHandler &#x3D; new GroupChatMessageHandler();
ch.pipeline().addLast(groupChatMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>发送方（群聊存在）</p>
<pre class="line-numbers language-none"><code class="language-none">gsend Netty学习 你们好

45408 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;你们好&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>接收方</p>
<pre class="line-numbers language-none"><code class="language-none">48082 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;你们好&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>发送方（群聊不存在）</p>
<pre class="line-numbers language-none"><code class="language-none">gsend Spring学习 你们好

25140 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;群聊不存在&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class GroupJoinMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception &#123;
        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();
        &#x2F;&#x2F; 判断该用户是否在群聊中
        Set&lt;String&gt; members &#x3D; groupSession.getMembers(msg.getGroupName());
        boolean joinFlag &#x3D; false;
        &#x2F;&#x2F; 群聊存在且用户未加入，才能加入
        if (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;
            joinFlag &#x3D; true;
        &#125;

        if (joinFlag) &#123;
            &#x2F;&#x2F; 加入群聊
            groupSession.joinMember(msg.getGroupName(), msg.getUsername());
            ctx.writeAndFlush(new GroupJoinResponseMessage(true,&quot;加入&quot;+msg.getGroupName()+&quot;成功&quot;));
        &#125; else &#123;
            ctx.writeAndFlush(new GroupJoinResponseMessage(false, &quot;加入失败，群聊未存在或您已加入该群聊&quot;));
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理加入群聊
GroupJoinMessageHandler groupJoinMessageHandler &#x3D; new GroupJoinMessageHandler();
ch.pipeline().addLast(groupJoinMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>正常加入群聊</p>
<pre class="line-numbers language-none"><code class="language-none">94921 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;加入Netty学习成功&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>加入不能存在或已加入的群聊</p>
<pre class="line-numbers language-none"><code class="language-none">44025 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;加入失败，群聊未存在或您已加入该群聊&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class GroupQuitMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception &#123;
        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();
        String groupName &#x3D; msg.getGroupName();
        Set&lt;String&gt; members &#x3D; groupSession.getMembers(groupName);
        String username &#x3D; msg.getUsername();
        &#x2F;&#x2F; 判断用户是否在群聊中以及群聊是否存在
        boolean joinFlag &#x3D; false;
        if (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;
            &#x2F;&#x2F; 可以退出
            joinFlag &#x3D; true;
        &#125;

        if (joinFlag) &#123;
            &#x2F;&#x2F; 退出成功
            groupSession.removeMember(groupName, username);
            ctx.writeAndFlush(new GroupQuitResponseMessage(true, &quot;退出&quot;+groupName+&quot;成功&quot;));
        &#125; else &#123;
            &#x2F;&#x2F; 退出失败
            ctx.writeAndFlush(new GroupQuitResponseMessage(false, &quot;群聊不存在或您未加入该群，退出&quot;+groupName+&quot;失败&quot;));
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理退出群聊
GroupQuitMessageHandler groupQuitMessageHandler &#x3D; new GroupQuitMessageHandler();
ch.pipeline().addLast(groupQuitMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>正常退出</p>
<pre class="line-numbers language-none"><code class="language-none">32282 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;退出Netty学习成功&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>退出不存在或未加入的群聊</p>
<pre class="line-numbers language-none"><code class="language-none">67404 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;群聊不存在或您未加入该群，退出Netty失败&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class GroupMembersMessageHandler extends SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception &#123;
        ctx.writeAndFlush(new GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));
    &#125;
&#125;
&#x2F;&#x2F; 该handler处理查看成员
GroupMembersMessageHandler groupMembersMessageHandler &#x3D; new GroupMembersMessageHandler();
ch.pipeline().addLast(groupMembersMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">46557 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members&#x3D;[zhangsan, Nyima]&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class QuitHandler extends ChannelInboundHandlerAdapter &#123;
    &#x2F;**
     * 断开连接时触发 Inactive事件
     *&#x2F;
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
        &#x2F;&#x2F; 解绑
        SessionFactory.getSession().unbind(ctx.channel());
    &#125;

    &#x2F;**
     * 异常退出，需要解绑
     *&#x2F;
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        &#x2F;&#x2F; 解绑
        SessionFactory.getSession().unbind(ctx.channel());
    &#125;
&#125; 
&#x2F;&#x2F; 该handler处理退出聊天室
ch.pipeline().addLast(quitHandler);
GroupMembersMessageHandler groupMembersMessageHandler &#x3D; new GroupMembersMessageHandler();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>退出时，客户端会关闭channel并返回</strong></p>
<pre class="line-numbers language-none"><code class="language-none">case &quot;quit&quot;:
	&#x2F;&#x2F; 关闭channel并返回
    ctx.channel().close();
    return;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p>
<ul>
<li>readerIdleTimeSeconds 读空闲经过的秒数</li>
<li>writerIdleTimeSeconds 写空闲经过的秒数</li>
<li>allIdleTimeSeconds 读和写空闲经过的秒数</li>
</ul>
<p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" alt="img"></a></p>
<ul>
<li>读空闲会触发<code>READER_IDLE</code></li>
<li>写空闲会触发<code>WRITE_IDLE</code></li>
<li>读和写空闲会触发<code>ALL_IDEL</code></li>
</ul>
<p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p>
<p><strong>服务器端代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件
ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));
&#x2F;&#x2F; 添加双向处理器，负责处理READER_IDLE事件
ch.pipeline().addLast(new ChannelDuplexHandler() &#123;
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;
        &#x2F;&#x2F; 获得事件
        IdleStateEvent event &#x3D; (IdleStateEvent) evt;
        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE) &#123;
            &#x2F;&#x2F; 断开连接
            ctx.channel().close();
        &#125;
    &#125;
&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>使用<code>IdleStateHandler</code>进行空闲检测</p>
</li>
<li><p>使用双向处理器</p>
<pre class="line-numbers language-none"><code class="language-none">ChannelDuplexHandler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对入站与出站事件进行处理</p>
<ul>
<li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li>
</ul>
</li>
</ul>
<p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p>
<p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p>
<p><strong>客户端代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 发送心跳包，让服务器知道客户端在线
&#x2F;&#x2F; 3s未发生WRITER_IDLE，就像服务器发送心跳包
&#x2F;&#x2F; 该值为服务器端设置的READER_IDLE触发时间的一半左右
ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));
ch.pipeline().addLast(new ChannelDuplexHandler() &#123;
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;
        IdleStateEvent event &#x3D; (IdleStateEvent) evt;
        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;
            &#x2F;&#x2F; 发送心跳包
            ctx.writeAndFlush(new PingMessage());
        &#125;
    &#125;
&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><pre class="line-numbers language-none"><code class="language-none">public interface Serializer &#123;
    &#x2F;**
     * 序列化
     * @param object 被序列化的对象
     * @param &lt;T&gt; 被序列化对象类型
     * @return 序列化后的字节数组
     *&#x2F;
    &lt;T&gt; byte[] serialize(T object);

    &#x2F;**
     * 反序列化
     * @param clazz 反序列化的目标类的Class对象
     * @param bytes 被反序列化的字节数组
     * @param &lt;T&gt; 反序列化目标类
     * @return 反序列化后的对象
     *&#x2F;
    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><pre class="line-numbers language-none"><code class="language-none">public enum SerializerAlgorithm implements Serializer &#123;
    &#x2F;&#x2F; Java的序列化和反序列化
    Java &#123;
        @Override
        public &lt;T&gt; byte[] serialize(T object) &#123;
            &#x2F;&#x2F; 序列化后的字节数组
            byte[] bytes &#x3D; null;
            try (ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();
                 ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos)) &#123;
                oos.writeObject(object);
                bytes &#x3D; bos.toByteArray();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            return bytes;
        &#125;

        @Override
        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;
            T target &#x3D; null;
            System.out.println(Arrays.toString(bytes));
            try (ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);
                 ObjectInputStream ois &#x3D; new ObjectInputStream(bis)) &#123;
                target &#x3D; (T) ois.readObject();
            &#125; catch (IOException | ClassNotFoundException e) &#123;
                e.printStackTrace();
            &#125;
            &#x2F;&#x2F; 返回反序列化后的对象
            return target;
        &#125;
    &#125;
    
     &#x2F;&#x2F; Json的序列化和反序列化
    Json &#123;
        @Override
        public &lt;T&gt; byte[] serialize(T object) &#123;
            String s &#x3D; new Gson().toJson(object);
            System.out.println(s);
            &#x2F;&#x2F; 指定字符集，获得字节数组
            return s.getBytes(StandardCharsets.UTF_8);
        &#125;

        @Override
        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;
            String s &#x3D; new String(bytes, StandardCharsets.UTF_8);
            System.out.println(s);
            &#x2F;&#x2F; 此处的clazz为具体类型的Class对象，而不是父类Message的
            return new Gson().fromJson(s, clazz);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得序列化后的msg
&#x2F;&#x2F; 使用指定的序列化方式
SerializerAlgorithm[] values &#x3D; SerializerAlgorithm.values();
&#x2F;&#x2F; 获得序列化后的对象
byte[] bytes &#x3D; values[out.getByte(5)-1].serialize(msg);Cop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>解码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得反序列化方式
SerializerAlgorithm[] values &#x3D; SerializerAlgorithm.values();
&#x2F;&#x2F; 通过指定方式进行反序列化
&#x2F;&#x2F; 需要通过Message的方法获得具体的消息类型
Message message &#x3D; values[seqType-1].deserialize(Message.getMessageClass(messageType), bytes);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul>
<li>属于 <strong>SocketChannal</strong> 的参数</li>
<li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li>
<li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><pre class="line-numbers language-none"><code class="language-none">public class TestParam &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常
        new Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);
        
        &#x2F;&#x2F; ServerSocketChannel 5s内未建立连接就抛出异常
        new ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);
        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常
        new ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p>
</li>
<li><p>服务器通过</p>
<pre class="line-numbers language-none"><code class="language-none">ServerBootstrap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>来配置参数，但是对于不同的 Channel 需要选择不同的方法</p>
<ul>
<li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li>
<li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li>
</ul>
</li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p>
<p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p>
<pre class="line-numbers language-none"><code class="language-none">public final void connect(
                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;
    
    ...
        
    &#x2F;&#x2F; Schedule connect timeout.
    &#x2F;&#x2F; 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置
    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();
    &#x2F;&#x2F; 如果超时时间大于0
    if (connectTimeoutMillis &gt; 0) &#123;
        &#x2F;&#x2F; 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行
        &#x2F;&#x2F; schedule(Runnable command, long delay, TimeUnit unit)
        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;
            @Override
            public void run() &#123;
                &#x2F;&#x2F; 判断是否建立连接，Promise进行NIO线程与主线程之间的通信
                &#x2F;&#x2F; 如果超时，则通过tryFailure方法将异常放入Promise中
                &#x2F;&#x2F; 在主线程中抛出
                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;
                ConnectTimeoutException cause &#x3D; new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);
                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;
                    close(voidPromise());
                &#125;
            &#125;
        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);
    &#125;
    
   	...
        
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p>
<ul>
<li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li>
<li>如果指定时间内没有建立连接，则会执行其中的任务<ul>
<li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li>
</ul>
</li>
</ul>
<h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p>
<h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png" alt="img"></a></p>
<p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png" alt="img"></a></p>
<p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png" alt="img"></a></p>
<p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p>
<ul>
<li>半连接队列 - sync queue<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li>全连接队列 - accept queue<ul>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
</ul>
</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p>
<p><strong>设置方式如下</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 设置全连接队列，大小为2
new ServerBootstrap().option(ChannelOption.SO_BACKLOG, 2);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void doBind(SocketAddress localAddress) throws Exception &#123;
    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;
        javaChannel().bind(localAddress, config.getBacklog());
    &#125; else &#123;
        javaChannel().socket().bind(localAddress, config.getBacklog());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p>
<pre class="line-numbers language-none"><code class="language-none">private volatile int backlog &#x3D; NetUtil.SOMAXCONN;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>具体的赋值操作如下</p>
<pre class="line-numbers language-none"><code class="language-none">SOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;
    @Override
    public Integer run() &#123;
        &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.
        &#x2F;&#x2F; The known defaults:
        &#x2F;&#x2F; - Windows NT Server 4.0+: 200
        &#x2F;&#x2F; - Linux and Mac OS X: 128
        int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;
        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);
        BufferedReader in &#x3D; null;
        try &#123;
            &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the
            &#x2F;&#x2F; try &#x2F; catch block.
            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936
            if (file.exists()) &#123;
                in &#x3D; new BufferedReader(new FileReader(file));
                &#x2F;&#x2F; 将somaxconn设置为Linux配置文件中设置的值
                somaxconn &#x3D; Integer.parseInt(in.readLine());
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;&#123;&#125;: &#123;&#125;&quot;, file, somaxconn);
                &#125;
            &#125; else &#123;
                ...
            &#125;
            ...
        &#125;  
        &#x2F;&#x2F; 返回backlog的值
        return somaxconn;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>backlog的值会根据操作系统的不同，来</p>
<p>选择不同的默认值</p>
<ul>
<li>Windows 200</li>
<li>Linux/Mac OS 128</li>
</ul>
</li>
<li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p>
</li>
</ul>
<h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul>
<li>属于 <strong>SocketChannal</strong> 参数</li>
<li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li>
<li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li>
</ul>
<h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul>
<li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li>
<li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li>
<li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li>
</ul>
<h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul>
<li>属于 <strong>SocketChannal</strong> 参数</li>
<li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型
&#x2F;&#x2F; 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型
new ServerBootstrap().childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator());  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>ByteBufAllocator类型</strong></p>
<ul>
<li><p>池化并使用直接内存</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; true表示使用直接内存
new PooledByteBufAllocator(true);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>池化并使用堆内存</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; false表示使用堆内存
new PooledByteBufAllocator(false);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>非池化并使用直接内存</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; ture表示使用直接内存
new UnpooledByteBufAllocator(true);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>非池化并使用堆内存</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; false表示使用堆内存
new UnpooledByteBufAllocator(false);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul>
<li>属于 <strong>SocketChannal</strong> 参数</li>
<li><strong>控制 Netty 接收缓冲区大小</strong></li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li>
</ul>
<h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p>
<p><strong>Message</strong>中添加如下代码</p>
<pre class="line-numbers language-none"><code class="language-none">public abstract class Message implements Serializable &#123;

    ...

    &#x2F;&#x2F; 添加RPC消息类型
    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;
    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;

    static &#123;
        &#x2F;&#x2F; 将消息类型放入消息类对象Map中
        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);
        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>RPC请求消息</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class RpcRequestMessage extends Message &#123;
    &#x2F;**
     * 调用的接口全限定名，服务端根据它找到实现
     *&#x2F;
    private String interfaceName;
    
    &#x2F;**
     * 调用接口中的方法名
     *&#x2F;
    private String methodName;
    
    &#x2F;**
     * 方法返回类型
     *&#x2F;
    private Class&lt;?&gt; returnType;
    
    &#x2F;**
     * 方法参数类型数组
     *&#x2F;
    private Class[] parameterTypes;
    
    &#x2F;**
     * 方法参数值数组
     *&#x2F;
    private Object[] parameterValue;

    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;
        super.setSequenceId(sequenceId);
        this.interfaceName &#x3D; interfaceName;
        this.methodName &#x3D; methodName;
        this.returnType &#x3D; returnType;
        this.parameterTypes &#x3D; parameterTypes;
        this.parameterValue &#x3D; parameterValue;
    &#125;

    @Override
    public int getMessageType() &#123;
        return RPC_MESSAGE_TYPE_REQUEST;
    &#125;
    
     public String getInterfaceName() &#123;
        return interfaceName;
    &#125;

    public String getMethodName() &#123;
        return methodName;
    &#125;

    public Class&lt;?&gt; getReturnType() &#123;
        return returnType;
    &#125;

    public Class[] getParameterTypes() &#123;
        return parameterTypes;
    &#125;

    public Object[] getParameterValue() &#123;
        return parameterValue;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;RpcRequestMessage&#123;&quot; +
                &quot;interfaceName&#x3D;&#39;&quot; + interfaceName + &#39;\&#39;&#39; +
                &quot;, methodName&#x3D;&#39;&quot; + methodName + &#39;\&#39;&#39; +
                &quot;, returnType&#x3D;&quot; + returnType +
                &quot;, parameterTypes&#x3D;&quot; + Arrays.toString(parameterTypes) +
                &quot;, parameterValue&#x3D;&quot; + Arrays.toString(parameterValue) +
                &#39;&#125;&#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p>
<ul>
<li>方法所在的全限定类名</li>
<li>方法名</li>
<li>方法返回值类型</li>
<li>方法参数类型</li>
<li>方法参数值</li>
</ul>
<p><strong>RPC响应消息</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class RpcResponseMessage extends Message &#123;
    &#x2F;**
     * 返回值
     *&#x2F;
    private Object returnValue;
    &#x2F;**
     * 异常值
     *&#x2F;
    private Exception exceptionValue;

    @Override
    public int getMessageType() &#123;
        return RPC_MESSAGE_TYPE_RESPONSE;
    &#125;
    
    
    public void setReturnValue(Object returnValue) &#123;
        this.returnValue &#x3D; returnValue;
    &#125;

    public void setExceptionValue(Exception exceptionValue) &#123;
        this.exceptionValue &#x3D; exceptionValue;
    &#125;
    
     public Object getReturnValue() &#123;
        return returnValue;
    &#125;

    public Exception getExceptionValue() &#123;
        return exceptionValue;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;RpcResponseMessage&#123;&quot; +
                &quot;returnValue&#x3D;&quot; + returnValue +
                &quot;, exceptionValue&#x3D;&quot; + exceptionValue +
                &#39;&#125;&#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>响应消息中只需要获取<strong>返回结果和异常值</strong></p>
<p><strong>服务器</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class RPCServer &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();
        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);
        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();

        &#x2F;&#x2F; PRC 请求消息处理器
        RpcRequestMessageHandler rpcRequestMessageHandler &#x3D; new RpcRequestMessageHandler();
        try &#123;
            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProtocolFrameDecoder());
                    ch.pipeline().addLast(loggingHandler);
                    ch.pipeline().addLast(messageSharableCodec);
                    ch.pipeline().addLast(rpcRequestMessageHandler);
                &#125;
            &#125;);
            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p>
<p><strong>客户端</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class RPCClient &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();
        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);
        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();

        &#x2F;&#x2F; PRC 请求消息处理器
        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();
        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(group);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProtocolFrameDecoder());
                    ch.pipeline().addLast(loggingHandler);
                    ch.pipeline().addLast(messageSharableCodec);
                    ch.pipeline().addLast(rpcResponseMessageHandler);
                &#125;
            &#125;);
            Channel channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过接口Class获取实例对象的<strong>Factory</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class ServicesFactory &#123;
    static HashMap&lt;Class&lt;?&gt;, Object&gt; map &#x3D; new HashMap&lt;&gt;(16);

    public static Object getInstance(Class&lt;?&gt; interfaceClass) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;
        &#x2F;&#x2F; 根据Class创建实例
        try &#123;
            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloService&quot;);
            Object instance &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;).newInstance();
           
            &#x2F;&#x2F; 放入 InterfaceClass -&gt; InstanceObject 的映射
            map.put(clazz, instance);
        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;
            e.printStackTrace();
        &#125;  
        return map.get(interfaceClass);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage) &#123;
        RpcResponseMessage rpcResponseMessage &#x3D; new RpcResponseMessage();
        try &#123;
            &#x2F;&#x2F; 设置返回值的属性
            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());
            &#x2F;&#x2F; 返回一个实例
            HelloService service &#x3D; (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));
            
            &#x2F;&#x2F; 通过反射调用方法，并获取返回值
            Method method &#x3D; service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());
            &#x2F;&#x2F; 获得返回值
            Object invoke &#x3D; method.invoke(service, rpcMessage.getParameterValue());
            &#x2F;&#x2F; 设置返回值
            rpcResponseMessage.setReturnValue(invoke);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            &#x2F;&#x2F; 设置异常
            rpcResponseMessage.setExceptionValue(e);
        &#125;
    &#125;
    &#x2F;&#x2F; 向channel中写入Message
    ctx.writeAndFlush(rpcResponseMessage);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>远程调用方法主要是通过反射实现的，大致步骤如下</p>
<ul>
<li>通过<strong>请求消息传入被调入方法的各个参数</strong></li>
<li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li>
<li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li>
<li>若有<strong>异常需要捕获，并放入响应消息中</strong></li>
</ul>
<h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;
    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;
        log.debug(&quot;&#123;&#125;&quot;, msg);
        System.out.println((String)msg.getReturnValue());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><pre class="line-numbers language-none"><code class="language-none">public class RPCClient &#123;
    public static void main(String[] args) &#123;
		...
           
        &#x2F;&#x2F; 创建请求并发送
		RpcRequestMessage message &#x3D; new RpcRequestMessage(1,
               &quot;cn.nyimac.study.day8.server.service.HelloService&quot;,
               &quot;sayHello&quot;,
               String.class,
               new Class[]&#123;String.class&#125;,
               new Object[]&#123;&quot;Nyima&quot;&#125;);
		
        channel.writeAndFlush(message);   
            
        ...    
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<p>客户端</p>
<pre class="line-numbers language-none"><code class="language-none">1606 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue&#x3D;你好，Nyima, exceptionValue&#x3D;null&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><pre class="line-numbers language-none"><code class="language-none">public class RPCClientManager &#123;
    &#x2F;**
     * 产生SequenceId
     *&#x2F;
    private static AtomicInteger sequenceId &#x3D; new AtomicInteger(0);
    private static volatile Channel channel &#x3D; null;
    private static final Object lock &#x3D; new Object();
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建代理对象
        HelloService service &#x3D; (HelloService) getProxy(HelloService.class);
        &#x2F;&#x2F; 通过代理对象执行方法
        System.out.println(service.sayHello(&quot;Nyima&quot;));
        System.out.println(service.sayHello(&quot;Hulu&quot;));
    &#125;

    &#x2F;**
     * 单例模式创建Channel
     *&#x2F;
    public static Channel getChannel() &#123;
        if (channel &#x3D;&#x3D; null) &#123;
            synchronized (lock) &#123;
                if (channel &#x3D;&#x3D; null) &#123;
                    init();
                &#125;
            &#125;
        &#125;
        return channel;
    &#125;

    &#x2F;**
     * 使用代理模式，帮助我们创建请求消息并发送
     *&#x2F;
    public static Object getProxy(Class&lt;?&gt; serviceClass) &#123;
        Class&lt;?&gt;[] classes &#x3D; new Class&lt;?&gt;[]&#123;serviceClass&#125;;
        &#x2F;&#x2F; 使用JDK代理，创建代理对象
        Object o &#x3D; Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, new InvocationHandler() &#123;
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                &#x2F;&#x2F; 创建请求消息
                int id &#x3D; sequenceId.getAndIncrement();
                RpcRequestMessage message &#x3D; new RpcRequestMessage(id, serviceClass.getName(),
                        method.getName(), method.getReturnType(),
                        method.getParameterTypes(),
                        args);
                &#x2F;&#x2F; 发送消息
                getChannel().writeAndFlush(message);

                &#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的
                DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());
                &#x2F;&#x2F; 将Promise放入Map中
                RpcResponseMessageHandler.promiseMap.put(id, promise);
                &#x2F;&#x2F; 等待被放入Promise中结果
                promise.await();
                if (promise.isSuccess()) &#123;
                    &#x2F;&#x2F; 调用方法成功，返回方法执行结果
                    return promise.getNow();
                &#125; else &#123;
                    &#x2F;&#x2F; 调用方法失败，抛出异常
                    throw new RuntimeException(promise.cause());
                &#125;
            &#125;
        &#125;);
        return o;
    &#125;

    private static void init() &#123;
        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();
        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);
        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();

        &#x2F;&#x2F; PRC 请求消息处理器
        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();

        Bootstrap bootstrap &#x3D; new Bootstrap();
        bootstrap.channel(NioSocketChannel.class);
        bootstrap.group(group);
        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
            @Override
            protected void initChannel(SocketChannel ch) throws Exception &#123;
                ch.pipeline().addLast(new ProtocolFrameDecoder());
                ch.pipeline().addLast(loggingHandler);
                ch.pipeline().addLast(messageSharableCodec);
                ch.pipeline().addLast(rpcResponseMessageHandler);
            &#125;
        &#125;);
        try &#123;
            channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();
            &#x2F;&#x2F; 异步关闭 group，避免Channel被阻塞
            channel.closeFuture().addListener(future -&gt; &#123;
                group.shutdownGracefully();
            &#125;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>获得Channel</strong></p>
<ul>
<li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li>
<li>通过<strong>单例模式</strong>创建与获取Channel</li>
</ul>
<p><strong>远程调用方法</strong></p>
<ul>
<li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li>
<li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li>
</ul>
<p><strong>远程调用方法返回值获取</strong></p>
<ul>
<li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p>
</li>
<li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p>
<ul>
<li>Key为<strong>SequenceId</strong></li>
<li>Value为对应的<strong>Promise</strong></li>
</ul>
</li>
<li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的
DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());
&#x2F;&#x2F; 将Promise放入Map中
RpcResponseMessageHandler.promiseMap.put(id, promise);
&#x2F;&#x2F; 等待被放入Promise中结果
promise.await();
if (promise.isSuccess()) &#123;
    &#x2F;&#x2F; 调用方法成功，返回方法执行结果
    return promise.getNow();
&#125; else &#123;
    &#x2F;&#x2F; 调用方法失败，抛出异常
    throw new RuntimeException(promise.cause());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p>
<ul>
<li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li>
<li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的Promise
Promise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());
Object returnValue &#x3D; msg.getReturnValue();
Exception exception &#x3D; msg.getExceptionValue();
if (promise !&#x3D; null) &#123;
    if (exception !&#x3D; null) &#123;
        &#x2F;&#x2F; 返回结果中有异常信息
        promise.setFailure(exception);
    &#125; else &#123;
        &#x2F;&#x2F; 方法正常执行，没有异常
        promise.setSuccess(returnValue);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable
public class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;
    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);

    &#x2F;**
     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值
     *&#x2F;
    public static Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap &#x3D; new ConcurrentHashMap&lt;&gt;(16);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;
        &#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的Promise
        Promise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());
        Object returnValue &#x3D; msg.getReturnValue();
        Exception exception &#x3D; msg.getExceptionValue();
        if (promise !&#x3D; null) &#123;
            if (exception !&#x3D; null) &#123;
                &#x2F;&#x2F; 返回结果中有异常信息
                promise.setFailure(exception);
            &#125; else &#123;
                &#x2F;&#x2F; 方法正常执行，没有异常
                promise.setSuccess(returnValue);
            &#125;
        &#125;
        &#x2F;&#x2F; 拿到返回结果并打印
        log.debug(&quot;&#123;&#125;&quot;, msg);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector
Selector selector &#x3D; Selector.open(); 

&#x2F;&#x2F; 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config
NioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();

&#x2F;&#x2F; 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel
ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); 
serverSocketChannel.configureBlocking(false);

&#x2F;&#x2F; 启动 nio boss 线程执行接下来的操作

&#x2F;&#x2F;注册（仅关联 selector 和 NioServerSocketChannel），未关注事件
SelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);

&#x2F;&#x2F; head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor

&#x2F;&#x2F; 绑定端口
serverSocketChannel.bind(new InetSocketAddress(8080));

&#x2F;&#x2F; 触发 channel active 事件，在 head 中关注 op_accept 事件
selectionKey.interestOps(SelectionKey.OP_ACCEPT);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li>
<li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li>
<li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li>
<li>绑定端口</li>
<li>通过<code>interestOps</code>设置感兴趣的事件</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p>
<p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p>
<pre class="line-numbers language-none"><code class="language-none">public ChannelFuture bind(SocketAddress localAddress) &#123;
	validate();
	return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p>
<p><strong>dobind方法在主线程中执行</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private ChannelFuture doBind(final SocketAddress localAddress) &#123;
    &#x2F;&#x2F; 负责NioServerSocketChannel和ServerSocketChannel的创建
    &#x2F;&#x2F; ServerSocketChannel的注册工作
    &#x2F;&#x2F; init由main线程完成，regisetr由NIO线程完成
    final ChannelFuture regFuture &#x3D; initAndRegister();
    final Channel channel &#x3D; regFuture.channel();
    if (regFuture.cause() !&#x3D; null) &#123;
        return regFuture;
    &#125;

    &#x2F;&#x2F; 因为register操作是异步的
    &#x2F;&#x2F; 所以要判断主线程执行到这里时，register操作是否已经执行完毕
    if (regFuture.isDone()) &#123;
        &#x2F;&#x2F; At this point we know that the registration was complete and successful.
        ChannelPromise promise &#x3D; channel.newPromise();
        
        &#x2F;&#x2F; 执行doBind0绑定操作
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    &#125; else &#123;
        &#x2F;&#x2F; Registration future is almost always fulfilled already, but just in case it&#39;s not.
        &#x2F;&#x2F; 如果register操作还没执行完，就会到这个分支中来
        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);
        
        &#x2F;&#x2F; 添加监听器，NIO线程异步进行doBind0操作
        regFuture.addListener(new ChannelFutureListener() &#123;
            @Override
            public void operationComplete(ChannelFuture future) throws Exception &#123;
                Throwable cause &#x3D; future.cause();
                if (cause !&#x3D; null) &#123;
                    &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                    &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.
                    promise.setFailure(cause);
                &#125; else &#123;
                    &#x2F;&#x2F; Registration was successful, so set the correct executor to use.
                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586
                    promise.registered();

                    doBind0(regFuture, channel, localAddress, promise);
                &#125;
            &#125;
        &#125;);
        return promise;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li>
<li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li>
<li><strong>doBind0</strong>则负责连接的创建工作</li>
</ul>
<h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p>
<pre class="line-numbers language-none"><code class="language-none">final ChannelFuture initAndRegister() &#123;
    Channel channel &#x3D; null;
    try &#123;
        channel &#x3D; channelFactory.newChannel();
        init(channel);
    &#125; catch (Throwable t) &#123;
        if (channel !&#x3D; null) &#123;
            &#x2F;&#x2F; channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))
            channel.unsafe().closeForcibly();
            &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        &#125;
        &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    &#125;

    ChannelFuture regFuture &#x3D; config().group().register(channel);
    if (regFuture.cause() !&#x3D; null) &#123;
        if (channel.isRegistered()) &#123;
            channel.close();
        &#125; else &#123;
            channel.unsafe().closeForcibly();
        &#125;
    &#125;

    &#x2F;&#x2F; If we are here and the promise is not failed, it&#39;s one of the following cases:
    &#x2F;&#x2F; 1) If we attempted registration from the event loop, the registration has been completed at this point.
    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now because the channel has been registered.
    &#x2F;&#x2F; 2) If we attempted registration from the other thread, the registration request has been successfully
    &#x2F;&#x2F;    added to the event loop&#39;s task queue for later execution.
    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now:
    &#x2F;&#x2F;         because bind() or connect() will be executed *after* the scheduled registration task is executed
    &#x2F;&#x2F;         because register(), bind(), and connect() are all bound to the same thread.

    return regFuture;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre class="line-numbers language-none"><code class="language-none">Channel channel &#x3D; null;
try &#123;
    &#x2F;&#x2F; 通过反射初始化NioServerSocketChannel
    channel &#x3D; channelFactory.newChannel();
    init(channel);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>newChannel方法</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
public T newChannel() &#123;
    try &#123;
        &#x2F;&#x2F; 通过反射调用NioServerSocketChannel的构造方法
        &#x2F;&#x2F; 创建NioServerSocketChannel对象
        return constructor.newInstance();
    &#125; catch (Throwable t) &#123;
        throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>NioServerSocketChannel构造方法</p>
<pre class="line-numbers language-none"><code class="language-none">public NioServerSocketChannel() &#123;
    &#x2F;&#x2F; 创建了ServerSocketChannel实例
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>newSocket方法</p>
<pre class="line-numbers language-none"><code class="language-none">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;
    try &#123;
        &#x2F;&#x2F; ServerSocketChannel.open方法：
        &#x2F;&#x2F; SelectorProvider.provider().openServerSocketChannel()
	    &#x2F;&#x2F; 所以此处相当于ServerSocketChannel.open()
        &#x2F;&#x2F; 创建了ServerSocketChannel实例
    	return provider.openServerSocketChannel();
	&#125; catch (IOException e) &#123;
  	  throw new ChannelException(&quot;Failed to open a server socket.&quot;, e);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>init方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Override
void init(Channel channel) &#123;
   	...
		
    &#x2F;&#x2F; NioSocketChannl的Pipeline    
    ChannelPipeline p &#x3D; channel.pipeline();
		
    ...

    &#x2F;&#x2F; 向Pipeline中添加了一个handler，该handler等待被调用
    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        &#x2F;&#x2F; register之后才调用该方法
        public void initChannel(final Channel ch) &#123;
            final ChannelPipeline pipeline &#x3D; ch.pipeline();
            
            &#x2F;&#x2F; 创建handler并加入到pipeline中
            ChannelHandler handler &#x3D; config.handler();
            if (handler !&#x3D; null) &#123;
                pipeline.addLast(handler);
            &#125;

            ch.eventLoop().execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    &#x2F;&#x2F; 添加新的handler，在发生Accept事件后建立连接
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                &#125;
            &#125;);
        &#125;
    &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>init主要完成了以下三个操作</strong></p>
<ul>
<li><p>创建NioServerSocketChannel</p>
</li>
<li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p>
</li>
<li><p>由</p>
<pre class="line-numbers language-none"><code class="language-none">initChannel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>方法向NioServerSocketChannel中添加了两个handler，</p>
<p>添加操作在register之后被执行</p>
<ul>
<li>一个handler负责设置配置</li>
<li>一个handler负责发生Accepet事件后建立连接</li>
</ul>
</li>
</ul>
<h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p>
<p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p>
<p><strong>promise.channel().unsafe().register(this, promise)</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Override
public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;
    ...

    &#x2F;&#x2F; 获取EventLoop
    AbstractChannel.this.eventLoop &#x3D; eventLoop;

   	&#x2F;&#x2F; 此处完成了由 主线程 到 NIO线程 的切换
    &#x2F;&#x2F; eventLoop.inEventLoop()用于判断当前线程是否为NIO线程
    if (eventLoop.inEventLoop()) &#123;
        register0(promise);
    &#125; else &#123;
        try &#123;
            &#x2F;&#x2F; 向NIO线程中添加任务
            eventLoop.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    &#x2F;&#x2F; 该方法中会执行doRegister
                    &#x2F;&#x2F; 执行真正的注册操作
                    register0(promise);
                &#125;
            &#125;);
        &#125; catch (Throwable t) &#123;
           ...
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>register0方法</p>
<pre class="line-numbers language-none"><code class="language-none">private void register0(ChannelPromise promise) &#123;
    try &#123;
       	...
            
        &#x2F;&#x2F; 执行真正的注册操作
        doRegister();
        neverRegistered &#x3D; false;
        registered &#x3D; true;

        &#x2F;&#x2F; Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
        &#x2F;&#x2F; user may already fire events through the pipeline in the ChannelFutureListener.
        
        &#x2F;&#x2F; 调用init中的initChannel方法
        pipeline.invokeHandlerAddedIfNeeded();

        ...
    &#125; catch (Throwable t) &#123;
        ...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>doRegister方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void doRegister() throws Exception &#123;
    boolean selected &#x3D; false;
    for (;;) &#123;
        try &#123;
            &#x2F;&#x2F; javaChannel()即为ServerSocketChannel
            &#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector
            &#x2F;&#x2F; this为NIOServerSocketChannel，作为附件
            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        &#125; catch (CancelledKeyException e) &#123;
            ...
           
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>回调initChannel</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
public void initChannel(final Channel ch) &#123;
    final ChannelPipeline pipeline &#x3D; ch.pipeline();
    ChannelHandler handler &#x3D; config.handler();
    if (handler !&#x3D; null) &#123;
        pipeline.addLast(handler);
    &#125;

    &#x2F;&#x2F; 添加新任务，任务负责添加handler
    &#x2F;&#x2F; 该handler负责发生Accepet事件后建立连接
    ch.eventLoop().execute(new Runnable() &#123;
        @Override
        public void run() &#123;
            pipeline.addLast(new ServerBootstrapAcceptor(
                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
        &#125;
    &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Register主要完成了以下三个操作</p>
<ul>
<li><p>完成了主线程到NIO的<strong>线程切换</strong></p>
<ul>
<li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li>
<li>切换的方式为让eventLoop执行register的操作</li>
<li><strong>register的操作在NIO线程中完成</strong></li>
</ul>
</li>
<li><p><strong>调用doRegister方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; javaChannel()即为ServerSocketChannel
&#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector
&#x2F;&#x2F; this为NIOServerSocketChannel，作为附件
selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li>
<li>此时还未关注事件</li>
<li>添加NioServerSocketChannel附件</li>
</ul>
</li>
<li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p>
<ul>
<li><p>initChannel方法主要创建了</p>
<p>两个handler</p>
<ul>
<li>一个handler负责设置配置</li>
<li>一个handler负责发生Accept事件后建立连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; initAndRegister为异步方法，会返回ChannelFuture对象
final ChannelFuture regFuture &#x3D; initAndRegister();
regFuture.addListener(new ChannelFutureListener() &#123;
    @Override
    public void operationComplete(ChannelFuture future) throws Exception &#123;
        Throwable cause &#x3D; future.cause();
        if (cause !&#x3D; null) &#123;
            &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
            &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.
            promise.setFailure(cause);
        &#125; else &#123;
            &#x2F;&#x2F; Registration was successful, so set the correct executor to use.
            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586
            promise.registered();
            &#x2F;&#x2F; 如果没有异常，则执行绑定操作
            doBind0(regFuture, channel, localAddress, promise);
        &#125;
    &#125;
&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p>
<p>NioServerSocketChannel.doBind方法</p>
<p>通过该方法，绑定了对应的端口</p>
<pre class="line-numbers language-none"><code class="language-none">@SuppressJava6Requirement(reason &#x3D; &quot;Usage guarded by java version check&quot;)
@Override
protected void doBind(SocketAddress localAddress) throws Exception &#123;
    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;
        &#x2F;&#x2F; 调用ServerSocketChannel的bind方法，绑定端口
        javaChannel().bind(localAddress, config.getBacklog());
    &#125; else &#123;
        javaChannel().socket().bind(localAddress, config.getBacklog());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p>
<pre class="line-numbers language-none"><code class="language-none">if (!wasActive &amp;&amp; isActive()) &#123;
    invokeLater(new Runnable() &#123;
        @Override
        public void run() &#123;
            pipeline.fireChannelActive();
        &#125;
    &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void doBeginRead() throws Exception &#123;
    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called
    final SelectionKey selectionKey &#x3D; this.selectionKey;
    if (!selectionKey.isValid()) &#123;
        return;
    &#125;
    readPending &#x3D; true;
    final int interestOps &#x3D; selectionKey.interestOps();
    &#x2F;&#x2F; 如果ServerSocketChannel没有关注Accept事件
    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;
        &#x2F;&#x2F; 则让其关注Accepet事件
        &#x2F;&#x2F; readInterestOp 取值是 16
        &#x2F;&#x2F; 在 NioServerSocketChannel 创建时初始化
        selectionKey.interestOps(interestOps | readInterestOp);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p>
<ul>
<li><p>首先获取Channel所有感兴趣的事件</p>
<pre class="line-numbers language-none"><code class="language-none">final int interestOps &#x3D; selectionKey.interestOps();  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>然后再设置其感兴趣的事件</p>
<pre class="line-numbers language-none"><code class="language-none">selectionKey.interestOps(interestOps | readInterestOp);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p><strong>各个事件对应的值</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png" alt="img"></a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p>
<ul>
<li>NioServerSocketChannel与ServerSocketChannel的创建</li>
<li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li>
<li>绑定了对应的端口</li>
<li>关注了Accept事件</li>
</ul>
<h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p>
<ul>
<li><p><strong>Selector</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public final class NioEventLoop extends SingleThreadEventLoop &#123;
    
    ...
        
    &#x2F;&#x2F; selector中的selectedKeys是基于数组的
    &#x2F;&#x2F; unwrappedSelector中的selectedKeys是基于HashSet的    
    private Selector selector;
    private Selector unwrappedSelector;
    private SelectedSelectionKeySet selectedKeys;
    
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>Thread与TaskQueue</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor &#123;
    &#x2F;&#x2F; 任务队列
    private final Queue&lt;Runnable&gt; taskQueue;

    &#x2F;&#x2F; 线程
    private volatile Thread thread;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p>
<pre class="line-numbers language-none"><code class="language-none">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;
    
        ...
           
        &#x2F;&#x2F; 初始化selector，初始化过程在openSelector中
        final SelectorTuple selectorTuple &#x3D; openSelector();
        this.selector &#x3D; selectorTuple.selector;
        this.unwrappedSelector &#x3D; selectorTuple.unwrappedSelector;
&#125;


private SelectorTuple openSelector() &#123;
    final Selector unwrappedSelector;
    try &#123;
        &#x2F;&#x2F; 此处等同于 Selector.open()方法
        &#x2F;&#x2F; 创建了unwrappedSelector对象
        unwrappedSelector &#x3D; provider.openSelector();
    &#125; catch (IOException e) &#123;
        throw new ChannelException(&quot;failed to open a new selector&quot;, e);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p>
<p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p>
<pre class="line-numbers language-none"><code class="language-none">unwrappedSelector &#x3D; provider.openSelector();  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获得了Selector对象<code>unwrappedSelector</code></p>
<p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private static final class SelectorTuple &#123;
    final Selector unwrappedSelector;
    final Selector selector;

    SelectorTuple(Selector unwrappedSelector) &#123;
        this.unwrappedSelector &#x3D; unwrappedSelector;
        this.selector &#x3D; unwrappedSelector;
    &#125;

    &#x2F;**
    * 一般调用的是这个构造方法
    *&#x2F;
    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;
        this.unwrappedSelector &#x3D; unwrappedSelector;
        this.selector &#x3D; selector;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p>
<h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p>
<ul>
<li>selector中的SelectedKeys是<strong>基于数组</strong>的</li>
<li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li>
</ul>
<p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private SelectorTuple openSelector() &#123;
    final Selector unwrappedSelector;
    try &#123;
        unwrappedSelector &#x3D; provider.openSelector();
    &#125; catch (IOException e) &#123;
        throw new ChannelException(&quot;failed to open a new selector&quot;, e);
    &#125;

    ...
    
    &#x2F;&#x2F; 获得基于数组的selectedKeySet实现
    final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();


    Object maybeException &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;
        @Override
        public Object run() &#123;
            try &#123;
                &#x2F;&#x2F; 通过反射拿到unwrappedSelector中的selectedKeys属性
                Field selectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);
                Field publicSelectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);

                ...
	
                &#x2F;&#x2F; 暴力反射，修改私有属性
                Throwable cause &#x3D; ReflectionUtil.trySetAccessible(selectedKeysField, true);
                if (cause !&#x3D; null) &#123;
                    return cause;
                &#125;
                cause &#x3D; ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);
                if (cause !&#x3D; null) &#123;
                    return cause;
                &#125;

                &#x2F;&#x2F; 替换为基于数组的selectedKeys实现
                selectedKeysField.set(unwrappedSelector, selectedKeySet);
                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);
                return null;
            &#125; catch (NoSuchFieldException e) &#123;
                return e;
            &#125; catch (IllegalAccessException e) &#123;
                return e;
            &#125;
        &#125;
    &#125;);

    selectedKeys &#x3D; selectedKeySet;
    
    &#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector
    return new SelectorTuple(unwrappedSelector,
                             new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p>
<ul>
<li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得基于数组的selectedKeySet实现
final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();

SelectedSelectionKeySet() &#123;
	keys &#x3D; new SelectionKey[1024];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p>
</li>
<li><p><strong>通过Selector的构造方法</strong>获得selector</p>
<pre class="line-numbers language-none"><code class="language-none">new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector
return new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p>
<p><strong>测试代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class TestNioEventLoop &#123;
    public static void main(String[] args) &#123;
        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();
        &#x2F;&#x2F; 使用NioEventLoop执行任务
        eventLoop.execute(()-&gt;&#123;
            System.out.println(&quot;hello&quot;);
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进入<code>execute</code>执行任务</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
public void execute(Runnable task) &#123;
    &#x2F;&#x2F; 检测传入的任务是否为空，为空会抛出NullPointerException
    ObjectUtil.checkNotNull(task, &quot;task&quot;);
    &#x2F;&#x2F; 执行任务
    &#x2F;&#x2F; 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true
    execute(task, !(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进入上述代码的<code>execute</code>方法</p>
<pre class="line-numbers language-none"><code class="language-none">private void execute(Runnable task, boolean immediate) &#123;
    &#x2F;&#x2F; 判断当前线程是否为NIO线程
    &#x2F;&#x2F; 判断方法为 return thread &#x3D;&#x3D; this.thread;
    &#x2F;&#x2F; this.thread即为NIO线程，首次执行任务时，其为null
    boolean inEventLoop &#x3D; inEventLoop();
    
    &#x2F;&#x2F; 向任务队列taskQueue中添加任务
    addTask(task);
    
    &#x2F;&#x2F; 当前线程不是NIO线程，则进入if语句
    if (!inEventLoop) &#123;
        &#x2F;&#x2F; 启动NIO线程的核心方法
        startThread();
        
        ...
        
    &#125;
	
    &#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程
    if (!addTaskWakesUp &amp;&amp; immediate) &#123;
        wakeup(inEventLoop);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进入<code>startThread</code>方法</p>
<pre class="line-numbers language-none"><code class="language-none">private void startThread() &#123;
    &#x2F;&#x2F; 查看NIO线程状态是否为未启动
    &#x2F;&#x2F; 该if代码块只会执行一次
    &#x2F;&#x2F; state一开始的值就是ST_NOT_STARTED
    &#x2F;&#x2F; private volatile int state &#x3D; ST_NOT_STARTED;
    if (state &#x3D;&#x3D; ST_NOT_STARTED) &#123;
        &#x2F;&#x2F; 通过原子属性更新器将状态更新为启动（ST_STARTED）
        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;
            boolean success &#x3D; false;
            try &#123;
                &#x2F;&#x2F; 执行启动线程
                doStartThread();
                success &#x3D; true;
            &#125; finally &#123;
                if (!success) &#123;
                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private void doStartThread() &#123;
    assert thread &#x3D;&#x3D; null;
    &#x2F;&#x2F; 创建NIO线程并执行任务
    executor.execute(new Runnable() &#123;
        @Override
        public void run() &#123;
            &#x2F;&#x2F; thread即为NIO线程
            thread &#x3D; Thread.currentThread();
            if (interrupted) &#123;
                thread.interrupt();
            &#125;

            boolean success &#x3D; false;
            updateLastExecutionTime();
            try &#123;
                &#x2F;&#x2F; 执行内部run方法
                SingleThreadEventExecutor.this.run();
                success &#x3D; true;
            &#125; 
            
            ...
    &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p>
<p>该run方法是<strong>NioEvnetLoop的run方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void run() &#123;
    int selectCnt &#x3D; 0;
    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行
    for (;;) &#123;	
      	&#x2F;&#x2F; 执行各种任务
   		try &#123;
            int strategy;
            try &#123;
                strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                switch (strategy) &#123;
                case SelectStrategy.CONTINUE:
                    continue;

                case SelectStrategy.BUSY_WAIT:
                    &#x2F;&#x2F; fall-through to SELECT since the busy-wait is not supported with NIO

                case SelectStrategy.SELECT:
                    long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();
                    if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;
                        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar
                    &#125;
                    nextWakeupNanos.set(curDeadlineNanos);
                    try &#123;
                        if (!hasTasks()) &#123;
                            strategy &#x3D; select(curDeadlineNanos);
                        &#125;
                    &#125; finally &#123;
                        &#x2F;&#x2F; This update is just to help block unnecessary selector wakeups
                        &#x2F;&#x2F; so use of lazySet is ok (no race condition)
                        nextWakeupNanos.lazySet(AWAKE);
                    &#125;
                    &#x2F;&#x2F; fall through
                default:
                &#125;
       		&#125;
    	&#125;
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void run() &#123;
    int selectCnt &#x3D; 0;
    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行
    for (;;) &#123;
      	&#x2F;&#x2F; 执行各种任务
   		...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p>
<p>run方法中有SELECT分支</p>
<pre class="line-numbers language-none"><code class="language-none">case SelectStrategy.SELECT:
	long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();
	if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;
        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar
    &#125;
	nextWakeupNanos.set(curDeadlineNanos);
	try &#123;
    	if (!hasTasks()) &#123;
            &#x2F;&#x2F; 执行select方法
            strategy &#x3D; select(curDeadlineNanos);
        &#125;
    &#125;
	...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private int select(long deadlineNanos) throws IOException &#123;
    &#x2F;&#x2F; 如果没有指定阻塞事件，就调用select()
    if (deadlineNanos &#x3D;&#x3D; NONE) &#123;
        return selector.select();
    &#125;
    &#x2F;&#x2F; 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞
    &#x2F;&#x2F; Timeout will only be 0 if deadline is within 5 microsecs
    long timeoutMillis &#x3D; deadlineToDelayNanos(deadlineNanos + 995000L) &#x2F; 1000000L;
    return timeoutMillis &lt;&#x3D; 0 ? selector.selectNow() : selector.select(timeoutMillis);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p>
<p>唤醒是通过execute最后的if代码块来完成的</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程
if (!addTaskWakesUp &amp;&amp; immediate) &#123;
    wakeup(inEventLoop);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void wakeup(boolean inEventLoop) &#123;
    &#x2F;&#x2F; 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒
    &#x2F;&#x2F; 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功
    if (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) !&#x3D; AWAKE) &#123;
        &#x2F;&#x2F; 唤醒被selector.select方法阻塞的NIO线程
        selector.wakeup();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>唤醒时需要进行两个判断</p>
<ul>
<li><p>判断提交任务的</p>
<p>是否为NIO线程</p>
<ul>
<li>若是其他线程，才能唤醒NIO线程</li>
<li>若是NIO线程自己，则不能唤醒</li>
</ul>
</li>
<li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p>
</li>
</ul>
<h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p>
<pre class="line-numbers language-none"><code class="language-none">int strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
switch (strategy) &#123;
	...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>strategy的值由<code>calculateStrategy</code>方法确定</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;
    &#x2F;&#x2F; selectSupplier.get() 底层是 selector.selectNow();
    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p>
<ul>
<li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p>
<ul>
<li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private final IntSupplier selectNowSupplier &#x3D; new IntSupplier() &#123;
    public int get() throws Exception &#123;
        return NioEventLoop.this.selectNow();
    &#125;
&#125;;

int selectNow() throws IOException &#123;
    return this.selector.selectNow();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>若没有任务，就会进入SELECT分支</p>
</li>
</ul>
<p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p>
<h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p>
<p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void run() &#123;
    ...
    for(;;)&#123;
        ...
        &#x2F;&#x2F; 可能发生空轮询，无法阻塞NIO线程
        strategy &#x3D; select(curDeadlineNanos);  
        ...     
    
     	if(...) &#123;
			...
     	&#125; else if (unexpectedSelectorWakeup(selectCnt) )&#123;
            &#x2F;&#x2F; 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector
            &#x2F;&#x2F; 并将selectCnt重置为0
            selectCnt &#x3D; 0;
        &#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p>
<p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p>
<pre class="line-numbers language-none"><code class="language-none">if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;
    &#x2F;&#x2F; The selector returned prematurely many times in a row.
    &#x2F;&#x2F; Rebuild the selector to work around the problem.
    logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,selectCnt, selector);
    &#x2F;&#x2F; 重建selector，将原selector的配置信息传给新selector
    &#x2F;&#x2F; 再用新selector覆盖旧selector
    rebuildSelector();
    return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p>
<h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p>
<p><strong>NioEventLoop.run方法</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 处理IO事件时间比例，默认为50%
final int ioRatio &#x3D; this.ioRatio;

&#x2F;&#x2F; 如果IO事件时间比例设置为100%
if (ioRatio &#x3D;&#x3D; 100) &#123;
    try &#123;
        &#x2F;&#x2F; 如果需要去处理IO事件
        if (strategy &gt; 0) &#123;
            &#x2F;&#x2F; 先处理IO事件
            processSelectedKeys();
        &#125;
    &#125; finally &#123;
        &#x2F;&#x2F; Ensure we always run tasks.
        &#x2F;&#x2F; 剩下的时间都去处理普通任务和定时任务
        ranTasks &#x3D; runAllTasks();
    &#125;
&#125; else if (strategy &gt; 0) &#123; &#x2F;&#x2F; 如果需要去处理IO事件
    &#x2F;&#x2F; 记录处理IO事件前的时间
    final long ioStartTime &#x3D; System.nanoTime();
    try &#123;
        &#x2F;&#x2F; 去处理IO事件
        processSelectedKeys();
    &#125; finally &#123;
        &#x2F;&#x2F; Ensure we always run tasks.
        &#x2F;&#x2F; ioTime为处理IO事件耗费的事件
        final long ioTime &#x3D; System.nanoTime() - ioStartTime;
        &#x2F;&#x2F; 计算出处理其他任务的事件
        &#x2F;&#x2F; 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行
        ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);
    &#125;
&#125; else &#123; &#x2F;&#x2F; 没有IO事件需要处理
    &#x2F;&#x2F; This will run the minimum number of tasks
    &#x2F;&#x2F; 直接处理普通和定时任务
    ranTasks &#x3D; runAllTasks(0); 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p>
<ul>
<li><p>判断ioRatio是否为100</p>
<ul>
<li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p>
<ul>
<li>若需要处理IO事件，则先处理IO事件</li>
</ul>
</li>
<li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 没有指定执行任务的时间
ranTasks &#x3D; runAllTasks();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>若ioRatio不为100</p>
<ul>
<li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p>
</li>
<li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 比如ioTime为10s，ioRatio为50
&#x2F;&#x2F; 那么通过 10*(100-50)&#x2F;50&#x3D;10 计算出其他任务可用的时间为 10s
&#x2F;&#x2F; 处理IO事件占用的事件总比例为50%
ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p>
</li>
</ul>
</li>
<li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 运行最少数量的任务
ranTasks &#x3D; runAllTasks(0);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p>
<pre class="line-numbers language-none"><code class="language-none">private void processSelectedKeys() &#123;
    &#x2F;&#x2F; 如果selectedKeys是基于数组的
    &#x2F;&#x2F; 一般情况下都走这个分支
    if (selectedKeys !&#x3D; null) &#123;
        &#x2F;&#x2F; 处理各种IO事件
        processSelectedKeysOptimized();
    &#125; else &#123;
        processSelectedKeysPlain(selector.selectedKeys());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>processSelectedKeysOptimized方法</p>
<pre class="line-numbers language-none"><code class="language-none">private void processSelectedKeysOptimized() &#123;
    for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;
        &#x2F;&#x2F; 拿到SelectionKeyec
        final SelectionKey k &#x3D; selectedKeys.keys[i];
        &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close
        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363
        selectedKeys.keys[i] &#x3D; null;

        &#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel
        final Object a &#x3D; k.attachment();

        if (a instanceof AbstractNioChannel) &#123;
            &#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel
            processSelectedKey(k, (AbstractNioChannel) a);
        &#125; else &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;
            processSelectedKey(k, task);
        &#125;

        if (needsToSelectAgain) &#123;
            &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close
            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363
            selectedKeys.reset(i + 1);

            selectAgain();
            i &#x3D; -1;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p>
<pre class="line-numbers language-none"><code class="language-none">final SelectionKey k &#x3D; selectedKeys.keys[i];  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel
final Object a &#x3D; k.attachment();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果附件继承自AbstractNioChannel，则会调用</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel
processSelectedKey(k, (AbstractNioChannel) a);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>去处理各个事件</p>
<p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p>
<p>获取SelectionKey的事件，然后进行相应处理</p>
<pre class="line-numbers language-none"><code class="language-none">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;
    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();
    if (!k.isValid()) &#123;
        final EventLoop eventLoop;
        try &#123;
            eventLoop &#x3D; ch.eventLoop();
        &#125; catch (Throwable ignored) &#123;
            &#x2F;&#x2F; If the channel implementation throws an exception because there is no event loop, we ignore this
            &#x2F;&#x2F; because we are only trying to determine if ch is registered to this event loop and thus has authority
            &#x2F;&#x2F; to close ch.
            return;
        &#125;
        &#x2F;&#x2F; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
        &#x2F;&#x2F; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
        &#x2F;&#x2F; still healthy and should not be closed.
        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;5125
        if (eventLoop &#x3D;&#x3D; this) &#123;
            &#x2F;&#x2F; close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
        &#125;
        return;
    &#125;

    try &#123;
        int readyOps &#x3D; k.readyOps();
        &#x2F;&#x2F; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
        &#x2F;&#x2F; the NIO JDK channel implementation may throw a NotYetConnectedException.
        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;
            &#x2F;&#x2F; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;924
            int ops &#x3D; k.interestOps();
            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);

            unsafe.finishConnect();
        &#125;

        &#x2F;&#x2F; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;
            &#x2F;&#x2F; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        &#125;

        &#x2F;&#x2F; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        &#x2F;&#x2F; to a spin loop
        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;
            unsafe.read();
        &#125;
    &#125; catch (CancelledKeyException ignored) &#123;
        unsafe.close(unsafe.voidPromise());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p>
<ul>
<li>selector.select()阻塞线程，直到事件发生</li>
<li>遍历selectionKeys</li>
<li>获取一个key，判断事件类型是否为Accept</li>
</ul>
<hr>
<ul>
<li>创建SocketChannel，设置为非阻塞</li>
<li>将SocketChannel注册到selector中</li>
<li>关注selectionKeys的read事件</li>
</ul>
<p>代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 阻塞直到事件发生
selector.select();

Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectionKeys().iterator();
while (iter.hasNext()) &#123;    
    &#x2F;&#x2F; 拿到一个事件
    SelectionKey key &#x3D; iter.next();
    
    &#x2F;&#x2F; 如果是 accept 事件
    if (key.isAcceptable()) &#123;
        
        &#x2F;&#x2F; 执行accept，获得SocketChannel
        SocketChannel channel &#x3D; serverSocketChannel.accept();
        channel.configureBlocking(false);
        
        &#x2F;&#x2F; 将SocketChannel注册到selector中，并关注read事件
        channel.register(selector, SelectionKey.OP_READ);
    &#125;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p>
<h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p>
<pre class="line-numbers language-none"><code class="language-none">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;
	unsafe.read();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>NioMessageUnsafe.read</code>方法</p>
<pre class="line-numbers language-none"><code class="language-none">public void read() &#123;

    ...
    
    try &#123;
        try &#123;
            do &#123;
				&#x2F;&#x2F; doReadMessages中执行了accept获得了SocketChannel
                &#x2F;&#x2F; 并创建NioSocketChannel作为消息放入readBuf
                &#x2F;&#x2F; readBuf是一个ArrayList用来缓存消息
                &#x2F;&#x2F; private final List&lt;Object&gt; readBuf &#x3D; new ArrayList&lt;Object&gt;();
                int localRead &#x3D; doReadMessages(readBuf);
                
                ...
                
				&#x2F;&#x2F; localRead值为1，就一条消息，即接收一个客户端连接
                allocHandle.incMessagesRead(localRead);
            &#125; while (allocHandle.continueReading());
        &#125; catch (Throwable t) &#123;
            exception &#x3D; t;
        &#125;

        int size &#x3D; readBuf.size();
        for (int i &#x3D; 0; i &lt; size; i ++) &#123;
            readPending &#x3D; false;
            &#x2F;&#x2F; 触发read事件，让pipeline上的handler处理
            &#x2F;&#x2F; ServerBootstrapAcceptor.channelRead
            pipeline.fireChannelRead(readBuf.get(i));
        &#125;
        
        ...
        
    &#125; finally &#123;
        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;
            removeReadOp();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>NioSocketChannel.doReadMessages</code>方法</p>
<p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;
    &#x2F;&#x2F; 处理accpet事件，获得SocketChannel
    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());

    try &#123;
        if (ch !&#x3D; null) &#123;
            &#x2F;&#x2F; 创建了NioSocketChannel，作为消息放在了readBuf中
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        &#125;
    &#125; catch (Throwable t) &#123;
       ...
    &#125;

    return 0;
&#125;
ServerBootstrapAcceptor.channelRead
public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
    &#x2F;&#x2F; 这时的msg是NioSocketChannel
    final Channel child &#x3D; (Channel) msg;

    &#x2F;&#x2F; NioSocketChannel添加childHandler，即初始化器
    child.pipeline().addLast(childHandler);

    &#x2F;&#x2F; 设置选项
    setChannelOptions(child, childOptions, logger);

    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;
        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());
    &#125;

    try &#123;
        &#x2F;&#x2F; 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程
        childGroup.register(child).addListener(new ChannelFutureListener() &#123;
            @Override
            public void operationComplete(ChannelFuture future) throws Exception &#123;
                if (!future.isSuccess()) &#123;
                    forceClose(child, future.cause());
                &#125;
            &#125;
        &#125;);
    &#125; catch (Throwable t) &#123;
        forceClose(child, t);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;
    
    ...

    AbstractChannel.this.eventLoop &#x3D; eventLoop;

    if (eventLoop.inEventLoop()) &#123;
        register0(promise);
    &#125; else &#123;
        try &#123;
            &#x2F;&#x2F; 这行代码完成的是nio boss -&gt; nio worker线程的切换
            eventLoop.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    &#x2F;&#x2F; 真正的注册操作
                    register0(promise);
                &#125;
            &#125;);
        &#125; catch (Throwable t) &#123;
            ...
        &#125;
    &#125;
&#125;
AbstractChannel.AbstractUnsafe.register0
private void register0(ChannelPromise promise) &#123;
    try &#123;
        
        ...
            
        &#x2F;&#x2F; 该方法将SocketChannel注册到Selector中
        doRegister();
        
        &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail
        pipeline.invokeHandlerAddedIfNeeded();
        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail

        safeSetSuccess(promise);
        pipeline.fireChannelRegistered();
        
        if (isActive()) &#123;
            if (firstRegistration) &#123;
                &#x2F;&#x2F; 触发pipeline上active事件
                pipeline.fireChannelActive();
            &#125; else if (config().isAutoRead()) &#123;
                beginRead();
            &#125;
        &#125;
    &#125; catch (Throwable t) &#123;
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
protected void doRegister() throws Exception &#123;
    boolean selected &#x3D; false;
    for (;;) &#123;
        try &#123;
            &#x2F;&#x2F; 将Selector注册到Selector中
            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        &#125; catch (CancelledKeyException e) &#123;
            ...
        &#125;
    &#125;
&#125;
HeadContext.channelActive
public void channelActive(ChannelHandlerContext ctx) &#123;
    ctx.fireChannelActive();
	&#x2F;&#x2F; 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)
    readIfIsAutoRead();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p>
<pre class="line-numbers language-none"><code class="language-none">protected void doBeginRead() throws Exception &#123;
    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called
    final SelectionKey selectionKey &#x3D; this.selectionKey;
    if (!selectionKey.isValid()) &#123;
        return;
    &#125;

    readPending &#x3D; true;
	&#x2F;&#x2F; 这时候 interestOps是0
    final int interestOps &#x3D; selectionKey.interestOps();
    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;
        &#x2F;&#x2F; 关注read事件
        selectionKey.interestOps(interestOps | readInterestOp);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p>
<pre class="line-numbers language-none"><code class="language-none">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;
	unsafe.read();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Override
public final void read() &#123;
    &#x2F;&#x2F; 获得Channel的配置
    final ChannelConfig config &#x3D; config();
    if (shouldBreakReadReady(config)) &#123;
        clearReadPending();
        return;
    &#125;
    final ChannelPipeline pipeline &#x3D; pipeline();
	&#x2F;&#x2F; 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）
	final ByteBufAllocator allocator &#x3D; config.getAllocator();
    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小
    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();
    allocHandle.reset(config);

    ByteBuf byteBuf &#x3D; null;
    boolean close &#x3D; false;
    try &#123;
        do &#123;
            &#x2F;&#x2F; 创建ByteBuf
            byteBuf &#x3D; allocHandle.allocate(allocator);
            &#x2F;&#x2F; 读取内容，放入ByteBUf中
            allocHandle.lastBytesRead(doReadBytes(byteBuf));
            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;
                byteBuf.release();
                byteBuf &#x3D; null;
                close &#x3D; allocHandle.lastBytesRead() &lt; 0;
                if (close) &#123;
                    readPending &#x3D; false;
                &#125;
                break;
            &#125;

            allocHandle.incMessagesRead(1);
            readPending &#x3D; false;
            &#x2F;&#x2F; 触发read 事件，让pipeline上的handler处理
            &#x2F;&#x2F; 这时是处理NioSocketChannel上的handler
            pipeline.fireChannelRead(byteBuf);
            byteBuf &#x3D; null;
        &#125; 
        &#x2F;&#x2F; 是否要继续循环
        while (allocHandle.continueReading());

        allocHandle.readComplete();
        &#x2F;&#x2F; 触发 read complete事件
        pipeline.fireChannelReadComplete();

        if (close) &#123;
            closeOnRead(pipeline);
        &#125;
    &#125; catch (Throwable t) &#123;
        handleReadException(pipeline, byteBuf, t, close, allocHandle);
    &#125; finally &#123;
         &#x2F;&#x2F; Check if there is a readPending which was not processed yet.
         &#x2F;&#x2F; This could be for two reasons:
         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
         &#x2F;&#x2F;
         &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2254
        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;
            removeReadOp();
        &#125;
    &#125;
&#125;
DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)
public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;
    return 
           &#x2F;&#x2F; 一般为true
           config.isAutoRead() &amp;&amp;
           &#x2F;&#x2F; respectMaybeMoreData默认为true
           &#x2F;&#x2F; maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true
           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;
           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead默认16
           totalMessages &lt; maxMessagePerRead &amp;&amp;
           &#x2F;&#x2F; 实际读到了数据
           totalBytesRead &gt; 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">KTS</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://wzykt.github.io/2021/11/29/netty/">https://wzykt.github.io/2021/11/29/netty/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">KTS</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Netty/">
                                    <span class="chip bg-color">Netty</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/11/29/netty-xue-xi-zhi-nio-ji-chu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/images/23.jpg" class="responsive-img" alt="Netty学习之NIO基础">
                        
                        <span class="card-title">Netty学习之NIO基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%BD%AC%E8%BD%BD/" class="post-category">
                                    转载
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/NIO/">
                        <span class="chip bg-color">NIO</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/11/29/springcloud/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/images/25.jpg" class="responsive-img" alt="SpringCloud学习笔记">
                        
                        <span class="card-title">SpringCloud学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">
                        <span class="chip bg-color">微服务</span>
                    </a>
                    
                    <a href="/tags/Nacos/">
                        <span class="chip bg-color">Nacos</span>
                    </a>
                    
                    <a href="/tags/Eureka/">
                        <span class="chip bg-color">Eureka</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="song"
                   id="003UkWuI0E8U0l"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <a href="/about" target="_blank">KTS</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "11";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis"></div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
