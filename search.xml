<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis</title>
      <link href="/2021/12/14/redis/"/>
      <url>/2021/12/14/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h1><h2 id="1-什么是NOSQL"><a href="#1-什么是NOSQL" class="headerlink" title="1.什么是NOSQL"></a>1.什么是NOSQL</h2><p>NoSQL(NoSQL=Not Only SQL)：</p><p>意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p><p>NoSQL是一个通用术语，用于指不遵循传统RDBMS模型的任何数据存储——具体来说，数据是非关系型的，它不使用SQL作为主要查询语言。它是用于指试图解决可伸缩性和可用性问题而不是原子性或一致性问题的数据库。</p><p>NoSQL可以用描述任何一种数据文件，不具备传统关系型数据库的范式，NoSQL是非关系型设计的Database，主要针对当前互联网时代的复杂数据，不去关注数据间的复杂关系。</p><h2 id="2-为什么需要NOSQL"><a href="#2-为什么需要NOSQL" class="headerlink" title="2.为什么需要NOSQL"></a>2.为什么需要NOSQL</h2><p>随着互联网的高速崛起，网站的用户群的增加，访问量的上升，传统数据库上都开始出现了性能瓶颈，web程序不再仅仅专注在功能上，同时也在追求性能。所以NOSQL数据库应运而上，具体表现为对如下三高问题的解决：</p><p><strong>High performance - 对数据库高并发读写的需求</strong></p><p>web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负</p><p>载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就</p><p>已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点</p><p>击次数，投票计数等，因此这是一个相当普遍的需求。</p><p><strong>Huge Storage - 对海量数据的高效率存储和访问的需求</strong></p><p>类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户</p><p>动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登</p><p>录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。</p><p><strong>High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求</strong></p><p>在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像</p><p>web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站</p><p>来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来</p><p>实现扩展呢？</p><h2 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3.NoSQL的四大分类"></a>3.NoSQL的四大分类</h2><table><thead><tr><th>分类</th><th>举例</th><th>典型应用场景</th><th>数据模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>键值（key-value）</strong></td><td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td><strong>列存储数据库</strong></td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td><strong>文档型数据库</strong></td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td><strong>图形(Graph)数据库</strong></td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td></tr></tbody></table><p><strong>键值( Key-Value )存储数据库</strong></p><p>这一类数据库主要会使用到一个 哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果 DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。 [3]  举例如：Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB.</p><p><strong>列存储数据库。</strong></p><p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra, HBase, Riak.</p><p><strong>文档型数据库</strong></p><p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, </p><p>MongoDB. 国内也有文档型数据库SequoiaDB，目前已经开源。</p><p><strong>图形(Graph)数据库</strong><br>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 [2]  如：Neo4J, InfoGrid, Infinite Graph.</p><p>因此，我们总结NoSQL数据库在以下的这几种情况下比较适用：1、数据模型比较简单；2、需要灵活性更强的IT系统；3、对数据库性能要求较高；4、不需要高度的数据一致性；5、对于给定key，比较容易映射复杂值的环境。</p><p><a href="https://www.cnblogs.com/yejg1212/p/3584094.html">常见的NoSQL数据库</a></p><h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><h2 id="Redis中文文档"><a href="#Redis中文文档" class="headerlink" title="Redis中文文档"></a>Redis中文文档</h2><p><a href="http://www.redis.cn/">http://www.redis.cn/</a></p><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p><p><strong>官网介绍</strong></p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a><strong>Redis特点</strong></h2><p>Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，它的读取速度可高达110000次/s，写速度高达81000次/s。</p><p>Redis跟memcache不同的是，储存在Redis中的数据是持久化的，断电或重启后，数据也不会丢失。因为Redis的存储分为内存存储、磁盘存储和log文件三部分，重启后，Redis可以从磁盘重新将数据加载到内存中，这些可以通过配置文件对其进行配置，正因为这样，Redis才能实现持久化。</p><p>Redis支持主从模式，可以配置集群，这样更利于支撑起大型的项目，这也是Redis的一大亮点。</p><h2 id="Redis应用场景，它能做什么"><a href="#Redis应用场景，它能做什么" class="headerlink" title="Redis应用场景，它能做什么"></a><strong>Redis应用场景，它能做什么</strong></h2><p>众多语言都支持Redis，因为Redis交换数据快，所以在服务器中常用来存储一些需要频繁调取的数据，这样可以大大节省系统直接读取磁盘来获得数据的I/O开销，更重要的是可以极大提升速度。 </p><p>拿大型网站来举个例子，比如a网站首页一天有100万人访问，其中有一个板块为推荐新闻。要是直接从数据库查询，那么一天就要多消耗100万次数据库请求。上面已经说过，Redis支持丰富的数据类型，所以这完全可以用Redis来完成，将这种热点数据存到Redis（内存）中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。</p><p><strong>具体应用</strong></p><p>1，会话缓存（最常用）</p><p>2，消息队列，比如支付</p><p>3，活动排行榜或计数</p><p>4，发布，订阅消息（消息通知）</p><p>5，商品列表，评论列表等</p><h2 id="Redis下载"><a href="#Redis下载" class="headerlink" title="Redis下载"></a>Redis下载</h2><p>Windows版本</p><p><strong>下载地址：</strong><a href="https://github.com/tporadowski/redis/releases%E3%80%82">https://github.com/tporadowski/redis/releases。</a></p><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="Redis性能测试"><a href="#Redis性能测试" class="headerlink" title="Redis性能测试"></a>Redis性能测试</h2><p>redis-benchmark是一个压力测试工具</p><p>Redis性能测试工具可选参数如下所示：</p><table><thead><tr><th align="left">序号</th><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输 <numreq> 请求</td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><p>Redis-benchmark命令的使用示例如下所示。</p><ul><li><p>如下命令所示，使用100个并发连接、100000个请求检测端口为6379的Redis服务器性能。</p><pre class="line-numbers language-none"><code class="language-none">redis-benchmark -h 192.X.X.201 -p 6379 -c 100 -n 100000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如下命令所示，测试获取大小为100字节的数据包的性能。</p><pre class="line-numbers language-none"><code class="language-none">redis-benchmark -h X.X.X.X -p 6379 -q -d 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如下命令所示，只测试部分操作的性能。</p><pre class="line-numbers language-none"><code class="language-none">redis-benchmark -t set,lpush -n 100000 -q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><img src="C:/Users/WZY/AppData/Roaming/Typora/typora-user-images/image-20210415193636975.png" alt="image-20210415193636975"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis数据存储格式</p><p>redis自身是一个Map，其中所有的数据都是采用key : value的形式存储</p><p>数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213162305492.png" alt="image-20211213162305492"></p><blockquote><p> <strong>Redis是单线程的</strong></p></blockquote><p>Redis是基于内存操作的，CPU不是Redis的瓶颈，机器的内存和网络带宽是瓶颈 </p><blockquote><p><strong>为什么Redis单线程很快？</strong></p></blockquote><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p><p>（1）多路 I/O 复用模型</p><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><p><a href="https://blog.csdn.net/xlgen157387/article/details/79470556">为什么说Redis是单线程的以及Redis为什么这么快！</a></p><blockquote><p><strong>什么是cpu上下文切换?</strong></p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p><h2 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.<strong>简介</strong></h4><p>　　string 类型是 Redis 中最基本的数据类型，最常用的数据类型，甚至被很多玩家当成 redis 唯一的数据类型去使用。string 类型在 redis 中是二进制安全(binary safe)的,这意味着 string 值关心二进制的字符串，不关心具体格式，你可以用它存储 json 格式或 JPEG 图片格式的字符串。</p><ul><li><p>存储的数据:单个数据，最简单的数据存储类型，也是最常用的数据存</p></li><li><p>储类型存储数据的格式:一个存储空间保存一个数据</p></li><li><p>存储内容:通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p></li></ul><h4 id="2-相关命令及操作"><a href="#2-相关命令及操作" class="headerlink" title="2.相关命令及操作"></a>2.相关命令及操作</h4><p>菜鸟教程：<a href="https://www.runoob.com/redis/redis-strings.html">https://www.runoob.com/redis/redis-strings.html</a></p><ul><li><p>string 作为数值操作</p><ul><li><p>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</p></li><li><p>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</p></li><li><p>注意:按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。9223372036854775807 (java中long型数据最大值，Long.MAX_VALUE)</p></li></ul></li><li><p>redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</p><p><code>setex key seconds value</code></p><p><code>psetex key milliseconds value</code></p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.<strong>简介</strong></h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），像双端队列。</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><ul><li>数据存储需求:存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构:一个存储空间保存多个数据，且通过数据可以体现进入顺序</li><li>list类型:保存多个数据，底层使用双向链表存储结构实现</li></ul><h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h4><ul><li>各种列表，比如twitter的关注列表、粉丝列表等，最新消息排行、每篇文章的评论等也可以用Redis的list结构来实现。</li><li>消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出执行。这里的消息队列并没有ack机制，如果消费者把任务给Pop走了又没处理完就死机了怎么办？解决方法之一是加多一个sorted set，分发的时候同时发到list与sorted set，以分发时间为score，用户把任务做完了之后要用ZREM消掉sorted set里的job，并且定时从sorted set中取出超时没有完成的任务，重新放回list。另一个做法是为每个worker多加一个的list，弹出任务时改用RPopLPush，将job同时放到worker自己的list中，完成时用LREM消掉。如果集群管理(如zookeeper)发现worker已经挂掉，就将worker的list内容重新放回主list。</li><li>利用LRANGE可以很方便的实现list内容分页的功能。</li><li>取最新N个数据的操作：LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。</li></ul><h4 id="3-Redis-列表命令"><a href="#3-Redis-列表命令" class="headerlink" title="3.Redis 列表命令"></a>3.Redis 列表命令</h4><p>下表列出了列表相关的基本命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/lists-blpop.html">BLPOP key1/key2 timeout</a>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/lists-brpop.html">BRPOP key1/key2 timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a> 通过索引获取列表中的元素</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a> 获取列表长度</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a> 移出并获取列表的第一个元素</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpush.html">LPUSH key value1 /value2]</a> 将一个或多个值插入到列表头部</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a> 获取列表指定范围内的元素</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a> 移除列表元素</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a> 通过索引设置列表元素的值</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpush.html">RPUSH key value1/value2]</a> 在列表中添加一个或多个值</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td></tr></tbody></table><p>注意：数据从那边进，就从反方向读</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p>set类型:与hash存储结构完全相同，仅存储键，不存储值(nil)，并且值是不允许重复的</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213192425622.png" alt="image-20211213192425622"></p><h4 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2.应用场景"></a>2.应用场景</h4><ul><li><p>某些需要去重的列表，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p></li><li><p>可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。</p></li><li><p>Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。又比如QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这里也可以把每一个用户的标签都存储在一个集合之中。</p></li><li><p>权限校验</p></li><li><p>实现网站访问量统计</p><p>公司对旗下新的网站做推广，统计网站的PV(访问量),UV(独立访客) ,IP (独立IP)。</p><p>PV:网站被访问次数，可通过刷新页面提高访问量</p><p>UV∶网站被不同用户访问的次数，可通过cookie统计访问量，相同用户切换IP地址，UV不变</p><p>IP:网站被不同IP地址访问的总次数，可通过IP地址统计访问量，相同IP不同用户访问，IP不变</p></li><li><p>黑白名单</p></li></ul><h4 id="3-Redis-集合命令"><a href="#3-Redis-集合命令" class="headerlink" title="3.Redis 集合命令"></a>3.Redis 集合命令</h4><p>下表列出了 Redis 集合基本命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/sets-sadd.html">SADD key member1/member2</a> 向集合添加一个或多个成员</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a> 获取集合的成员数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF key1/key2</a> 返回第一个集合与其他集合之间的差异。(差集)</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/sets-sdiffstore.html">SDIFFSTORE destination key1/key2</a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/sets-sinter.html">SINTER key1/key2</a> 返回给定所有集合的交集</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/sets-sinterstore.html">SINTERSTORE destination key1/key2</a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a> 返回集合中的所有成员</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a> 移除并返回集合中的一个随机元素</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/sets-srandmember.html">SRANDMEMBER key count</a> 返回集合中一个或多个随机数</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/sets-srem.html">SREM key member1 member2</a> 移除集合中一个或多个成员</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/sets-sunion.html">SUNION key1 key2</a> 返回所有给定集合的并集</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/sets-sunionstore.html">SUNIONSTORE destination key1/key2</a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="left">15</td><td align="left">[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a><strong>1.简介</strong></h4><p>新的存储需求:对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p><p>需要的存储结构:一个存储空间保存多个键值对数据</p><p>hash类型:底层使用哈希表结构实现数据存储</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213164500961.png" alt="image-20211213164500961"></p><p><strong>hash存储结构优化</strong></p><p>如果field数量较少，存储结构优化为类数组结构</p><p>如果field数量较多，存储结构使用HashMap结构</p><p><strong>hash类型数据操作的注意事项</strong></p><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现 象。如果数据未获取到,对应的值为(nil)</li><li>每个 hash可以存储232-1个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ul><h4 id="2-Redis-hash-命令"><a href="#2-Redis-hash-命令" class="headerlink" title="2.Redis hash 命令"></a>2.Redis hash 命令</h4><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1/field2</a> 删除一个或多个哈希表字段</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hexists.html">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a> 获取存储在哈希表中指定字段的值。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a> 获取所有哈希表中的字段</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a> 获取哈希表中字段的数量</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hmget.html">HMGET key field1 field2]</a> 获取所有给定字段的值</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hmset.html">HMSET key field1 value1 field2 value2 ]</a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a> 将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a> 获取哈希表中所有值。</td></tr><tr><td align="left">14</td><td align="left">[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a> 迭代哈希表中的键值对。</td></tr></tbody></table><h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><p>电商网站购物车设计与实现</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213165621697.png" alt="image-20211213165621697"></p><p>业务分析</p><ul><li><p>仅分析购物车的redis存储模型<br>添加、浏览、更改数量、删除、清空</p></li><li><p>购物车于数据库间持久化同步(不讨论)</p></li><li><p>购物车于订单间关系(不讨论)</p><p>提交购物车:读取数据生成订单</p><p>商家临时价格调整:隶属于订单级别</p></li><li><p>未登录用户购物车信息存储(不讨论)<br>cookie存储</p></li></ul><p>解决方案</p><p>以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息</p><p>将商品编号作为field，购买数量作为value进行存储</p><p>添加商品:追加全新的field与value</p><p>浏览:遍历hash</p><p>更改数量:自增/自减，设置value值</p><p>删除商品:删除field</p><p>清空:删除key</p><blockquote><p> 当前设计是否加速了购物车的呈现？  答：没有</p></blockquote><p>当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库</p><p>每条购物车中的商品记录保存成两条field</p><p>field1专用于保存购买数量</p><p>​    命名格式:商品id:nums</p><p>​    保存数据:数值</p><p>field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等</p><p>​    命名格式:商品id:info</p><p>​    保存数据: json</p><blockquote><p>当商品信息对应的json相同时，如何区分？</p></blockquote><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213171541638.png" alt="image-20211213171541638"></p><p>field2作为独立的hash，专门作为存储信息的hash，类似于外键，field2不在存储信息而是存储信息对应的key，进行二次查找，不过不需要再走数据库，速度有保障。</p><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><h4 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="1.简介"></a>1.简介</h4><p>sorted_set类型:在set的存储结构基础上添加可排序字段</p><p>和Set不同的是每个元素都会关联一个 double 类型的分数score。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 </p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211213195328194.png" alt="image-20211213195328194"></p><p><strong>注意</strong></p><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li><li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据,score值将被反复覆盖，保留最后一次修改的结果</li></ul><h4 id="2-Redis-有序集合命令"><a href="#2-Redis-有序集合命令" class="headerlink" title="2.Redis 有序集合命令"></a>2.Redis 有序集合命令</h4><p>下表列出了 redis 有序集合的基本命令:</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD key score1 member1 score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">ZINTERSTORE destination numkeys key key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrange.html">ZRANGE key start stop WITHSCORES</a> 通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">ZRANGEBYLEX key min max LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td></tr><tr><td align="left">9</td><td align="left">[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM key member member …]</a> 移除有序集合中的一个或多个成员</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">ZREVRANGE key start stop WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">ZREVRANGEBYSCORE key max min WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">ZUNIONSTORE destination numkeys key key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td align="left">20</td><td align="left">[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h4 id="3-应用场景-1"><a href="#3-应用场景-1" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><ul><li>实现排行榜</li></ul><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。GEO 的数据结构总共有六个命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash,这里着重讲解几个。</p><p>1.GEOADD</p><pre class="line-numbers language-none"><code class="language-none">GEOADD key longitude latitude member [longitude latitude member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。例子：</p><pre class="line-numbers language-none"><code class="language-none">GEOADD china:city 116.416 39.916 beijing 121.433 34.500 shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.GEOPOS</p><pre class="line-numbers language-none"><code class="language-none">GEOPOS key member [member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从键里面返回所有给定位置元素的位置（经度和纬度），例子：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; GEOPOS china:city beijing1) 1) &quot;116.41600102186203003&quot;   2) &quot;39.91599925162866924&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.GEODIST</p><pre class="line-numbers language-none"><code class="language-none">GEODIST key member1 member2 [m|km|ft|mi]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。指定单位的参数 unit 必须是以下单位的其中一个：（默认为m）</p><blockquote><p>m  表示单位为米。<br>km 表示单位为千米。<br>mi 表示单位为英里。<br>ft 表示单位为英尺。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km&quot;748.3058&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.GEORADIUS</p><pre class="line-numbers language-none"><code class="language-none">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。距离单位和上面的一致，其中后面的选项：</p><blockquote><p>WITHDIST： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致。<br>WITHCOORD： 将位置元素的经度和维度也一并返回。<br>WITHHASH： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。这个选项主要用于底层应用或者调试， 实际中的作用并不大。</p></blockquote><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1500 km withdist withcoord count 31) 1) &quot;guangzhou&quot;   2) &quot;825.2135&quot;   3) 1) &quot;113.23300212621688843&quot;      2) &quot;23.16599912261950323&quot;2) 1) &quot;xianggang&quot;   2) &quot;959.1250&quot;   3) 1) &quot;114.09999936819076538&quot;      2) &quot;22.19999914574732003&quot;3) 1) &quot;shanghai&quot;   2) &quot;1185.2226&quot;   3) 1) &quot;121.43299788236618042&quot;      2) &quot;34.49999971716130887&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><strong>什么是基数?</strong></p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><p><strong>Redis HyperLogLog 命令</strong></p><p>下表列出了 redis HyperLogLog 的基本命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">PFADD key element1 element1 …</a> 添加指定元素到 HyperLogLog 中。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">PFCOUNT key1 key2 …</a> 返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">PFMERGE destkey sourcekey1 sourcekey2 …</a> 将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p><strong>Bitmaps介绍</strong></p><ul><li>Redis提供的Bitmaps这个“数据结构”可以实现对位的操作。Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。</li><li>可以把Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在bitmaps中叫做偏移量。</li><li>单个bitmaps的最大长度是512MB，即2^32个比特位。</li><li>bitmaps的最大优势是节省存储空间。例如，在一个以自增id代表不同用户的系统中，我们只需要512MB空间就可以记录40亿用户的某个单一信息（比如，用户是否希望接收新闻邮件）。</li><li>有两种类型的位操作：一类是对特定bit位的操作，比如设置/获取某个特定比特位的值。另一类是批量bit位操作，例如在给定范围内统计为1的比特位个数。</li><li>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR以及其它位操作。</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211214152926376.png" alt="image-20211214152926376"></p><p>需要注意的是：BitMap 在 Redis 中并不是一个新的数据类型，其底层是 Redis 实现。</p><p><strong>Bitmaps使用场景</strong></p><blockquote><p>各种实时分析(Real time analytics of all kinds)。<br>存储与对象ID关联的布尔信息，要求高效且高性能(Storing space efficient but high performance boolean information associated with object IDs.)。</p></blockquote><p><strong>Bitmaps常用命令</strong><br>1.设置值</p><pre class="line-numbers language-none"><code class="language-none">setbit key offset value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>setbit命令接收两个参数，</p><p>第一个参数表示你要操作的是第几个bit位，第二个参数表示你要将这个位设为何值，可选值只有0,1两个。如果所操作的bit位超过了当前字串的长度，reids会自动增大字串长度。</p><p>2 .获取值</p><pre class="line-numbers language-none"><code class="language-none">getbit key offset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>getbit只是返回特定bit位的值。如果试图获取的bit位在当前字串长度范围外，该命令返回0。</p><p>3 .获取Bitmaps指定范围值为1的个数</p><pre class="line-numbers language-none"><code class="language-none">bitcount key [start] [end]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><p>　　</p><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p><strong>事务的工作流程</strong></p><p><img src="https://s2.loli.net/2021/12/14/anJYeP4diLWFqfI.png" alt="image-20211214145046188"></p><p><strong>定义事务的过程中，命令格式输入错误怎么办?</strong><br>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</p><p><strong>定义事务的过程中，命令执行出现错误怎么办?</strong></p><p>指命令格式正确，但是无法正确的执行。例如对list进行incr操作。Redis会将能正确运行的命令会执行，运行错误的命令不会被执行。</p><p>注意:已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</p><p><strong>Redis事务没有隔离级别的概念：</strong></p><p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p><p><strong>Redis不保证原子性：</strong></p><p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h3><p>下表列出了 redis 事务的相关命令：</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a> 取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a> 执行所有事务块内的命令。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a> 标记一个事务块的开始。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a> 取消 WATCH 命令对所有 key 的监视。</td></tr><tr><td align="left">5</td><td align="left">[WATCH key <a href="https://www.runoob.com/redis/transactions-watch.html">key …]</a> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr></tbody></table><h3 id="Redis事务实操"><a href="#Redis事务实操" class="headerlink" title="Redis事务实操"></a>Redis事务实操</h3><p><strong>正常执行</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416204151947-1999193750.png" alt="img"></p><p><strong>放弃事务</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416204558119-2028373874.png" alt="img"></p><p><strong>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416205137740-1887538258.png" alt="img"></p><p><strong>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416205714294-77806844.png" alt="img"></p><h3 id="Redis-锁"><a href="#Redis-锁" class="headerlink" title="Redis-锁"></a>Redis-锁</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p><p><strong>使用watch</strong></p><p>案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416210530600-1167641209.png" alt="img"></p><p>案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1659331-20190416211144923-1469436233.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1659331/201904/1659331-20190416211149567-1618751187.png" alt="img"></p><p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。</p><p>故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>使用setnx设置一个公共锁</p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">setnx lock-key value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p><ul><li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li></ul><p>操作完毕通过del操作释放锁</p><p><img src="https://s2.loli.net/2021/12/14/UdEKTcNo7QaVlAn.png" alt="image-20211214150404019"></p><p>注意：使用分布式锁时，要保证锁住的是同一个key。</p><h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis是Redis官方推荐的Java连接开发工具。</p><p>Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。</p><p>SpringDataRedis相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用如：SpringCache</p><h3 id="Jedis与Lettuce对比"><a href="#Jedis与Lettuce对比" class="headerlink" title="Jedis与Lettuce对比"></a><strong>Jedis与Lettuce对比</strong></h3><p>这两个都是用于提供连接Redis的客户端。</p><p>Jedis是直接连接Redis，非线程安全，在性能上，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，资源消耗阶梯式增大，连接成</p><p>本就较高了。</p><p>Lettuce的连接是基于Netty的，Netty 是一个多线程、事件驱动的 I/O 框架。连接实例可以在多个线程间共享，当多线程使用同一连接实</p><p>例时，是线程安全的。</p><h3 id="SpringBoot使用Redis"><a href="#SpringBoot使用Redis" class="headerlink" title="SpringBoot使用Redis"></a>SpringBoot使用Redis</h3><ol><li><p>导入依赖</p></li><li><p>添加配置文件</p></li><li><p>不推荐使用原生配置的RedisTemplate，推荐自定义的RedisTemplate</p></li><li><p>创建Redis的工具类，RedisUtil，方便操作</p></li></ol><h2 id="Redis依赖"><a href="#Redis依赖" class="headerlink" title="Redis依赖"></a>Redis依赖</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redis自动配置类"><a href="#Redis自动配置类" class="headerlink" title="Redis自动配置类"></a>Redis自动配置类</h2><p>我们可以在spring-boot-autoConfigure包下查看到各种自动配置类，查找到redis的自动配置类，进入RedisAutoConfiguration，查看源码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>    proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisOperations</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">LettuceConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">JedisConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RedisAutoConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>        name <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"redisTemplate"</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span> <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">StringRedisTemplate</span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常使用StringRedisTemplate，StringRedisTemplate是RedisTemplate的子类，功能更多。</p><h2 id="自定义的RedisTemplate"><a href="#自定义的RedisTemplate" class="headerlink" title="自定义的RedisTemplate"></a>自定义的RedisTemplate</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">myRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> factory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnknownHostException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Json序列化配置</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectMapper</span> om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);方法过期，不建议使用</span>        om<span class="token punctuation">.</span><span class="token function">activateDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">LaissezFaireSubTypeValidator</span><span class="token punctuation">.</span>instance<span class="token punctuation">,</span> <span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">,</span> <span class="token class-name">JsonTypeInfo<span class="token punctuation">.</span>As</span><span class="token punctuation">.</span>PROPERTY<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// String 的序列化</span>        <span class="token class-name">StringRedisSerializer</span> stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// key采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// hash的key也采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// hash的value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="RedisUtil"><a href="#RedisUtil" class="headerlink" title="RedisUtil"></a>RedisUtil</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.example.util;import java.io.Serializable;import java.util.concurrent.TimeUnit;import javax.annotation.Resource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;@Componentpublic class RedisUtil &#123;    private static final Logger logger &#x3D; LoggerFactory.getLogger(RedisUtil.class);    @Resource    private RedisTemplate&lt;Serializable, Serializable&gt; redisTemplate;    &#x2F;**     * 前缀     *&#x2F;    public static final String KEY_PREFIX_VALUE &#x3D; &quot;itstyle:seckill:value:&quot;;    &#x2F;**     * 缓存value操作     *     * @param k     * @param v     * @param time     * @return     *&#x2F;    public boolean cacheValue(String k, Serializable v, long time) &#123;        String key &#x3D; KEY_PREFIX_VALUE + k;        try &#123;            ValueOperations&lt;Serializable, Serializable&gt; valueOps &#x3D; redisTemplate.opsForValue();            valueOps.set(key, v);            &#x2F;&#x2F;redisTemplate.opsForValue().set(key, v);            if (time &gt; 0) redisTemplate.expire(key, time, TimeUnit.SECONDS); &#x2F;&#x2F;设置过期时间            return true;        &#125; catch (Throwable t) &#123;            logger.error(&quot;缓存[&#123;&#125;]失败, value[&#123;&#125;]&quot;, key, v, t);        &#125;        return false;    &#125;    &#x2F;**     * 缓存value操作     *     * @param k     * @param v     * @param time     * @param unit     * @return boolean     *&#x2F;    public boolean cacheValue(String k, Serializable v, long time, TimeUnit unit) &#123;        String key &#x3D; KEY_PREFIX_VALUE + k;        try &#123;            ValueOperations&lt;Serializable, Serializable&gt; valueOps &#x3D; redisTemplate.opsForValue();            valueOps.set(key, v);            if (time &gt; 0) redisTemplate.expire(key, time, unit);            return true;        &#125; catch (Throwable t) &#123;            logger.error(&quot;缓存[&#123;&#125;]失败, value[&#123;&#125;]&quot;, key, v, t);        &#125;        return false;    &#125;    &#x2F;**     * 缓存value操作     *     * @param k     * @param v     * @return     *&#x2F;    public boolean cacheValue(String k, Serializable v) &#123;        &#x2F;&#x2F;-1表示不设置过期时间        return cacheValue(k, v, -1);    &#125;    &#x2F;**     * 判断缓存是否存在     *     * @param k     * @return     *&#x2F;    public boolean containsValueKey(String k) &#123;        String key &#x3D; KEY_PREFIX_VALUE + k;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Throwable t) &#123;            logger.error(&quot;判断缓存存在失败key[&quot; + key + &quot;, error[&quot; + t + &quot;]&quot;);        &#125;        return false;    &#125;    &#x2F;**     * 获取缓存     *     * @param k     * @return     *&#x2F;    public Serializable getValue(String k) &#123;        try &#123;            ValueOperations&lt;Serializable, Serializable&gt; valueOps &#x3D; redisTemplate.opsForValue();            return valueOps.get(KEY_PREFIX_VALUE + k);        &#125; catch (Throwable t) &#123;            logger.error(&quot;获取缓存失败key[&quot; + KEY_PREFIX_VALUE + k + &quot;, error[&quot; + t + &quot;]&quot;);        &#125;        return null;    &#125;    &#x2F;**     * 移除缓存     *     * @param k     * @return     *&#x2F;    public boolean removeValue(String k) &#123;        String key &#x3D; KEY_PREFIX_VALUE + k;        try &#123;            redisTemplate.delete(key);            return true;        &#125; catch (Throwable t) &#123;            logger.error(&quot;获取缓存失败key[&quot; + key + &quot;, error[&quot; + t + &quot;]&quot;);        &#125;        return false;    &#125;    &#x2F;**     * 递增     *     * @param k     * @param delta 要增加几(大于0)     * @return     *&#x2F;    public long incr(String k, long delta) &#123;        String key &#x3D; KEY_PREFIX_VALUE + k;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    &#x2F;**     * 递减     *     * @param k     键     * @param delta 要减少几(小于0)     * @return     *&#x2F;    public long decr(String k, long delta) &#123;        String key &#x3D; KEY_PREFIX_VALUE + k;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有更全的Redis工具类，来自网络：<a href="https://blog.csdn.net/tom5982160/article/details/83509023">https://blog.csdn.net/tom5982160/article/details/83509023</a></p><h1 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h1><h2 id="redis-conf-配置项说明如下："><a href="#redis-conf-配置项说明如下：" class="headerlink" title="redis.conf 配置项说明如下："></a>redis.conf 配置项说明如下：</h2><table><thead><tr><th align="left">序号</th><th align="center">配置项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="center"><code>daemonize no</code></td><td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="left">2</td><td align="center"><code>pidfile /var/run/redis.pid</code></td><td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="left">3</td><td align="center"><code>port 6379</code></td><td align="left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td align="left">4</td><td align="center"><code>bind 127.0.0.1</code></td><td align="left">绑定的主机地址</td></tr><tr><td align="left">5</td><td align="center"><code>timeout 300</code></td><td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td align="left">6</td><td align="center"><code>loglevel notice</code></td><td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="left">7</td><td align="center"><code>logfile 路径名（‘’表示控制台输出）</code></td><td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td align="left">8</td><td align="center"><code>databases 16</code></td><td align="left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td align="left">9</td><td align="center"><code>save 900 1</code> <br /><code>save 300 10</code> <br /><code>save 60 10000</code></td><td align="left">快照配置<br />注释掉“save”这一行配置项就可以让保存数据库功能失效<br />设置sedis进行数据库镜像的频率。  <br />900秒（15分钟）内至少1个key值改变（则进行数据库保存–持久化）   <br />300秒（5分钟）内至少10个key值改变（则进行数据库保存–持久化）  <br />60秒（1分钟）内至少10000个key值改变（则进行数据库保存–持久化）</td></tr><tr><td align="left">10</td><td align="center"><code>rdbcompression yes</code></td><td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="left">11</td><td align="center"><code>dbfilename dump.rdb</code></td><td align="left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="left">12</td><td align="center"><code>dir ./</code></td><td align="left">指定本地数据库存放目录</td></tr><tr><td align="left">13</td><td align="center"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td align="left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td align="left">14</td><td align="center"><code>masterauth &lt;master-password&gt;</code></td><td align="left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td align="left">15</td><td align="center"><code>requirepass psw</code></td><td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td></tr><tr><td align="left">16</td><td align="center"><code> maxclients 128</code></td><td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="left">17</td><td align="center"><code>maxmemory &lt;bytes&gt;</code></td><td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td align="left">18</td><td align="center"><code>appendonly no</code></td><td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="left">19</td><td align="center"><code>appendfilename appendonly.aof</code></td><td align="left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="left">20</td><td align="center"><code>appendfsync everysec</code></td><td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="left">21</td><td align="center"><code>vm-enabled no</code></td><td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td align="left">22</td><td align="center"><code>vm-swap-file /tmp/redis.swap</code></td><td align="left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="left">23</td><td align="center"><code>vm-max-memory 0</code></td><td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="left">24</td><td align="center"><code>vm-page-size 32</code></td><td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="left">25</td><td align="center"><code>vm-pages 134217728</code></td><td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="left">26</td><td align="center"><code>vm-max-threads 4</code></td><td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td align="left">27</td><td align="center"><code>glueoutputbuf yes</code></td><td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td align="left">28</td><td align="center"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td><td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td align="left">29</td><td align="center"><code>activerehashing yes</code></td><td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td align="left">30</td><td align="center"><code>include /path/to/local.conf</code></td><td align="left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr><tr><td align="left">31</td><td align="center"><code>stop-writes-on-bgsave-error yes</code></td><td align="left">当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no</td></tr></tbody></table><p><a href="https://blog.csdn.net/WYA1993/article/details/83096088">redis.conf</a></p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="什么是Redis持久化"><a href="#什么是Redis持久化" class="headerlink" title="什么是Redis持久化?"></a>什么是Redis持久化?</h2><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，如下所示：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java5-1566526018.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p><strong>这样做有什么问题呢？</strong></p><p>其实，只要稍微有点计算机基础知识的人都知道，存储在内存当中的数据，只要服务器关机(各种原因引起的)，内存中的数据就会消失了，不仅服务器关机会造成数据消失，Redis服务器守护进程退出，内存中的数据也一样会消失。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java1-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p>对于只把Redis当缓存来用的项目来说，数据消失或许问题不大，重新从数据源把数据加载进来就可以了，但如果直接把用户提交的业务数据存储在Redis当中，把Redis作为数据库来使用，在其放存储重要业务数据，那么Redis的内存数据丢失所造成的影响也许是毁灭性。</p><p>为了避免内存中数据丢失，Redis提供了对持久化的支持，我们可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java3-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p>Redis提供了RDB和AOF两种不同的数据持久化方式，下面我们就来详细介绍一下这种不同的持久化方式吧。</p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>了解RDB，先了解什么是快照。</p><p>快照技术主要是在操作系统以及存储技术上实现的一种记录某一时间系统状态的技术。近来，Oracle等数据库厂家以及Vmware等虚拟化产品也把这种技术引入各自的数据保护当中。</p><p><a href="https://zhuanlan.zhihu.com/p/21749155">https://zhuanlan.zhihu.com/p/21749155</a></p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><h3 id="开启RDB持久化方式"><a href="#开启RDB持久化方式" class="headerlink" title="开启RDB持久化方式"></a>开启RDB持久化方式</h3><p>开启RDB持久化方式很简单，客户端可以通过向Redis服务器发送save或bgsave命令让服务器生成rdb文件，或者通过服务器配置文件指定触发RDB条件。</p><h4 id="1-save命令"><a href="#1-save命令" class="headerlink" title="1. save命令"></a>1. save命令</h4><p>save命令是一个同步操作。</p><pre class="line-numbers language-none"><code class="language-none"># 同步数据到磁盘上&gt; save <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java4-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p>当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。</p><p>如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令。</p><h4 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h4><p>与save命令不同，bgsave命令是一个异步操作。</p><pre class="line-numbers language-none"><code class="language-none"># 异步保存数据集到磁盘上&gt; bgsave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java5-1566526019.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p>当客户端发服务发出bgsave命令时，Redis服务器主进程会forks一个子进程来数据同步问题，在将数据保存到rdb文件之后，子进程会退出。</p><p>所以，与save命令相比，Redis服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。</p><h4 id="3-服务器配置自动触发"><a href="#3-服务器配置自动触发" class="headerlink" title="3. 服务器配置自动触发"></a>3. 服务器配置自动触发</h4><p>除了通过客户端发送命令外，还有一种方式，就是在Redis配置文件中的save指定到达触发RDB持久化的条件，比如【多少秒内至少达到多少写操作】就开启RDB数据同步。</p><p>例如我们可以在配置文件redis.conf指定如下的选项：</p><pre class="line-numbers language-none"><code class="language-none"># 900s内至少达到一条写命令save 900 1# 300s内至少达至10条写命令save 300 10# 60s内至少达到10000条写命令save 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后在启动服务器时加载配置文件。</p><pre class="line-numbers language-none"><code class="language-none"># 启动服务器加载配置文件redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</p><h3 id="rdb文件"><a href="#rdb文件" class="headerlink" title="rdb文件"></a>rdb文件</h3><p>前面介绍了三种让服务器生成rdb文件的方式，无论是由主进程生成还是子进程来生成，其过程如下：</p><ul><li>生成临时rdb文件，并写入数据。</li><li>完成数据写入，用临时文代替代正式rdb文件。</li><li>删除原来的db文件。</li></ul><p>RDB默认生成的文件名为dump.rdb，当然，我可以通过配置文件进行更加详细配置，比如在单机下启动多个redis服务器进程时，可以通过端口号配置不同的rdb名称，如下所示：</p><pre class="line-numbers language-none"><code class="language-none"># 是否压缩rdb文件rdbcompression yes# rdb文件的名称dbfilename redis-6379.rdb# rdb文件保存目录dir ~&#x2F;redis&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RDB的几个优点</strong></p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul><p><strong>RDB的几个缺点</strong></p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Redis的另外一个持久化方式：AOF(Append-only file)。</p><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java9-1566526020.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p><strong>开启AOF持久化方式</strong></p><p>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：</p><pre class="line-numbers language-none"><code class="language-none"># 开启aof机制appendonly yes# aof文件名appendfilename &quot;appendonly.aof&quot;# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或noappendfsync always# 默认不重写aof文件no-appendfsync-on-rewrite no# 保存目录dir ~&#x2F;redis&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>三种写入策略</strong></p><p>在上面的配置文件中，我们可以通过appendfsync选项指定写入策略,有三个选项</p><pre class="line-numbers language-none"><code class="language-none">appendfsync always# appendfsync everysec# appendfsync no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-always"><a href="#1-always" class="headerlink" title="1. always"></a>1. always</h4><p>客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</p><h4 id="2-everysec"><a href="#2-everysec" class="headerlink" title="2. everysec"></a>2. everysec</h4><p>appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。</p><h4 id="3-no"><a href="#3-no" class="headerlink" title="3. no"></a>3. no</h4><p>Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。</p><pre class="line-numbers language-none"><code class="language-none">incr num 1incr num 2incr num 3incr num 4incr num 5incr num 6...incr num 100000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：</p><pre class="line-numbers language-none"><code class="language-none">set num 100000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。</p><h3 id="两种重写方式"><a href="#两种重写方式" class="headerlink" title="两种重写方式"></a>两种重写方式</h3><p>通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。</p><pre class="line-numbers language-none"><code class="language-none"># 默认不重写aof文件no-appendfsync-on-rewrite no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 让服务器异步重写追加aof文件命令</span><span class="token operator">></span> bgrewriteaof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理，如下所示：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/java10-1566526020.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p>重写aof文件的好处</p><ul><li>压缩aof文件，减少磁盘占用量。</li><li>将aof的命令压缩为最小命令集，加快了数据恢复的速度。</li></ul><h3 id="AOF文件损坏"><a href="#AOF文件损坏" class="headerlink" title="AOF文件损坏"></a>AOF文件损坏</h3><p>在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。</p><p>1、备份现在aof文件，以防万一。</p><p>2、使用redis-check-aof命令修复aof文件，该命令格式如下：</p><pre class="line-numbers language-none"><code class="language-none"># 修复aof日志文件$ redis-check-aof -fix file.aof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3、重启Redis服务器，加载已经修复的aof文件，恢复数据。</p><h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul><li>AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li></ul><h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul><li>AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。</li><li>恢复数据的速度比RDB慢。</li></ul><hr><h2 id="选择RDB还是AOF呢？"><a href="#选择RDB还是AOF呢？" class="headerlink" title="选择RDB还是AOF呢？"></a>选择RDB还是AOF呢？</h2><p>通过上面的介绍，我们了解了RDB与AOF各自的优点与缺点，到底要如何选择呢？</p><p>通过下面的表示，我们可以从几个方面对比一下RDB与AOF,在应用时，要根本自己的实际需求，选择RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行IO操作，会严重影响服务器性能，因此有时候不得不做出选择。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/08/java10-1566526020-1.jpeg" alt="10分钟彻底理解Redis的持久化机制：RDB和AOF"></p><p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="单机一主两从实现"><a href="#单机一主两从实现" class="headerlink" title="单机一主两从实现"></a>单机一主两从实现</h2><ol><li>复制三份相同的配置文件</li><li>对配置文件进行修改，修改端口，修改rdb文件，修改日志文件的位置</li><li>根据对应的配置文件启动相应的redis服务器（单机情况下，一个端口对应一个服务）</li></ol><p>如何解决一主多从的情况下主机或从机挂掉，通过集群解决。</p><p>主从配置可以通过命令配置，也可以通过配置文件进行主从配置，配置文件时永久配置，命令行配置是暂时的，redis服务重新启动后，需要再次配置。</p><p>主机断开连接，从机使用<code>slaveof  no  one</code>命令是自己变成主机，其他节点再手动连接到这个主节点。当主机重新连接后，需要将从机重新连接到主机。</p><h2 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave),数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><p>Redis的Master和Slave并没有特别不同的地方，Slave也可以拥有自己的Slave，并由此形成主从链。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/907596-20180710175627988-299575978.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210411160437949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2MjY0MDA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><ol><li><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p></li><li><p>容灾快速恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p></li><li><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p></li><li><p>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</p></li><li><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p></li></ol><h2 id="Redis主从复制的问题"><a href="#Redis主从复制的问题" class="headerlink" title="Redis主从复制的问题"></a>Redis主从复制的问题</h2><ol><li><p>一旦 主节点宕机，从节点 晋升成 主节点，同时需要修改 应用方 的 主节点地址，还需要命令所有 从节点 去 复制 新的主节点，整个过程需要 人工干预。</p></li><li><p>主节点 的 写能力 受到 单机的限制。</p></li><li><p>主节点 的 存储能力 受到 单机的限制。</p></li><li><p>原生复制 的弊端在早期的版本中也会比较突出，比如：Redis 复制中断 后，从节点 会发起 <code>psync</code>。此时如果 同步不成功，则会进行 全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</p></li></ol><h2 id="Redis的全量同步和增量同步"><a href="#Redis的全量同步和增量同步" class="headerlink" title="Redis的全量同步和增量同步"></a>Redis的全量同步和增量同步</h2><ul><li>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br>　　1）从服务器连接主服务器，发送SYNC命令；<br>  　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>  　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>  　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>  　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>  　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ul><p>　　完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p><ul><li><p>增量同步<br>　　Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p></li><li><p>Redis主从同步策略<br>　　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p></li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis 的 主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，当主节点恢复连接后需要重新通知从节点更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制 来解决这个问题。</p><h3 id="Redis-Sentinel的主要功能"><a href="#Redis-Sentinel的主要功能" class="headerlink" title="Redis Sentinel的主要功能"></a>Redis Sentinel的主要功能</h3><p><code>Sentinel</code> 的主要功能包括 <strong>主节点存活检测</strong>、<strong>主从运行情况检测</strong>、<strong>自动故障转移</strong> （<code>failover</code>）、<strong>主从切换</strong>。<code>Redis</code> 的 <code>Sentinel</code> 最小配置是 <strong>一主一从</strong>。</p><p><code>Redis</code> 的 <code>Sentinel</code> 系统可以用来管理多个 <code>Redis</code> 服务器，该系统可以执行以下四个任务：</p><ul><li><strong>监控</strong></li></ul><p><code>Sentinel</code> 会不断的检查 <strong>主服务器</strong> 和 <strong>从服务器</strong> 是否正常运行。</p><ul><li><strong>通知</strong></li></ul><p>当被监控的某个 <code>Redis</code> 服务器出现问题，<code>Sentinel</code> 通过 <code>API</code> <strong>脚本</strong> 向 <strong>管理员</strong> 或者其他的 <strong>应用程序</strong> 发送通知。</p><ul><li><strong>自动故障转移</strong></li></ul><p>当 <strong>主节点</strong> 不能正常工作时，<code>Sentinel</code> 会开始一次 <strong>自动的</strong> 故障转移操作，它会将与 <strong>失效主节点</strong> 是 <strong>主从关系</strong> 的其中一个 <strong>从节点</strong> 升级为新的 <strong>主节点</strong>，并且将其他的 <strong>从节点</strong> 指向 <strong>新的主节点</strong>，主节点恢复正常工作后，成为从节点，指向新的主节点。</p><ul><li><strong>配置提供者</strong></li></ul><p>在 <code>Redis Sentinel</code> 模式下，<strong>客户端应用</strong> 在初始化时连接的是 <code>Sentinel</code> <strong>节点集合</strong>，从中获取 <strong>主节点</strong> 的信息。</p><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p><ul><li><strong>主观下线</strong></li></ul><p><strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</p><ul><li><strong>客观下线</strong></li></ul><p><strong>客观下线</strong> 只适用于 <strong>主节点</strong>。如果 <strong>主节点</strong> 出现故障，<code>Sentinel</code> 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。如果超过 <code>&lt;quorum&gt;</code> 个数的节点判定 <strong>主节点</strong> 不可达，则该 <code>Sentinel</code> 节点会判断 <strong>主节点</strong> 为 <strong>客观下线</strong>。</p><p><strong>详细博客连接</strong></p><p>作者：零壹技术栈<br>链接：<a href="https://juejin.cn/post/6844903663362637832">https://juejin.cn/post/6844903663362637832</a></p><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当查询Redis中没有的数据时，该查询会下沉到数据库层，同时数据库层也没有该数据，当这种情况大量出现或被恶意攻击时，接口的访</p><p>问全部透过Redis访问数据库，而数据库中也没有这些数据，我们称这种现象为”缓存穿透”。缓存穿透会穿透Redis的保护，提升底层数据</p><p>库的负载压力，同时这类穿透查询没有数据返回也造成了网络和计算资源的浪费。</p><p><img src="https://s2.loli.net/2021/12/14/WOfAPsCaLb1JQ7k.png" alt="image-20210421210139942"></p><p><strong>解决方案：</strong></p><ul><li>在接口访问层对用户做校验，如接口传参、登陆状态、n秒内访问接口的次数；</li><li>利用布隆过滤器，将数据库层有的数据key存储在位数组中，以判断访问的key在底层数据库中是否存在；</li></ul><p>第一种解决方案很好理解，这里介绍一下第二种方案，在前一篇文章中我们介绍了Redis的布隆过滤器，我们知道布隆过滤器可以判断key一定不在集合内以及key极有可能在集合内。</p><p>基于布隆过滤器，我们可以先将数据库中数据的key存储在布隆过滤器的位数组中，每次客户端查询数据时先访问Redis：</p><ul><li>如果Redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内；</li><li>如果布隆过滤器告诉我们该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作；</li><li>如果布隆过滤器告诉我们该key极有可能在底层数据库内存在，那么将查询下推到底层数据库即可；</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210547359.png" alt="image-20210421210547359"></p><p>布隆过滤器有误判率，虽然不能完全避免数据穿透的现象，但已经可以将99.99%的穿透查询给屏蔽在Redis层了，极大的降低了底层数据库的压力，减少了资源浪费。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a><strong>什么是布隆过滤器</strong></h3><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p><a href="https://www.cnblogs.com/ysocean/p/12594982.html"> Redis布隆过滤器</a></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存穿透从名词上可能很难区分开来，它们的区别是：穿透表示底层数据库没有数据且缓存内也没有数据，击穿表示底层数据</p><p>库有数据而缓存内没有数据。当热点数据key从缓存内失效时，大量访问同时请求这个数据，就会将查询下沉到数据库层，此时数据库层</p><p>的负载压力会骤增，我们称这种现象为”缓存击穿”。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210107128.png" alt="image-20210421210107128"></p><p>解决方案：</p><ul><li><p>延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口；</p></li><li><p>利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时</p><p>穿过Redis访问底层数据库；</p></li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210528642.png" alt="image-20210421210528642"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是缓存击穿的”大面积”版，缓存击穿是数据库缓存到Redis内的热点数据失效导致大量并发查询穿过redis直接击打到底层数据</p><p>库，而缓存雪崩是指Redis中大量的key几乎同时过期，然后大量并发查询穿过redis击打到底层数据库上，此时数据库层的负载压力会骤</p><p>增，我们称这种现象为”缓存雪崩”。例如微博的热搜。事实上缓存雪崩相比于缓存击穿更容易发生，对于大多数公司来讲，同时超大并发</p><p>量访问同一个过时key的场景的确太少见了，而大量key同时过期，大量用户访问这些key的几率相比缓存击穿来说明显更大。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210358622.png" alt="image-20210421210358622"></p><p><strong>解决方案：</strong></p><ul><li>在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期；</li><li>对于一定要在固定时间让key失效的场景(例如每日12点准时更新所有最新排名)，可以在固定的失效时间时在接口服务端设置随机延时，将请求的时间打散，让一部分查询先将数据缓存起来；</li><li>延长热点key的过期时间或者设置永不过期，这一点和缓存击穿中的方案一样；</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210637280.png" alt="image-20210421210637280"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20210421210648811.png" alt="image-20210421210648811"></p><p>相关博客地址：<a href="https://cloud.tencent.com/developer/article/1666384">https://cloud.tencent.com/developer/article/1666384</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢红包实战案例</title>
      <link href="/2021/12/13/hong-bao/"/>
      <url>/2021/12/13/hong-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="微信抢红包实战案例"><a href="#微信抢红包实战案例" class="headerlink" title="微信抢红包实战案例"></a>微信抢红包实战案例</h1><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p><a href="https://blog.52itstyle.vip/usr/uploads/2020/02/1820591650.png"><img src="https://blog.52itstyle.vip/usr/uploads/2020/02/1820591650.png" alt="img"></a></p><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><ul><li>老板发红包，此时缓存初始化红包个数，红包金额(单位分)，并异步入库。</li><li>抢红包，判断缓存剩余红包金额，剩余金额大于零则抢到红包，否则手慢了，红包派完了</li><li>拆红包，根据 <code>redPacketId</code> 获取分布式锁，如果获取到锁，红包个数减一，如果剩余红包个数大于零抢红包成功、否则失败。成功则计算红包金额，缓存总红包金额减去抢到的红包金额，异步入库、异步到账。</li></ul><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><ul><li>红包信息表</li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;red_racket&#96; (   &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,   &#96;red_packet_id&#96; bigint(20) NOT NULL COMMENT &#39;红包唯一ID&#39;,   &#96;total_amount&#96; int(11) NOT NULL COMMENT &#39;红包金额单位分&#39;,   &#96;total_packet&#96; int(11) NOT NULL COMMENT &#39;红包个数&#39;,   &#96;type&#96; int(11) NOT NULL COMMENT &#39;红包类型&#39;,   &#96;create_time&#96; datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,   &#96;version&#96; int(11) NOT NULL COMMENT &#39;版本号&#39;,   PRIMARY KEY (&#96;id&#96;) ) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8 CHECKSUM&#x3D;1 DELAY_KEY_WRITE&#x3D;1 ROW_FORMAT&#x3D;DYNAMIC COMMENT&#x3D;&#39;红包信息表&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>抢红包记录表</li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;red_packet_record&#96; (   &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,   &#96;amount&#96; int(11) NOT NULL COMMENT &#39;抢到红包的金额&#39;,   &#96;red_packet_id&#96; bigint(20) NOT NULL COMMENT &#39;红包ID&#39;,   &#96;uid&#96; int(11) NOT NULL COMMENT &#39;抢到红包用户的用户标识&#39;,   &#96;create_time&#96; datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,   PRIMARY KEY (&#96;id&#96;) ) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;10 DEFAULT CHARSET&#x3D;utf8 CHECKSUM&#x3D;1 DELAY_KEY_WRITE&#x3D;1 ROW_FORMAT&#x3D;DYNAMIC COMMENT&#x3D;&#39;抢红包记录表&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>老板发了10个红包一共200人民币，100个人同时抢红包，伪代码分别为拆红包和抢红包相关业务逻辑。</p><p>模拟抢红包伪代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   <span class="token comment">/** * 抢红包 拆红包 抢到不一定能拆到 * 建议使用抢红包二的方式 * * @param redPacketId * @param userId * @return */</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/start"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">long</span> redPacketId<span class="token punctuation">,</span> <span class="token keyword">long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 判断用户是否多次参与枪红包，记录中存在，直接返回记录     */</span>    <span class="token comment">/**     * 抢红包 判断剩余金额     */</span>    <span class="token class-name">Integer</span> money <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>redPacketId <span class="token operator">+</span> <span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 虽然能抢到 但是不一定能拆到         * 类似于微信的 点击红包显示抢的按钮         * 没有就直接显示无         */</span>        <span class="token class-name">Result</span> result <span class="token operator">=</span> redPacketService<span class="token punctuation">.</span><span class="token function">startTwoSeckil</span><span class="token punctuation">(</span>redPacketId<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"500"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"用户&#123;&#125;手慢了，红包派完了"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Double</span> amount <span class="token operator">=</span> <span class="token class-name">DoubleUtil</span><span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"用户&#123;&#125;抢红包成功，金额：&#123;&#125;"</span><span class="token punctuation">,</span> userId<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 直接显示手慢了，红包派完了         */</span>        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"用户&#123;&#125;手慢了，红包派完了"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>业务层拆红包：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">startTwoSeckil</span><span class="token punctuation">(</span><span class="token keyword">long</span> redPacketId<span class="token punctuation">,</span> <span class="token keyword">int</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Integer</span> money <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> res<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 获取锁 保证红包数量和计算红包金额的原子性操作         */</span>        res <span class="token operator">=</span> <span class="token class-name">RedissLockUtil</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">long</span> restPeople <span class="token operator">=</span> redisUtil<span class="token punctuation">.</span><span class="token function">decr</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-num"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>restPeople<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">/**                 * 如果是最后一人                 */</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>restPeople<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    money <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token class-name">Integer</span> restMoney <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//随机范围：[1,剩余人均金额的两倍]</span>                    money <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>restMoney <span class="token operator">/</span> <span class="token punctuation">(</span>restPeople<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                redisUtil<span class="token punctuation">.</span><span class="token function">decr</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-money"</span><span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/**                 * 异步入库                 */</span>                <span class="token class-name">RedPacketRecord</span> <span class="token keyword">record</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedPacketRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">setRedPacketId</span><span class="token punctuation">(</span>redPacketId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">setUid</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Timestamp</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">saveRecord</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/**                 * 异步入账                 */</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"手慢了，红包派完了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token comment">/**             * 获取锁失败相当于抢红包失败             */</span>             <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"手慢了，红包派完了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//释放锁</span>            <span class="token class-name">RedissLockUtil</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Before</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RestTemplate</span> restTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化红包，redPacketId=100，红包金额100，十人份</span>    <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8080/init?redPacketId=100&amp;number=100&amp;count=10"</span><span class="token punctuation">;</span>    <span class="token class-name">Result</span> result <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 测试start */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RestTemplate</span> restTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//模拟一百个人抢红包</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> userId <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token comment">//String url = "http://localhost:80/start?redPacketId=100&amp;userId=" + userId;</span>            <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8080/start?redPacketId=100&amp;userId="</span> <span class="token operator">+</span> userId<span class="token punctuation">;</span>            restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> restMoney <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">+</span> <span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"剩余金额：&#123;&#125;"</span><span class="token punctuation">,</span> restMoney<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上方案并没有实现持久化和分布式，生产环境可根据实际业务需求选择使用。</p><h1 id="微信抢红包过期失效实战案例"><a href="#微信抢红包过期失效实战案例" class="headerlink" title="微信抢红包过期失效实战案例"></a>微信抢红包过期失效实战案例</h1><p>微信红包业务，发红包之后如果24小时之内没有被领取完就自动过期失效。</p><h2 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h2><p><a href="https://blog.52itstyle.vip/usr/uploads/2020/02/3201701350.png"><img src="https://gitee.com/kisstt/typora/raw/master/images/3201701350.png" alt="img"></a></p><h2 id="业务流程-1"><a href="#业务流程-1" class="headerlink" title="业务流程"></a>业务流程</h2><ul><li>老板发红包，此时缓存初始化红包个数，红包金额(单位分)，并异步入库。</li><li>红包数据入延迟队列，唯一标识+失效时间</li><li>红包数据出延迟队列，根据唯一标识清空红包缓存数据、异步更新数据库、异步退回红包金额</li></ul><h2 id="代码案例-1"><a href="#代码案例-1" class="headerlink" title="代码案例"></a>代码案例</h2><p>这里我们使用<code>Java</code>内置的<code>DelayQueue</code>来实现，<code>DelayQueue</code>是一个无界的<code>BlockingQueue</code>，用于放置实现了<code>Delayed</code>接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。</p><p>老板发了10个红包一共200人民币，假装只有9个人抢红包。</p><p>发红包，红包初始化时，缓存数据进入延迟队列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token comment">/** * 初始化红包 * * @param redPacketId * @param number * @param count * @return */</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/init"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">long</span> redPacketId<span class="token punctuation">,</span> <span class="token keyword">int</span> number<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//这里红包Id没有用UUID</span>    <span class="token class-name">Result</span> result <span class="token operator">=</span> redPacketService<span class="token punctuation">.</span><span class="token function">redPacketInit</span><span class="token punctuation">(</span>redPacketId<span class="token punctuation">,</span> number<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 加入延迟队列 24s秒过期     * RedPacketMessage message = new RedPacketMessage(redPacketId, 24);     * RedPacketQueue.getQueue().produce(message);     */</span>    <span class="token class-name">RedPacketMessage</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedPacketMessage</span><span class="token punctuation">(</span>redPacketId<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">RedPacketQueue</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红包队列消息：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 红包队列消息 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedPacketMessage</span> <span class="token keyword">implements</span> <span class="token class-name">Delayed</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">DateTimeFormatter</span> <span class="token class-name">F</span> <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 默认延迟3秒     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> DELAY_MS <span class="token operator">=</span> <span class="token number">1000L</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 红包 ID     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> redPacketId<span class="token punctuation">;</span>    <span class="token comment">/**     * 创建时间戳     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp<span class="token punctuation">;</span>    <span class="token comment">/**     * 过期时间     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> expire<span class="token punctuation">;</span>    <span class="token comment">/**     * 描述信息     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> description<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RedPacketMessage</span><span class="token punctuation">(</span><span class="token keyword">long</span> redPacketId<span class="token punctuation">,</span> <span class="token keyword">long</span> expireSeconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>redPacketId <span class="token operator">=</span> redPacketId<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expire <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">+</span> expireSeconds <span class="token operator">*</span> <span class="token number">1000L</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>description <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"红包[%s]-创建时间为:%s,超时时间为:%s"</span><span class="token punctuation">,</span> redPacketId<span class="token punctuation">,</span>                <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">F</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>expire<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">F</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">RedPacketMessage</span><span class="token punctuation">(</span><span class="token keyword">long</span> redPacketId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>redPacketId <span class="token operator">=</span> redPacketId<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>expire <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">+</span> DELAY_MS<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>description <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"红包[%s]-创建时间为:%s,超时时间为:%s"</span><span class="token punctuation">,</span> redPacketId<span class="token punctuation">,</span>                <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">F</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">ofEpochMilli</span><span class="token punctuation">(</span>expire<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">F</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getRedPacketId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> redPacketId<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> timestamp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> expire<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> description<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>expire <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Delayed</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红包延迟队列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 红包延迟队列 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedPacketQueue</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 用于多线程间下单的队列 */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">DelayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedPacketMessage</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 私有的默认构造子，保证外界无法直接实例化     */</span>    <span class="token keyword">private</span> <span class="token class-name">RedPacketQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例     * 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 静态初始化器，由JVM来保证线程安全         */</span>        <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token class-name">RedPacketQueue</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedPacketQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//单例队列</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">RedPacketQueue</span> <span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>queue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 生产入队     * 1、执行加锁操作     * 2、把元素添加到优先级队列中     * 3、查看元素是否为队首     * 4、如果是队首的话，设置leader为空，唤醒所有等待的队列     * 5、释放锁     */</span>    <span class="token keyword">public</span>  <span class="token class-name">Boolean</span>  <span class="token function">produce</span><span class="token punctuation">(</span><span class="token class-name">RedPacketMessage</span> message<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 消费出队     * 1、执行加锁操作     * 2、取出优先级队列元素q的队首     * 3、如果元素q的队首/队列为空,阻塞请求     * 4、如果元素q的队首(first)不为空,获得这个元素的delay时间值     * 5、如果first的延迟delay时间值为0的话,说明该元素已经到了可以使用的时间,调用poll方法弹出该元素,跳出方法     * 6、如果first的延迟delay时间值不为0的话,释放元素first的引用,避免内存泄露     * 7、判断leader元素是否为空,不为空的话阻塞当前线程     * 8、如果leader元素为空的话,把当前线程赋值给leader元素,然后阻塞delay的时间,即等待队首到达可以出队的时间,在finally块中释放leader元素的引用     * 9、循环执行从1~8的步骤     * 10、如果leader为空并且优先级队列不为空的情况下(判断还有没有其他后续节点),调用signal通知其他的线程     * 11、执行解锁操作     */</span>    <span class="token keyword">public</span>  <span class="token class-name">RedPacketMessage</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红包延迟队列过期消费，监听任务：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 红包延迟队列过期消费 */</span><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"redPacket"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskRunner</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationRunner</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Logger</span> LOGGER <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">TaskRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisUtil</span> redisUtil<span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span>r <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"RedPacketDelayWorker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ApplicationArguments</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">RedPacketMessage</span> message <span class="token operator">=</span> <span class="token class-name">RedPacketQueue</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>message<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">long</span> redPacketId <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getRedPacketId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"红包&#123;&#125;过期了"</span><span class="token punctuation">,</span>redPacketId<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">/**                         * 获取剩余红包个数以及金额                         */</span>                        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> restMoney <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"剩余红包个数&#123;&#125;，剩余红包金额&#123;&#125;"</span><span class="token punctuation">,</span>num<span class="token punctuation">,</span>restMoney<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">/**                         * 清空红包数据                         */</span>                        redisUtil<span class="token punctuation">.</span><span class="token function">removeValue</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        redisUtil<span class="token punctuation">.</span><span class="token function">removeValue</span><span class="token punctuation">(</span>redPacketId<span class="token operator">+</span><span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">/**                         * 异步更新数据库、异步退回红包金额                         */</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目在启动时会遍历所有的 <strong>ApplicationRunner</strong> 的实现类并调用其中的 <strong>run</strong> 方法。</p><p>如果整个系统中有多个 <strong>ApplicationRunner</strong> 的实现类，同样可以使用 <strong>@Order</strong> 注解对这些实现类的调用顺序进行排序（数字越小越先执行）。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>淘宝订单到期，下单成功后60s之后给用户发送短信通知，限时支付、缓存系统等等。</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 测试start 红包未抢完的情况 */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RestTemplate</span> restTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//模拟九个人抢红包</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> userId <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token comment">//String url = "http://localhost:80/startTwo?redPacketId=100&amp;userId=" + userId;</span>            <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8080/start?redPacketId=100&amp;userId="</span> <span class="token operator">+</span> userId<span class="token punctuation">;</span>            restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> restMoney <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>redisUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">+</span> <span class="token string">"-money"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"剩余金额：&#123;&#125;"</span><span class="token punctuation">,</span> restMoney<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>以上方案并没有实现持久化和分布式，生产环境可根据实际业务需求选择使用。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/wzykt/RedPacketDemo">https://github.com/wzykt/RedPacketDemo</a></p>]]></content>
      
      
      <categories>
          
          <category> 案例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL和URI的区别</title>
      <link href="/2021/12/10/uri-url/"/>
      <url>/2021/12/10/uri-url/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://juejin.cn/post/6844903763057049613">https://juejin.cn/post/6844903763057049613</a></p><p>链接：<a href="https://maizitoday.github.io/post/url%E5%92%8Curi%E7%9A%84%E5%8C%BA%E5%88%AB/">https://maizitoday.github.io/post/url%E5%92%8Curi%E7%9A%84%E5%8C%BA%E5%88%AB/</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。 拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。 现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。 那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：</p><p>动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人</p><p>可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。 在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：</p><p>身份证号：<a href="tel:123456789">123456789</a></p><p>来标识他。 所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而URL就是用定位的方式实现的URI。</p><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL：（全称：Uniform Resource Locator） 统一资源定位符。</p><p>它是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址</p><h2 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h2><pre class="line-numbers language-none"><code class="language-none">&lt;scheme&gt;:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>scheme: 协议，常见的有 http（80），https（443），mailto，ftp（21），rtsp，rtspu，file。</li><li>user：用户名。</li><li>password： 密码。</li><li>host：主机。</li><li>port： 端口。</li><li>params: 参数。通常为 <code>key=value</code>。</li><li>query：查询参数或查询字符串。</li><li>frag: 片段（在浏览器中会被解析为 <code>window.location.hash</code>）。</li></ul><p>这只是通用语法，大多数的 URL 都只遵循了一部分而已，并不是每种URL都会有上面的所有信息。</p><p><strong>从上面的语法我们可以看出至少 :/@;?# 都是敏感字符，所以在其他参数中不能包含这些字符，如果含有敏感字符或者特殊字符，就需要使用对应的转义字符，否则可能会发生不可预料的结果。</strong> 在开发过程中，容易在查询参数中含有 敏感字符，所以查询字符串的值一般都需要使用 <code>encodeURIComponent</code>进行编码。</p><p>常用URL的格式一般由下列三部分组成:</p><ol><li>协议(或称为服务方式);</li><li>存有该资源所在的服务器的名称或IP地址(包括端口号);</li><li>主机资源的具体地址。</li></ol><h2 id="一个简单的url"><a href="#一个简单的url" class="headerlink" title="一个简单的url"></a>一个简单的url</h2><h3 id="1-—-协议"><a href="#1-—-协议" class="headerlink" title="1 — 协议"></a>1 — 协议</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">常见的协议http     超文本传输协议资源https    用安全套接字层传送的超文本传输协议ftp      文件传输协议mailto   电子邮件地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-—服务器名称或IP"><a href="#2-—服务器名称或IP" class="headerlink" title="2 —服务器名称或IP"></a>2 —服务器名称或IP</h3><p>端口:相当于一种数据的传输通道。用于接受某些数据，然后传输给相应的服务，而电脑将这些数据处理后，再将相应的回复通过开启的端口传给对方。</p><p>端口的作用：因为 IP 地址与网络服务的关系是一对多的关系。所以实际上因特网上是通过 IP 地址加上端口号来区分不同的服务的。</p><p>端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535。</p><h3 id="3-—-主机资源具体地址"><a href="#3-—-主机资源具体地址" class="headerlink" title="3 — 主机资源具体地址"></a>3 — 主机资源具体地址</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">例如：  <span class="token operator">/</span>webProject<span class="token operator">/</span>index<span class="token punctuation">.</span>html <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般的URL为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">URL<span class="token operator">:</span>  http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">8080</span><span class="token operator">/</span>webProject<span class="token operator">/</span>index<span class="token punctuation">.</span>html <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="在浏览器中输入URL后，执行的全部过程"><a href="#在浏览器中输入URL后，执行的全部过程" class="headerlink" title="在浏览器中输入URL后，执行的全部过程"></a>在浏览器中输入URL后，执行的全部过程</h2><p>整个流程如下:</p><ol><li>域名解析；</li><li>发起TCP的3次握手；</li><li>建立TCP连接后发起http请求；</li><li>服务器响应htp请求；</li><li>浏览器解析htm代码,并请求html代码中的资源(如js、css、图片等）；</li><li>断开TCP连接；</li><li>浏览器对页面进行渲染呈现给用户。</li></ol><p>其实，域名解析这个过程要是细说的话还是有点复杂的，总之有时候也是蛮耗时的，毕竟从 <strong>解析</strong> 这个用词我们就能看出它一定是需要时间的？通过DNS会将域名</p><p>解析为 IP，之后会根据 IP 和 端口连接服务器。</p><p>如果我们直接用IP访问服务器，就可以节省一部分时间，但还是不建议大家这么做，因为如果更换了服务器的话，域名可以解析到另一个IP，可以在浏览器端保留</p><p>相应的数据，而IP就不行了。还有就是，域名的可访问性和可读性可比IP强多了。</p><p>上面的大部分都只适用于静态服务器，如果是动态服务器的话，它会有自己的一套解析规则，但是大致上也是相同的，最大的区别可能还是动态服务器的动态路由</p><p>吧（前端路由现在也支持动态路由了）。</p><h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><p>URI：（全称：Uniform Resource Identifier） 统一资源标识符，它是一个字符串<strong>用来标示抽象或物理资源</strong>。</p><p>Web上可用的每种资源（ HTML文档、图像、音频、视频片段、程序等）都由一个通用资源标识符（Uniform Resource Identifier, 简称”URI”）进行定位。</p><p>URI的格式也由三部分组成:</p><ol><li>访问资源的命名机制。</li><li>存放资源的主机名。</li><li>资源自身的名称，由路径表示。</li></ol><h1 id="联系与区别"><a href="#联系与区别" class="headerlink" title="联系与区别"></a>联系与区别</h1><p>URI ：Uniform Resource Identifier，统一资源标识符； URL：Uniform Resource Locator，统一资源定位符； URN：Uniform Resource Name，统一资源名称。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/1.png" alt="1"></p><p>URI 属于 URL 更高层次的抽象，一种字符串文本标准。</p><p>就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集</p><p>URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（<a href="http:">http://）。</a>./)</p><p>URI可以分为URL,URN，或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。”</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><p>URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位。</p><p>URI：统一资源标识 </p><p>URL：统一资源定位 </p><p>URN：统一资源名称</p><p>例如： <a href="http://www.baidu.com/">www.baidu.com</a>是URL. <a href="http://www.baidu.com/index.html">www.baidu.com/index.html</a> 是URL 同时也是URI。 所以，URL 就是 URI 的 定位。</p><p>但 URI 不一定是 URL。 因为 URI有一类子集是 URN，它是命名资源 但不指定如何定位资源。 如： mailto 需要 加上 相应的结构参数，才能进行 统一资源定位。 如： mailto: <a href="mailto:xxxxx@qq.com">xxxxx@qq.com</a></p><p>因此，三者之间的关系是： URL 一定是 URI  URN + URL 就是 URI。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> URL </tag>
            
            <tag> URI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="/2021/11/29/rabbitmq/"/>
      <url>/2021/11/29/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717161939695.png" alt="image-20210717161939695"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717162004285.png" alt="image-20210717162004285"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210422095356088.png" alt="image-20210422095356088"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考资料：</p><p>我们在Centos7虚拟机中使用Docker来安装。</p><p>方式一：在线拉取</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker pull rabbitmq:3-management<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717162628635.png" alt="image-20210717162628635"></p><p>MQ的基本结构：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717162752376.png" alt="image-20210717162752376"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163332646.png" alt="image-20210717163332646"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163253264.png" alt="image-20210717163253264"></p><p>导入后可以看到结构如下：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163604330.png" alt="image-20210717163604330"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163434647.png" alt="image-20210717163434647"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">Channel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">Connection</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">ConnectionFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublisherTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.建立连接</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"124.70.145.43"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2.建立连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建通道Channel</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.创建队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.发送消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, rabbitmq!"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息成功：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5.关闭通道和连接</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.建立连接</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"124.70.145.43"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2.建立连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建通道Channel</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.创建队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.订阅消息</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span><span class="token class-name">String</span> consumerTag<span class="token punctuation">,</span> <span class="token class-name">Envelope</span> envelope<span class="token punctuation">,</span>                                       <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 5.处理消息</span>                <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到消息：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717164024967.png" alt="image-20210717164024967"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717164038678.png" alt="image-20210717164038678"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息 </li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--AMQP依赖，包含RabbitMQ--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 124.70.145.43 <span class="token comment"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> root <span class="token comment"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span> <span class="token comment"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>spring</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAmqpTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 队列名称</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        <span class="token comment">// 消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>        <span class="token comment">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 124.70.145.43 <span class="token comment"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> root <span class="token comment"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span> <span class="token comment"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>listener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RabbitListener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717164238910.png" alt="image-20210717164238910"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * workQueue     * 向队列中不停发送消息，模拟消息堆积。     */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列名称</span>    <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, message_"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">```<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165309625.png" alt="image-20210717165309625"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165438225.png" alt="image-20210717165438225"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165509466.png" alt="image-20210717165509466"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165552676.png" alt="image-20210717165552676"></p><p>在consumer中创建一个类，声明队列和交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Binding</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">BindingBuilder</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">FanoutExchange</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Queue</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FanoutConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 声明交换机     * @return Fanout类型交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">"itcast.fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 第1个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue1</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue1<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 第2个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue2</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue2<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列名称    </span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"itcast.fanout"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息    </span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, everyone!"</span><span class="token punctuation">;</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者1接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170041447.png" alt="image-20210717170041447"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170223317.png" alt="image-20210717170223317"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue1"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue2"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendDirectExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换机名称    </span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"direct"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息    </span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！"</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息    </span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170705380.png" alt="image-20210717170705380"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170829229.png" alt="image-20210717170829229"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * topicExchange */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendTopicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换机名称</span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"topic"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"喜报！孙悟空大战哥斯拉，胜!"</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"china.news"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*---------------topic-------------------*/</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue1"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"china.#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue2"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#.news"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20200525170410401.png" alt="image-20200525170410401"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 准备消息</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210422232835363.png" alt="image-20210422232835363"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可，覆盖默认的bean：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">MessageConverter</span> <span class="token function">jsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2021/11/29/java-nio/"/>
      <url>/2021/11/29/java-nio/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://nyimac.gitee.io/2020/11/30/Java%20NIO/">转自</a></strong></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p><h2 id="二、IO与NIO的区别"><a href="#二、IO与NIO的区别" class="headerlink" title="二、IO与NIO的区别"></a>二、IO与NIO的区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(NonBlocking IO)</td></tr><tr><td></td><td>选择器(Selectors)</td></tr></tbody></table><h3 id="1、面向流和缓冲区"><a href="#1、面向流和缓冲区" class="headerlink" title="1、面向流和缓冲区"></a>1、面向流和缓冲区</h3><p><strong>IO</strong></p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png" alt="img"></a></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109085054.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109085054.png" alt="img"></a></p><h2 id="三、通道与缓冲区"><a href="#三、通道与缓冲区" class="headerlink" title="三、通道与缓冲区"></a>三、通道与缓冲区</h2><p>Java NIO系统的核心在于：**通道(Channel)和缓冲区(Buffer)**。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><h2 id="四、缓冲区-Buffer"><a href="#四、缓冲区-Buffer" class="headerlink" title="四、缓冲区(Buffer)"></a>四、缓冲区(Buffer)</h2><h3 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h3><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><pre class="line-numbers language-none"><code class="language-none">final byte[] hb;                  &#x2F;&#x2F; Non-null only for heap buffers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>IntBuffer</p><pre class="line-numbers language-none"><code class="language-none">final int[] hb;                  &#x2F;&#x2F; Non-null only for heap buffers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>他们的继承关系如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109091555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109091555.png" alt="img"></a></p><h3 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h3><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取一个容量大小为1024字节的字节缓冲区ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h3><p>缓冲区的父类Buffer中有几个核心属性，如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacityprivate int mark &#x3D; -1;private int position &#x3D; 0;private int limit;private int capacity;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" alt="img"></a></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h4><pre class="line-numbers language-none"><code class="language-none">public class Demo1 &#123;public static void main(String[] args) &#123;ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);System.out.println(&quot;放入前参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------put()------&quot;);System.out.println(&quot;放入3个数据&quot;);byte bt &#x3D; 1;byteBuffer.put(bt);byteBuffer.put(bt);byteBuffer.put(bt);System.out.println(&quot;放入后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------flip()-get()------&quot;);System.out.println(&quot;读取一个数据&quot;);&#x2F;&#x2F; 切换模式byteBuffer.flip();byteBuffer.get();System.out.println(&quot;读取后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------rewind()------&quot;);byteBuffer.rewind();System.out.println(&quot;恢复后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------clear()------&quot;);&#x2F;&#x2F; 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在&#x2F;&#x2F; 但是下次写入的时候会覆盖缓冲区中之前的数据byteBuffer.clear();System.out.println(&quot;清空后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;清空后获得数据&quot;);System.out.println(byteBuffer.get());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果</p><pre class="line-numbers language-none"><code class="language-none">放入前参数position 0limit 1024capacity 1024------put()------放入3个数据放入后参数position 3limit 1024capacity 1024------flip()-get()------读取一个数据读取后参数position 1limit 3capacity 1024------rewind()------恢复后参数position 0limit 3capacity 1024------clear()------清空后参数position 0limit 1024capacity 1024清空后获得数据1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h3><h4 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h4><p>通过<strong>allocate()<strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM</strong>堆内存</strong>之中的。</p><pre class="line-numbers language-none"><code class="language-none">public static ByteBuffer allocate(int capacity) &#123;    if (capacity &lt; 0)    throw new IllegalArgumentException();    &#x2F;&#x2F; 在堆内存中开辟空间    return new HeapByteBuffer(capacity, capacity);&#125;HeapByteBuffer(int cap, int lim) &#123;        &#x2F;&#x2F; package-private    &#x2F;&#x2F; new byte[cap] 创建数组，在堆内存中开辟空间    super(-1, 0, lim, cap, new byte[cap], 0);    &#x2F;*    hb &#x3D; new byte[cap];    offset &#x3D; 0;    *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151057.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151057.png" alt="img"></a></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低</p><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><pre class="line-numbers language-none"><code class="language-none">public static ByteBuffer allocateDirect(int capacity) &#123;    return new DirectByteBuffer(capacity);&#125;DirectByteBuffer(int cap) &#123;                   &#x2F;&#x2F; package-private...    &#x2F;&#x2F; 申请物理内存boolean pa &#x3D; VM.isDirectMemoryPageAligned();...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151520.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151520.png" alt="img"></a></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h2 id="五、通道-Channel"><a href="#五、通道-Channel" class="headerlink" title="五、通道(Channel)"></a>五、通道(Channel)</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong></p><h3 id="2、图解"><a href="#2、图解" class="headerlink" title="2、图解"></a>2、图解</h3><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153039.png" alt="img"></a></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153439.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153439.png" alt="img"></a></p><p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154113.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154113.png" alt="img"></a></p><h3 id="3、Java-Channel"><a href="#3、Java-Channel" class="headerlink" title="3、Java Channel"></a>3、Java Channel</h3><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154803.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154803.png" alt="img"></a></p><ul><li>本地文件IO<ul><li>FileChannel</li></ul></li><li>网络IO<ul><li>SocketChanel、ServerSocketChannel：用于TCP传输</li><li>DatagramChannel：用于UDP传输</li></ul></li></ul><h4 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h4><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><pre class="line-numbers language-none"><code class="language-none">public class Demo2 &#123;   public static void main(String[] args) throws IOException &#123;      &#x2F;&#x2F; 本地通道      FileInputStream fileInputStream &#x3D; new FileInputStream(&quot;&quot;);      FileChannel channel1 &#x3D; fileInputStream.getChannel();      FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;&quot;);      FileChannel channel2 &#x3D; fileOutputStream.getChannel();         &#x2F;&#x2F; 网络通道      Socket socket &#x3D; new Socket();      SocketChannel channel3 &#x3D; socket.getChannel();            ServerSocket serverSocket &#x3D; new ServerSocket();      ServerSocketChannel channel4 &#x3D; serverSocket.getChannel();      DatagramSocket datagramSocket &#x3D; new DatagramSocket();      DatagramChannel channel5 &#x3D; datagramSocket.getChannel();             &#x2F;&#x2F; 最后要关闭通道          &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>也可以通过通道的静态方法open()来获取</strong></p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws IOException &#123;   FileChannel open &#x3D; FileChannel.open(Paths.get(&quot;&quot;));      SocketChannel open1 &#x3D; SocketChannel.open();      ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h4><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><pre class="line-numbers language-none"><code class="language-none">public class Demo4 &#123;   public static void main(String[] args) &#123;      FileInputStream is &#x3D; null;      FileOutputStream os &#x3D; null;      &#x2F;&#x2F; 获得通道      FileChannel inChannel &#x3D; null;      FileChannel outChannel &#x3D; null;             &#x2F;&#x2F; 利用 try-catch-finally 保证关闭      try &#123;         is &#x3D; new FileInputStream(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;);         os &#x3D; new FileOutputStream(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;);         &#x2F;&#x2F; 获得通道         inChannel &#x3D; is.getChannel();         outChannel &#x3D; os.getChannel();         &#x2F;&#x2F; 获得缓冲区，用于在通道中传输数据         ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);         &#x2F;&#x2F; 循环将字节数据放入到buffer中，然后写入磁盘中         while (inChannel.read(byteBuffer) !&#x3D; -1) &#123;            &#x2F;&#x2F; 切换模式            byteBuffer.flip();            outChannel.write(byteBuffer);            byteBuffer.clear();         &#125;      &#125; catch (IOException e) &#123;         e.printStackTrace();      &#125; finally &#123;         if (inChannel !&#x3D; null) &#123;            try &#123;               inChannel.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         if (outChannel !&#x3D; null) &#123;            try &#123;               outChannel.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         if (is !&#x3D; null) &#123;            try &#123;               is.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         if (os !&#x3D; null) &#123;            try &#123;               os.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;      &#125;   &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图片读取后，被写入到了指定位置</strong><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109211055.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109211055.png" alt="img"></a></p><h4 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h4><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><pre class="line-numbers language-none"><code class="language-none">public class Demo5 &#123;   public static void main(String[] args) throws IOException &#123;      &#x2F;&#x2F; 通过open()方法来获得通道      FileChannel inChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;), StandardOpenOption.READ);      &#x2F;&#x2F; outChannel需要为 READ WRITE CREATE模式      &#x2F;&#x2F; READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式      &#x2F;&#x2F; CREATE是因为要创建新的文件      FileChannel outChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);      &#x2F;&#x2F; 获得直接缓冲区      MappedByteBuffer inMapBuf &#x3D; inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());      MappedByteBuffer outMapBuf &#x3D; outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());      &#x2F;&#x2F; 字节数组      byte[] bytes &#x3D; new byte[inMapBuf.limit()];      &#x2F;&#x2F; 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输      inMapBuf.get(bytes);      outMapBuf.put(bytes);      &#x2F;&#x2F; 关闭缓冲区，这里没有用try-catch-finally      inChannel.close();      outChannel.close();   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果，图片被创建</strong><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109214801.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109214801.png" alt="img"></a></p><h4 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h4><pre class="line-numbers language-none"><code class="language-none">public static void channelToChannel() throws IOException &#123;   long start &#x3D; System.currentTimeMillis();   &#x2F;&#x2F; 通过open()方法来获得通道   FileChannel inChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;), StandardOpenOption.READ);   &#x2F;&#x2F; outChannel需要为 READ WRITE CREATE模式   &#x2F;&#x2F; READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式   &#x2F;&#x2F; CREATE是因为要创建新的文件   FileChannel outChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);   &#x2F;&#x2F; 通道间直接传输   inChannel.transferTo(0, inChannel.size(), outChannel);   &#x2F;&#x2F; 对应的还有transferFrom   &#x2F;&#x2F; outChannel.transferFrom(inChannel, 0, inChannel.size());   inChannel.close();   outChannel.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h4><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; getChannel() + 非直接缓冲区耗时708&#x2F;&#x2F; open() + 直接缓冲区耗时115&#x2F;&#x2F; channel transferTo channel耗时47<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h3 id="4、分散和聚集"><a href="#4、分散和聚集" class="headerlink" title="4、分散和聚集"></a>4、分散和聚集</h3><h4 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h4><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082427.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082427.png" alt="img"></a></p><h4 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h4><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png" alt="img"></a></p><p><strong>代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Demo2 &#123;   public static void main(String[] args) throws IOException &#123;      FileInputStream is &#x3D; new FileInputStream(&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;);      FileOutputStream os &#x3D; new FileOutputStream(&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;);      FileChannel inChannel &#x3D; is.getChannel();      FileChannel outChannel &#x3D; os.getChannel();      &#x2F;&#x2F; 获得多个缓冲区，并且放入到缓冲区数组中      ByteBuffer byteBuffer1 &#x3D; ByteBuffer.allocate(50);      ByteBuffer byteBuffer2 &#x3D; ByteBuffer.allocate(1024);      ByteBuffer[] byteBuffers &#x3D; &#123;byteBuffer1, byteBuffer2&#125;;      &#x2F;&#x2F; 分散读取      inChannel.read(byteBuffers);            byteBuffer1.flip();      byteBuffer2.flip();            &#x2F;&#x2F; 聚集写入      outChannel.write(byteBuffers);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083219.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083219.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083230.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083230.png" alt="img"></a></p><h2 id="六、非阻塞式网络通信"><a href="#六、非阻塞式网络通信" class="headerlink" title="六、非阻塞式网络通信"></a>六、非阻塞式网络通信</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>双11买的快递到了，快递小哥给你打电话说马上到小区门口，麻烦在门口等一下，方便签收快递</p><ul><li>若为<strong>阻塞式</strong>的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了</li><li>若为<strong>非阻塞式</strong>的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿</li></ul><h4 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h4><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111090126.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111090126.png" alt="img"></a></p><h4 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h4><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112165417.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112165417.png" alt="img"></a></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="阻塞式网络通信演示"><a href="#阻塞式网络通信演示" class="headerlink" title="阻塞式网络通信演示"></a>阻塞式网络通信演示</h4><pre class="line-numbers language-none"><code class="language-none">public class Demo1 &#123;   public static void main(String[] args) throws IOException &#123;      Thread thread1 &#x3D; new Thread(()-&gt;&#123;         try &#123;            server();         &#125; catch (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      Thread thread2 &#x3D; new Thread(()-&gt;&#123;         try &#123;            client();         &#125; catch (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      thread1.start();      thread2.start();   &#125;   public static void client() throws IOException &#123;      &#x2F;&#x2F; 创建客户端通道      SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 2022));      &#x2F;&#x2F; 读取信息      FileChannel fileChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\1.jpg&quot;), StandardOpenOption.READ);      &#x2F;&#x2F; 创建缓冲区      ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);      &#x2F;&#x2F; 写入数据      while (fileChannel.read(byteBuffer) !&#x3D; -1) &#123;         byteBuffer.flip();         socketChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      fileChannel.close();      socketChannel.close();   &#125;   public static void server() throws IOException &#123;      &#x2F;&#x2F; 创建服务端通道      ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();      FileChannel fileChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\2.jpg&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);      &#x2F;&#x2F; 绑定链接      serverSocketChannel.bind(new InetSocketAddress(2022));      &#x2F;&#x2F; 获取客户端的通道      SocketChannel socketChannel &#x3D; serverSocketChannel.accept();      &#x2F;&#x2F; 创建缓冲区      ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);      while (socketChannel.read(byteBuffer) !&#x3D; -1) &#123;         byteBuffer.flip();         fileChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      socketChannel.close();      fileChannel.close();      serverSocketChannel.close();   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="非阻塞式网络通信演示"><a href="#非阻塞式网络通信演示" class="headerlink" title="非阻塞式网络通信演示"></a>非阻塞式网络通信演示</h4><pre class="line-numbers language-none"><code class="language-none">public class DemoNIO &#123;public static void main(String[] args) &#123;Thread thread1 &#x3D; new Thread(()-&gt;&#123;try &#123;server();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;);Thread thread2 &#x3D; new Thread(()-&gt;&#123;try &#123;client();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;);thread1.start();thread2.start();&#125;public static void client() throws IOException &#123;SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 2020));&#x2F;&#x2F; 设置为非阻塞模式socketChannel.configureBlocking(false);ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);Scanner scanner &#x3D; new Scanner(System.in);while (scanner.hasNext()) &#123;String str &#x3D; scanner.next();byteBuffer.put(str.getBytes());byteBuffer.flip();socketChannel.write(byteBuffer);byteBuffer.clear();&#125;byteBuffer.clear();socketChannel.close();&#125;public static void server() throws IOException &#123;ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();serverSocketChannel.configureBlocking(false);serverSocketChannel.bind(new InetSocketAddress(2020));&#x2F;&#x2F; 获得选择器Selector selector &#x3D; Selector.open();&#x2F;&#x2F; 将通道注册到选择器中，设定为接收操作serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#x2F;&#x2F; 轮训接受while (selector.select() &gt; 0) &#123;Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();&#x2F;&#x2F; 获得事件的keywhile (iterator.hasNext()) &#123;SelectionKey key &#x3D; iterator.next();if (key.isAcceptable()) &#123;SocketChannel socketChannel &#x3D; serverSocketChannel.accept();socketChannel.configureBlocking(false);socketChannel.register(selector, SelectionKey.OP_READ);&#125; else if (key.isReadable()) &#123;&#x2F;&#x2F; 从选择器中获取通道SocketChannel socketChannel &#x3D; (SocketChannel) key.channel();ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(10);while (socketChannel.read(byteBuffer) !&#x3D; -1) &#123;int len &#x3D; byteBuffer.limit();byteBuffer.flip();System.out.println(new String(byteBuffer.array(), 0, len));byteBuffer.clear();&#125;socketChannel.close();&#125;iterator.remove();&#125;&#125;serverSocketChannel.close();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112163633.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112163633.png" alt="img"></a></p><p><strong>选择器的创建</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建一个选择器Selector selector &#x3D; Selector.open();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112164022.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112164022.png" alt="img"></a></p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 让选择器监听一种状态myChannel.register(selector, SelectionKey.OP_READ);&#x2F;&#x2F; 让选择器监听多种状态myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习之NIO基础</title>
      <link href="/2021/11/29/netty-xue-xi-zhi-nio-ji-chu/"/>
      <url>/2021/11/29/netty-xue-xi-zhi-nio-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty学习之NIO基础"><a href="#Netty学习之NIO基础" class="headerlink" title="Netty学习之NIO基础"></a>Netty学习之NIO基础</h1><p>本博客是根据<a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=2"><strong>黑马程序员Netty实战</strong></a>学习时所做的笔记</p><p>博客转载自：<a href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/"><strong>Netty学习之NIO基础</strong></a></p><h1 id="一、三大组件简介"><a href="#一、三大组件简介" class="headerlink" title="一、三大组件简介"></a>一、三大组件简介</h1><p><strong>Channel与Buffer &amp;Selector</strong></p><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)<strong>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于</strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Buffer有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png" alt="img"></a></p><h2 id="1、Selector"><a href="#1、Selector" class="headerlink" title="1、Selector"></a>1、Selector</h2><p>在使用Selector之前，处理socket连接还有以下两种方法</p><p><strong>使用多线程技术</strong></p><p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><p><strong>使用线程池技术</strong></p><p>使用线程池，让线程池中的线程去处理连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li><p>阻塞模式下，线程仅能处理一个连接</p><ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li></ul></li><li><p>仅适合</p><p>短连接</p><p>场景</p><ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><p><strong>使用选择器</strong></p><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png" alt="img"></a></p><p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="2、Buffer"><a href="#2、Buffer" class="headerlink" title="2、Buffer"></a>2、Buffer</h2><h3 id="ByteBuffer使用案例"><a href="#ByteBuffer使用案例" class="headerlink" title="ByteBuffer使用案例"></a>ByteBuffer使用案例</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p></li><li><p>调用 flip() 切换至</p><p>读模式</p><ul><li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li></ul></li><li><p>从 buffer 读取数据，例如调用 buffer.get()</p></li><li><p>调用 clear() 或者compact()切换至</p><p>写模式</p><ul><li>调用clear()方法时<strong>position=0，limit变为capacity</strong></li><li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li></ul></li><li><p>重复以上步骤</p></li></ul><p><strong>使用ByteBuffer读取文件中的内容</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestByteBuffer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 获得FileChannel        try (FileChannel channel &#x3D; new FileInputStream(&quot;stu.txt&quot;).getChannel()) &#123;            &#x2F;&#x2F; 获得缓冲区            ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);            int hasNext &#x3D; 0;            StringBuilder builder &#x3D; new StringBuilder();            while((hasNext &#x3D; channel.read(buffer)) &gt; 0) &#123;                &#x2F;&#x2F; 切换模式 limit&#x3D;position, position&#x3D;0                buffer.flip();                &#x2F;&#x2F; 当buffer中还有数据时，获取其中的数据                while(buffer.hasRemaining()) &#123;                    builder.append((char)buffer.get());                &#125;                &#x2F;&#x2F; 切换模式 position&#x3D;0, limit&#x3D;capacity                buffer.clear();            &#125;            System.out.println(builder.toString());        &#125; catch (IOException e) &#123;        &#125;    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果</p><pre class="line-numbers language-none"><code class="language-none">0123456789abcdefCopy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p><strong>向buffer写入数据有两种办法</strong></p><ul><li>调用channel 的read方法</li><li>调用buffer自己的put方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> readBytes <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">buf<span class="token punctuation">.</span>put <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>从buffer读取数据同样有两种办法</strong></p><ul><li>调用channel的 write方法</li><li>调用buffer自己的get方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> writeBytes <span class="token operator">=</span> channel<span class="token punctuation">.</span> <span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> b <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>get方法会让position读指针向后走，如果想重复读取数据</p><ul><li>可以调用rewind方法将position重新置为0</li><li>或者调用get(int i)方法获取索引i的内容，它不会移动读指针</li></ul><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacityprivate int mark &#x3D; -1;private int position &#x3D; 0;private int limit;private int capacity;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li><li><strong>注意：get(i)方法不会改变position的值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" alt="img"></a></p><h4 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值（索引）</li></ul><p>通常将mark()和reset()方法一起使用，mark方法用来标记重要的文件内容的索引，reset可以回到mark方法标记的地方</p><h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p><ul><li>compact会把未读完的数据向前压缩，然后切换到写模式</li><li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png" alt="img"></a></p><h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a>clear() VS compact()</h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p><p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p><h3 id="方法调用及演示"><a href="#方法调用及演示" class="headerlink" title="方法调用及演示"></a>方法调用及演示</h3><h4 id="ByteBuffer调试工具类"><a href="#ByteBuffer调试工具类" class="headerlink" title="ByteBuffer调试工具类"></a>ByteBuffer调试工具类</h4><p>可以使用debugAll方法来研究ByteBuffer的核心参数的变化情况。</p><p>需要先导入netty依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;  &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;  &lt;version&gt;4.1.51.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;Copyimport java.nio.ByteBuffer;import io.netty.util.internal.MathUtil;import io.netty.util.internal.StringUtil;import io.netty.util.internal.MathUtil.*;public class ByteBufferUtil &#123;    private static final char[] BYTE2CHAR &#x3D; new char[256];    private static final char[] HEXDUMP_TABLE &#x3D; new char[256 * 4];    private static final String[] HEXPADDING &#x3D; new String[16];    private static final String[] HEXDUMP_ROWPREFIXES &#x3D; new String[65536 &gt;&gt;&gt; 4];    private static final String[] BYTE2HEX &#x3D; new String[256];    private static final String[] BYTEPADDING &#x3D; new String[16];    static &#123;        final char[] DIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();        for (int i &#x3D; 0; i &lt; 256; i++) &#123;            HEXDUMP_TABLE[i &lt;&lt; 1] &#x3D; DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] &#x3D; DIGITS[i &amp; 0x0F];        &#125;        int i;        &#x2F;&#x2F; Generate the lookup table for hex dump paddings        for (i &#x3D; 0; i &lt; HEXPADDING.length; i++) &#123;            int padding &#x3D; HEXPADDING.length - i;            StringBuilder buf &#x3D; new StringBuilder(padding * 3);            for (int j &#x3D; 0; j &lt; padding; j++) &#123;                buf.append(&quot;   &quot;);            &#125;            HEXPADDING[i] &#x3D; buf.toString();        &#125;        &#x2F;&#x2F; Generate the lookup table for the start-offset header in each row (up to 64KiB).        for (i &#x3D; 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;            StringBuilder buf &#x3D; new StringBuilder(12);            buf.append(StringUtil.NEWLINE);            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));            buf.setCharAt(buf.length() - 9, &#39;|&#39;);            buf.append(&#39;|&#39;);            HEXDUMP_ROWPREFIXES[i] &#x3D; buf.toString();        &#125;        &#x2F;&#x2F; Generate the lookup table for byte-to-hex-dump conversion        for (i &#x3D; 0; i &lt; BYTE2HEX.length; i++) &#123;            BYTE2HEX[i] &#x3D; &#39; &#39; + StringUtil.byteToHexStringPadded(i);        &#125;        &#x2F;&#x2F; Generate the lookup table for byte dump paddings        for (i &#x3D; 0; i &lt; BYTEPADDING.length; i++) &#123;            int padding &#x3D; BYTEPADDING.length - i;            StringBuilder buf &#x3D; new StringBuilder(padding);            for (int j &#x3D; 0; j &lt; padding; j++) &#123;                buf.append(&#39; &#39;);            &#125;            BYTEPADDING[i] &#x3D; buf.toString();        &#125;        &#x2F;&#x2F; Generate the lookup table for byte-to-char conversion        for (i &#x3D; 0; i &lt; BYTE2CHAR.length; i++) &#123;            if (i &lt;&#x3D; 0x1f || i &gt;&#x3D; 0x7f) &#123;                BYTE2CHAR[i] &#x3D; &#39;.&#39;;            &#125; else &#123;                BYTE2CHAR[i] &#x3D; (char) i;            &#125;        &#125;    &#125;    &#x2F;**     * 打印所有内容     * @param buffer     *&#x2F;    public static void debugAll(ByteBuffer buffer) &#123;        int oldlimit &#x3D; buffer.limit();        buffer.limit(buffer.capacity());        StringBuilder origin &#x3D; new StringBuilder(256);        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), oldlimit);        System.out.println(origin);        buffer.limit(oldlimit);    &#125;    &#x2F;**     * 打印可读取内容     * @param buffer     *&#x2F;    public static void debugRead(ByteBuffer buffer) &#123;        StringBuilder builder &#x3D; new StringBuilder(256);        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), buffer.limit());        System.out.println(builder);    &#125;    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;        if (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;            throw new IndexOutOfBoundsException(                    &quot;expected: &quot; + &quot;0 &lt;&#x3D; offset(&quot; + offset + &quot;) &lt;&#x3D; offset + length(&quot; + length                            + &quot;) &lt;&#x3D; &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#39;)&#39;);        &#125;        if (length &#x3D;&#x3D; 0) &#123;            return;        &#125;        dump.append(                &quot;         +-------------------------------------------------+&quot; +                        StringUtil.NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +                        StringUtil.NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);        final int startIndex &#x3D; offset;        final int fullRows &#x3D; length &gt;&gt;&gt; 4;        final int remainder &#x3D; length &amp; 0xF;        &#x2F;&#x2F; Dump the rows which have 16 bytes.        for (int row &#x3D; 0; row &lt; fullRows; row++) &#123;            int rowStartIndex &#x3D; (row &lt;&lt; 4) + startIndex;            &#x2F;&#x2F; Per-row prefix.            appendHexDumpRowPrefix(dump, row, rowStartIndex);            &#x2F;&#x2F; Hex dump            int rowEndIndex &#x3D; rowStartIndex + 16;            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(&quot; |&quot;);            &#x2F;&#x2F; ASCII dump            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(&#39;|&#39;);        &#125;        &#x2F;&#x2F; Dump the last row which has less than 16 bytes.        if (remainder !&#x3D; 0) &#123;            int rowStartIndex &#x3D; (fullRows &lt;&lt; 4) + startIndex;            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);            &#x2F;&#x2F; Hex dump            int rowEndIndex &#x3D; rowStartIndex + remainder;            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(HEXPADDING[remainder]);            dump.append(&quot; |&quot;);            &#x2F;&#x2F; Ascii dump            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(BYTEPADDING[remainder]);            dump.append(&#39;|&#39;);        &#125;        dump.append(StringUtil.NEWLINE +                &quot;+--------+-------------------------------------------------+----------------+&quot;);    &#125;    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;            dump.append(HEXDUMP_ROWPREFIXES[row]);        &#125; else &#123;            dump.append(StringUtil.NEWLINE);            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));            dump.setCharAt(dump.length() - 9, &#39;|&#39;);            dump.append(&#39;|&#39;);        &#125;    &#125;    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;        return (short) (buffer.get(index) &amp; 0xFF);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用ByteBuffer的方法"><a href="#调用ByteBuffer的方法" class="headerlink" title="调用ByteBuffer的方法"></a>调用ByteBuffer的方法</h4><pre class="line-numbers language-none"><code class="language-none">public class TestByteBuffer &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);        &#x2F;&#x2F; 向buffer中写入1个字节的数据        buffer.put((byte)97);        &#x2F;&#x2F; 使用工具类，查看buffer状态        ByteBufferUtil.debugAll(buffer);        &#x2F;&#x2F; 向buffer中写入4个字节的数据        buffer.put(new byte[]&#123;98, 99, 100, 101&#125;);        ByteBufferUtil.debugAll(buffer);&#x2F;&#x2F;未改变模式前，试一下能不能拿到值        &#x2F;&#x2F;System.out.println(buffer.get());        &#x2F;&#x2F;会发现读到的是零，及读不到值                &#x2F;&#x2F; 获取数据        buffer.flip();        ByteBufferUtil.debugAll(buffer);        System.out.println(buffer.get());        System.out.println(buffer.get());        ByteBufferUtil.debugAll(buffer);        &#x2F;&#x2F; 使用compact切换模式        buffer.compact();        ByteBufferUtil.debugAll(buffer);        &#x2F;&#x2F; 再次写入        buffer.put((byte)102);        buffer.put((byte)103);        ByteBufferUtil.debugAll(buffer);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 向缓冲区写入了一个字节的数据，此时postition为1+--------+-------------------- all ------------------------+----------------+position: [1], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 00 00 00 00 00 00 00 00 00                   |a.........      |+--------+-------------------------------------------------+----------------+&#x2F;&#x2F; 向缓冲区写入四个字节的数据，此时position为5+--------+-------------------- all ------------------------+----------------+position: [5], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |+--------+-------------------------------------------------+----------------+&#x2F;&#x2F; 调用flip切换模式，此时position为0，表示从第0个数据开始读取+--------+-------------------- all ------------------------+----------------+position: [0], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |+--------+-------------------------------------------------+----------------+&#x2F;&#x2F; 读取两个字节的数据             9798            &#x2F;&#x2F; position变为2             +--------+-------------------- all ------------------------+----------------+position: [2], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |+--------+-------------------------------------------------+----------------+             &#x2F;&#x2F; 调用compact切换模式，此时position及其后面的数据被压缩到ByteBuffer前面去了&#x2F;&#x2F; 此时position为3，会覆盖之前的数据             +--------+-------------------- all ------------------------+----------------+position: [3], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 64 65 64 65 00 00 00 00 00                   |cdede.....      |+--------+-------------------------------------------------+----------------+             &#x2F;&#x2F; 再次写入两个字节的数据，之前的 0x64 0x65 被覆盖         +--------+-------------------- all ------------------------+----------------+position: [5], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 64 65 66 67 00 00 00 00 00                   |cdefg.....      |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p><p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Translate &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 准备两个字符串        String str1 &#x3D; &quot;hello&quot;;        String str2 &#x3D; &quot;&quot;;        ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 通过字符串的getByte方法获得字节数组，放入缓冲区中        buffer1.put(str1.getBytes());        ByteBufferUtil.debugAll(buffer1);        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串        &#x2F;&#x2F; 切换模式        buffer1.flip();                &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [5], limit: [16]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [5], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><pre class="line-numbers language-none"><code class="language-none">public class Translate &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 准备两个字符串        String str1 &#x3D; &quot;hello&quot;;        String str2 &#x3D; &quot;&quot;;        &#x2F;&#x2F; 通过StandardCharsets的encode方法获得ByteBuffer        &#x2F;&#x2F; 此时获得的ByteBuffer为读模式，无需通过flip切换模式        ByteBuffer buffer1 &#x3D; StandardCharsets.UTF_8.encode(str1);        ByteBufferUtil.debugAll(buffer1);        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [0], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [5], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><strong>方法三</strong></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><pre class="line-numbers language-none"><code class="language-none">public class Translate &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 准备两个字符串        String str1 &#x3D; &quot;hello&quot;;        String str2 &#x3D; &quot;&quot;;        &#x2F;&#x2F; 通过StandardCharsets的encode方法获得ByteBuffer        &#x2F;&#x2F; 此时获得的ByteBuffer为读模式，无需通过flip切换模式        ByteBuffer buffer1 &#x3D; ByteBuffer.wrap(str1.getBytes());        ByteBufferUtil.debugAll(buffer1);        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [0], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [5], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p>出现上面这些情况的原因是，发送方为了效率，将三条数据一起发了过来，但是接收方的Buffer是固定的，三条数据可能需要两个Buffer才能办到，就出现了上面这种情况</p><p><strong>粘包</strong></p><p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p><strong>半包</strong></p><p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p><p>注意</p><p>：get(index)不会改变position的值</p><ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p></li></ul><pre class="line-numbers language-none"><code class="language-none">public class ByteBufferDemo &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(32);        &#x2F;&#x2F; 模拟粘包+半包        buffer.put(&quot;Hello,world\nI&#39;m Nyima\nHo&quot;.getBytes());        &#x2F;&#x2F; 调用split函数处理        split(buffer);        buffer.put(&quot;w are you?\n&quot;.getBytes());        split(buffer);    &#125;    private static void split(ByteBuffer buffer) &#123;        &#x2F;&#x2F; 切换为读模式        buffer.flip();        for(int i &#x3D; 0; i &lt; buffer.limit(); i++) &#123;            &#x2F;&#x2F; 遍历寻找分隔符            &#x2F;&#x2F; get(i)不会移动position            &#x2F;&#x2F;&#39;\n&#39;占一个字节            if (buffer.get(i) &#x3D;&#x3D; &#39;\n&#39;) &#123;                &#x2F;&#x2F; 缓冲区长度                int length &#x3D; i+1-buffer.position();                ByteBuffer target &#x3D; ByteBuffer.allocate(length);                &#x2F;&#x2F; 将前面的内容写入target缓冲区                for(int j &#x3D; 0; j &lt; length; j++) &#123;                    &#x2F;&#x2F; 将buffer中的数据写入target中                    target.put(buffer.get());                &#125;                &#x2F;&#x2F; 打印查看结果                ByteBufferUtil.debugAll(target);            &#125;        &#125;        &#x2F;&#x2F; 切换为写模式，但是缓冲区可能未读完，这里需要使用compact        buffer.compact();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [12], limit: [12]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |+--------+-------------------------------------------------+----------------++--------+-------------------- all ------------------------+----------------+position: [10], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#39;m Nyima.      |+--------+-------------------------------------------------+----------------++--------+-------------------- all ------------------------+----------------+position: [13], limit: [13]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、文件编程"><a href="#二、文件编程" class="headerlink" title="二、文件编程"></a>二、文件编程</h1><h2 id="1、FileChannel"><a href="#1、FileChannel" class="headerlink" title="1、FileChannel"></a>1、FileChannel</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p><p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p><pre class="line-numbers language-none"><code class="language-none">int readBytes &#x3D; channel.read(buffer);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>可根据返回值判断是否读取完毕</strong></p><pre class="line-numbers language-none"><code class="language-none">while(channel.read(buffer) &gt; 0) &#123;    &#x2F;&#x2F; 进行对应操作    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中while(buffer.hasRemaining()) &#123;channel.write(buffer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestChannel &#123;    public static void main(String[] args) throws IOException &#123;        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);             FileChannel inputChannel &#x3D; fis.getChannel();             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;                        &#x2F;&#x2F; 执行对应操作            ...                        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><strong>position</strong></p><p>channel也拥有一个保存读取数据位置的属性，即position</p><pre class="line-numbers language-none"><code class="language-none">long pos &#x3D; channel.position();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过position(int pos)设置channel中position的值</p><pre class="line-numbers language-none"><code class="language-none">long newPos &#x3D; ...;channel.position(newPos);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="2、两个Channel传输数据"><a href="#2、两个Channel传输数据" class="headerlink" title="2、两个Channel传输数据"></a>2、两个Channel传输数据</h2><h3 id="transferTo方法"><a href="#transferTo方法" class="headerlink" title="transferTo方法"></a>transferTo方法</h3><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><p>transferTo底层使用了零拷贝技术</p><pre class="line-numbers language-none"><code class="language-none">public class TestChannel &#123;    public static void main(String[] args)&#123;        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);             FileChannel inputChannel &#x3D; fis.getChannel();             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;            &#x2F;&#x2F; 参数：inputChannel的起始位置，传输数据的大小，目的channel            &#x2F;&#x2F; 返回值为传输的数据的字节数            &#x2F;&#x2F; transferTo一次只能传输2G的数据            inputChannel.transferTo(0, inputChannel.size(), outputChannel);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><pre class="line-numbers language-none"><code class="language-none">public class TestChannel &#123;    public static void main(String[] args)&#123;        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);             FileChannel inputChannel &#x3D; fis.getChannel();             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;            long size &#x3D; inputChannel.size();            long capacity &#x3D; inputChannel.size();            &#x2F;&#x2F; 分多次传输            while (capacity &gt; 0) &#123;                &#x2F;&#x2F; transferTo返回值为传输了的字节数                capacity -&#x3D; inputChannel.transferTo(size-capacity, capacity, outputChannel);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Path与Paths"><a href="#3、Path与Paths" class="headerlink" title="3、Path与Paths"></a>3、Path与Paths</h2><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><pre class="line-numbers language-none"><code class="language-none">Path source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txtPath source &#x3D; Paths.get(&quot;d:\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\1.txt 反斜杠需要转义Path source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\1.txtPath projects &#x3D; Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\data\projectsCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><pre class="line-numbers language-none"><code class="language-none">d:|- data|- projects|- a|- bCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码</p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;d:\\data\\projects\\a\\..\\b&quot;);System.out.println(path);System.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径 会去除 . 以及 ..Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><pre class="line-numbers language-none"><code class="language-none">d:\data\projects\a\..\bd:\data\projects\bCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、Files"><a href="#4、Files" class="headerlink" title="4、Files"></a>4、Files</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>检查文件或者文件夹是否存在</p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);System.out.println(Files.exists(path));Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建<strong>一级目录</strong>，不能创建多级目录 </p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);Files.createDirectory(path);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建<strong>多级目录用</strong></p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);Files.createDirectories(path);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="拷贝及移动"><a href="#拷贝及移动" class="headerlink" title="拷贝及移动"></a>拷贝及移动</h3><p><strong>拷贝文件</strong></p><pre class="line-numbers language-none"><code class="language-none">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);Files.copy(source, target);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 StandardCopyOption 来控制</p><pre class="line-numbers language-none"><code class="language-none">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>移动文件</p><pre class="line-numbers language-none"><code class="language-none">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);Path target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除文件</p><pre class="line-numbers language-none"><code class="language-none">Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);Files.delete(target);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><pre class="line-numbers language-none"><code class="language-none">Path target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);Files.delete(target);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果<strong>目录还有内容</strong>，会抛异常 DirectoryNotEmptyException</li></ul><p>删除文件及文件夹，看看就好，这样删除时不走回收站的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//Files.delete(Paths.get("D:\\Snipaste-1.16.2-x64 –副本"));</span>    <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">walkFileTree</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"D: \\Snipaste-1.16.2-x64 -副本"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFileVisitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Path</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">FileVisitResult</span> <span class="token function">visitFile</span><span class="token punctuation">(</span><span class="token class-name">Path</span> file<span class="token punctuation">,</span> <span class="token class-name">BasicFileAttributes</span> attrs<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">FileVisitResult</span> <span class="token function">postVisitDirectory</span><span class="token punctuation">(</span><span class="token class-name">Path</span> dir<span class="token punctuation">,</span> <span class="token class-name">IOException</span> exc<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">postVisitDirectory</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p><ul><li><p>Path：文件起始路径</p></li><li><p>FileVisitor：文件访问器，</p><p>使用访问者模式</p><ul><li><p>接口的实现类</p><p>SimpleFileVisitor</p><p>有四个方法</p><ul><li>preVisitDirectory：访问目录前的操作</li><li>visitFile：访问文件的操作</li><li>visitFileFailed：访问文件失败时的操作</li><li>postVisitDirectory：访问目录后的操作</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">public class TestWalkFileTree &#123;    public static void main(String[] args) throws IOException &#123;        Path path &#x3D; Paths.get(&quot;D:\Programs\Netty-demo&quot;);        &#x2F;&#x2F; 文件目录数目        AtomicInteger dirCount &#x3D; new AtomicInteger();        &#x2F;&#x2F; 文件数目        AtomicInteger fileCount &#x3D; new AtomicInteger();        Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;            @Override            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&gt;&quot;+dir);                &#x2F;&#x2F; 增加文件目录数                dirCount.incrementAndGet();                return super.preVisitDirectory(dir, attrs);            &#125;            @Override            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;                System.out.println(file);                &#x2F;&#x2F; 增加文件数                fileCount.incrementAndGet();                return super.visitFile(file, attrs);            &#125;        &#125;);        &#x2F;&#x2F; 打印数目        System.out.println(&quot;文件目录数:&quot;+dirCount.get());        System.out.println(&quot;文件数:&quot;+fileCount.get());    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><pre class="line-numbers language-none"><code class="language-none">...D:\Programs\Netty-demo\target\test-classes\netty\TestByteBufferAllocate.classD:\Programs\Netty-demo\target\test-classes\netty\TestByteBufferReadWrite.classD:\Programs\Netty-demo\target\test-classes\netty\TestByteBufferString.classD:\Programs\Netty-demo\target\test-classes\netty\TestFileChannerTransferTo.classD:\Programs\Netty-demo\target\test-classes\netty\TestFilesWalkFileTree$1.classD:\Programs\Netty-demo\target\test-classes\netty\TestFilesWalkFileTree.class文件目录数:64文件数:88Process finished with exit code 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的设计模式是<strong>访问者模式</strong></p><h1 id="三、网络编程"><a href="#三、网络编程" class="headerlink" title="三、网络编程"></a>三、网络编程</h1><h2 id="1、阻塞"><a href="#1、阻塞" class="headerlink" title="1、阻塞"></a>1、阻塞</h2><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li><p>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上</p><p>下文切换导致性能降低</p></li><li><p>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池</p><p>中所有线程，因此不适合长连接，只适合短连接</p></li></ul></li></ul><p><strong>服务端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Server &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建缓冲区        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            &#x2F;&#x2F; 为服务器通道绑定端口            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 用户存放连接的集合            ArrayList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 循环接收连接            while (true) &#123;                System.out.println(&quot;before connecting...&quot;);                &#x2F;&#x2F; 没有连接时，会阻塞线程                SocketChannel socketChannel &#x3D; server.accept();                System.out.println(&quot;after connecting...&quot;);                channels.add(socketChannel);                &#x2F;&#x2F; 循环遍历集合中的连接                for(SocketChannel channel : channels) &#123;                    System.out.println(&quot;before reading&quot;);                    &#x2F;&#x2F; 处理通道中的数据                    &#x2F;&#x2F; 当通道中没有数据可读时，会阻塞线程                    channel.read(buffer);                    buffer.flip();                    ByteBufferUtil.debugRead(buffer);                    buffer.clear();                    System.out.println(&quot;after reading&quot;);                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码，debug模式启动，端点打在简历连接之后</p><pre class="line-numbers language-none"><code class="language-none">public class Client &#123;    public static void main(String[] args) &#123;        try (SocketChannel socketChannel &#x3D; SocketChannel.open()) &#123;            &#x2F;&#x2F; 建立连接            socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));            System.out.println(&quot;waiting...&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><ul><li>客户端-服务器建立连接前：服务器端因accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png" alt="img"></a></p><ul><li>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png" alt="img"></a></p><ul><li>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png" alt="img"></a></p><ul><li>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png" alt="img"></a></p><p>使用Idea的<img src="D:\Programs\InterviewNotes\image-20210928111407802.png" alt="image-20210928111407802">完成调试<img src="D:\Programs\InterviewNotes\image-20210928112019578.png" alt="image-20210928112019578"></p><p><strong>模拟多个客户端</strong></p><p>首先需要让客户端支持开启多个</p><p><img src="D:\Programs\InterviewNotes\image-20210928113624674.png" alt="image-20210928113624674"></p><p>支持并行开启</p><p><img src="D:\Programs\InterviewNotes\image-20210928113200237.png" alt="image-20210928113200237"></p><p>设置完成之后多次启动客户端即可</p><h2 id="2、非阻塞"><a href="#2、非阻塞" class="headerlink" title="2、非阻塞"></a>2、非阻塞</h2><p>不会使线程停止</p><ul><li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li><li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li></ul><p>服务器代码如下</p><pre class="line-numbers language-none"><code class="language-none">public class Server &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建缓冲区        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            &#x2F;&#x2F; 为服务器通道绑定端口            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 用户存放连接的集合            ArrayList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 循环接收连接            while (true) &#123;                &#x2F;&#x2F; 设置为非阻塞模式，没有连接时返回null，不会阻塞线程                server.configureBlocking(false);                SocketChannel socketChannel &#x3D; server.accept();                &#x2F;&#x2F; 通道不为空时才将连接放入到集合中                if (socketChannel !&#x3D; null) &#123;                    System.out.println(&quot;after connecting...&quot;);                    channels.add(socketChannel);                &#125;                &#x2F;&#x2F; 循环遍历集合中的连接                for(SocketChannel channel : channels) &#123;                    &#x2F;&#x2F; 处理通道中的数据                    &#x2F;&#x2F; 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程                    channel.configureBlocking(false);                    int read &#x3D; channel.read(buffer);                    if(read &gt; 0) &#123;                        buffer.flip();                        ByteBufferUtil.debugRead(buffer);                        buffer.clear();                        System.out.println(&quot;after reading&quot;);                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p><h2 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><p><strong>水平触发</strong></p><p>待补充。。。。。 </p><h3 id="绑定Channel事件"><a href="#绑定Channel事件" class="headerlink" title="绑定Channel事件"></a>绑定Channel事件</h3><p>也称之为注册事件，绑定的事件selector才会关心</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">channe1<span class="token punctuation">.</span><span class="token function">configureB1ocking</span><span class="token punctuation">(</span>fa1se<span class="token punctuation">)</span><span class="token punctuation">;</span>selectionKey key <span class="token operator">=</span> channe7<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector，绑定事件<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>channel必须工作在非阻塞模式</li><li>FileChannel没有非阻塞模式，因此不能配合selector一起使用·</li><li>绑定的事件类型可以有<ul><li>connect-客户端连接成功时触发</li><li>accept-服务器端成功接受连接时触发</li><li>read -数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write -数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h3 id="监听Channel事件"><a href="#监听Channel事件" class="headerlink" title="监听Channel事件"></a>监听Channel事件</h3><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少channel发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> selector <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法2，阻塞直到绑定事件发生，或是超时(时间单位为ms)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> selector <span class="token punctuation">.</span>select <span class="token punctuation">(</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> selector <span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="select何时不阻塞"><a href="#select何时不阻塞" class="headerlink" title="select何时不阻塞"></a>select何时不阻塞</h3><blockquote><ul><li><p>事件发生时</p><ul><li>客户端发起连接请求，会触发accept事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发read事件，另外如果发送的数据大于buffer缓冲区，会触发多次读取事件</li><li>channel可写，会触发write 事件。</li><li>在linux 下nio bug 发生时</li></ul></li><li><p>调用selector.wakeup()</p></li><li><p>调用selector.close()</p></li><li><p>selector所在线程interrupt</p></li></ul></blockquote><h2 id="4、处理Accpet事件"><a href="#4、处理Accpet事件" class="headerlink" title="4、处理Accpet事件"></a>4、处理Accpet事件</h2><p>要使用Selector实现多路复用，服务端代码如下改进</p><pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 创建选择器            Selector selector &#x3D; Selector.open();                        &#x2F;&#x2F; 通道必须设置为非阻塞模式            server.configureBlocking(false);            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的事件            server.register(selector, SelectionKey.OP_ACCEPT);            while (true) &#123;                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转                &#x2F;&#x2F; 返回值为就绪的事件个数                int ready &#x3D; selector.select();                System.out.println(&quot;selector ready counts : &quot; + ready);                                &#x2F;&#x2F; 获取所有事件                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                                &#x2F;&#x2F; 使用迭代器遍历事件                &#x2F;&#x2F;如果想在遍历过程中删除元素，就使用迭代器                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                                        &#x2F;&#x2F; 判断key的类型                    if(key.isAcceptable()) &#123;                        &#x2F;&#x2F; 获得key对应的channel                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();                        System.out.println(&quot;before accepting...&quot;);                                &#x2F;&#x2F; 获取连接并处理，而且是必须处理，否则需要取消                        SocketChannel socketChannel &#x3D; channel.accept();                        System.out.println(&quot;after accepting...&quot;);                                                &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤解析</strong></p><ul><li>获得选择器Selector</li></ul><pre class="line-numbers language-none"><code class="language-none">Selector selector &#x3D; Selector.open();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>将通道设置为非阻塞模式，并注册到选择器中，并设置感兴趣的事件</p><ul><li><p>channel 必须工作在非阻塞模式</p></li><li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p></li><li><p>绑定的事件类型可以有</p><ul><li>connect - 客户端连接成功时触发</li></ul></li></ul></li><li><p>accept - 服务器端成功接受连接时触发</p><ul><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li></ul></li><li><p>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通道必须设置为非阻塞模式server.configureBlocking(false);&#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的实践server.register(selector, SelectionKey.OP_ACCEPT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p><ul><li><p>阻塞直到绑定事件发生</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.select();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.select(long timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.selectNow();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取所有事件Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                &#x2F;&#x2F; 使用迭代器遍历事件Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();while (iterator.hasNext()) &#123;SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 判断key的类型，此处为Accept类型if(key.isAcceptable()) &#123;        &#x2F;&#x2F; 获得key对应的channel        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();        &#x2F;&#x2F; 获取连接并处理，而且是必须处理，否则需要取消，不然程序会空转        SocketChannel socketChannel &#x3D; channel.accept();        &#x2F;&#x2F; 处理完毕后移除        iterator.remove();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事件发生后能否不处理</strong></p><p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p><h2 id="5、处理Read事件"><a href="#5、处理Read事件" class="headerlink" title="5、处理Read事件"></a>5、处理Read事件</h2><ul><li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li><li>添加Read事件，触发后进行读取操作</li></ul><p>这里代码可以去掉iterator.remove();再跑，看一看会出现什么错误，并试着分析一下为什么会出现这个情况</p><pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 创建选择器            Selector selector &#x3D; Selector.open();            &#x2F;&#x2F; 通道必须设置为非阻塞模式            server.configureBlocking(false);            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的实践            server.register(selector, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 为serverKey设置感兴趣的事件            while (true) &#123;                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转                &#x2F;&#x2F; 返回值为就绪的事件个数                int ready &#x3D; selector.select();                System.out.println(&quot;selector ready counts : &quot; + ready);                &#x2F;&#x2F; 获取所有事件                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                &#x2F;&#x2F; 使用迭代器遍历事件                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 判断key的类型                    if(key.isAcceptable()) &#123;                        &#x2F;&#x2F; 获得key对应的channel                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();                        System.out.println(&quot;before accepting...&quot;);                        &#x2F;&#x2F; 获取连接                        SocketChannel socketChannel &#x3D; channel.accept();                        System.out.println(&quot;after accepting...&quot;);                        &#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中                        socketChannel.configureBlocking(false);                        socketChannel.register(selector, SelectionKey.OP_READ);                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125; else if (key.isReadable()) &#123;                        SocketChannel channel &#x3D; (SocketChannel) key.channel();                        System.out.println(&quot;before reading...&quot;);                        channel.read(buffer);                        System.out.println(&quot;after reading...&quot;);                        buffer.flip();                        ByteBufferUtil.debugRead(buffer);                        buffer.clear();                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除事件</strong></p><p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p><p>以我们上面的 <strong>Read事件</strong> 的代码为例</p><ul><li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道Channel</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; WindowsSelectorImpl 中的 SelectionKeyImpl数组private SelectionKeyImpl[] channelArray &#x3D; new SelectionKeyImpl[8];Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class SelectionKeyImpl extends AbstractSelectionKey &#123;    &#x2F;&#x2F; Key对应的通道    final SelChImpl channel;    ...&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png" alt="img"></a></p></li><li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png" alt="img"></a></p></li></ul><h3 id="断开处理"><a href="#断开处理" class="headerlink" title="断开处理"></a>断开处理</h3><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>（及程序会进入到下面的事件判断），对异常断开和正常断开需要加</p><p>以不同的方式进行处理</p><ul><li><p><strong>正常断开</strong></p><ul><li><p>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，此时表示客户端那边断开了（正常断开或者非正常断开），<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong>。</p><pre class="line-numbers language-none"><code class="language-none">int read &#x3D; channel.read(buffer);&#x2F;&#x2F; 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1if(read &#x3D;&#x3D; -1) &#123;    &#x2F;&#x2F; 取消该事件的处理key.cancel();    channel.close();&#125; else &#123;    ...&#125;&#x2F;&#x2F; 取消或者处理，都需要移除keyiterator.remove();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>异常断开</p><ul><li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li></ul></li></ul><h3 id="消息边界-重点"><a href="#消息边界-重点" class="headerlink" title="消息边界(重点)"></a>消息边界(重点)</h3><p><strong>不处理消息边界存在的问题</strong></p><p>将缓冲区的大小设置为4个字节，发送2个汉字（你好），通过decode解码并打印时，会出现乱码</p><pre class="line-numbers language-none"><code class="language-none">ByteBuffer buffer &#x3D; ByteBuffer.allocate(4);&#x2F;&#x2F; 解码并打印System.out.println(StandardCharsets.UTF_8.decode(buffer));你���<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为UTF-8字符集下，1个汉字占用3个字节，此时缓冲区大小为4个字节，<strong>一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件</strong>。这就导致 <code>你好</code> 的 <code>好</code> 字被拆分为了前半部分和后半部分发送，解码时就会出现问题</p><p><strong>处理消息边界</strong></p><p>传输的文本可能有以下三种情况</p><ul><li>文本大于缓冲区大小<ul><li>此时需要将缓冲区进行扩容</li></ul></li><li>发生半包现象</li><li>发生粘包现象</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png" alt="img"></a></p><p>解决思路大致有以下三种</p><ul><li><p><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p></li><li><p>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</p></li><li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据（也就是在消息开头用一些空间存放后面数据的长度），如HTTP请求头中的</p><p>Content-Type与Content-Length。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提</p><p>前分配，如果内容过大，则影响 server 吞吐量</p><ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png" alt="img"></a></li></ul></li></ul><p>下文的消息边界处理方式为<strong>第二种：按分隔符拆分</strong></p><p><strong>附件与扩容</strong></p><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p><pre class="line-numbers language-none"><code class="language-none">public final SelectionKey register(Selector sel, int ops, Object att)Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p><pre class="line-numbers language-none"><code class="language-none">ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件socketChannel.configureBlocking(false);ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);&#x2F;&#x2F; 添加通道对应的Buffer附件socketChannel.register(selector, SelectionKey.OP_READ, buffer);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 如果缓冲区太小，就进行扩容if (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;    ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity()*2);    &#x2F;&#x2F; 将旧buffer中的内容放入新的buffer中    ewBuffer.put(buffer);    &#x2F;&#x2F; 将新buffer作为附件放到key中    key.attach(newBuffer);&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>改造后的服务器代码如下</strong></p><pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 创建选择器            Selector selector &#x3D; Selector.open();            &#x2F;&#x2F; 通道必须设置为非阻塞模式            server.configureBlocking(false);            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的事件            server.register(selector, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 为serverKey设置感兴趣的事件            while (true) &#123;                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转                &#x2F;&#x2F; 返回值为就绪的事件个数                int ready &#x3D; selector.select();                System.out.println(&quot;selector ready counts : &quot; + ready);                &#x2F;&#x2F; 获取所有事件                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                &#x2F;&#x2F; 使用迭代器遍历事件                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 判断key的类型                    if(key.isAcceptable()) &#123;                        &#x2F;&#x2F; 获得key对应的channel                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();                        System.out.println(&quot;before accepting...&quot;);                        &#x2F;&#x2F; 获取连接                        SocketChannel socketChannel &#x3D; channel.accept();                        System.out.println(&quot;after accepting...&quot;);                        &#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件                        socketChannel.configureBlocking(false);                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);                        socketChannel.register(selector, SelectionKey.OP_READ, buffer);                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125; else if (key.isReadable()) &#123;                        SocketChannel channel &#x3D; (SocketChannel) key.channel();                        System.out.println(&quot;before reading...&quot;);                        &#x2F;&#x2F; 通过key获得附件（buffer）                        ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();                        int read &#x3D; channel.read(buffer);                        if(read &#x3D;&#x3D; -1) &#123;                            key.cancel();                            channel.close();                        &#125; else &#123;                            &#x2F;&#x2F; 通过分隔符来分隔buffer中的数据                            split(buffer);                            &#x2F;&#x2F; 如果缓冲区太小，就进行扩容，表示缓冲区中没有读到换行符，compact方法的position &#x3D;&#x3D; limit                            if (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;                                ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity()*2);                                &#x2F;&#x2F; 将旧buffer中的内容放入新的buffer中                                buffer.flip();                                newBuffer.put(buffer);                                &#x2F;&#x2F; 将新buffer放到key中作为附件                                key.attach(newBuffer);                            &#125;                        &#125;                        System.out.println(&quot;after reading...&quot;);                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    private static void split(ByteBuffer buffer) &#123;        buffer.flip();        for(int i &#x3D; 0; i &lt; buffer.limit(); i++) &#123;            &#x2F;&#x2F; 遍历寻找分隔符            &#x2F;&#x2F; get(i)不会移动position            if (buffer.get(i) &#x3D;&#x3D; &#39;\n&#39;) &#123;                &#x2F;&#x2F; 缓冲区长度                int length &#x3D; i+1-buffer.position();                ByteBuffer target &#x3D; ByteBuffer.allocate(length);                &#x2F;&#x2F; 将前面的内容写入target缓冲区                for(int j &#x3D; 0; j &lt; length; j++) &#123;                    &#x2F;&#x2F; 将buffer中的数据写入target中                    target.put(buffer.get());                &#125;                &#x2F;&#x2F; 打印结果                ByteBufferUtil.debugAll(target);            &#125;        &#125;        &#x2F;&#x2F; 切换为写模式，但是缓冲区可能未读完，这里需要使用compact        buffer.compact();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ByteBuffer的大小分配"><a href="#ByteBuffer的大小分配" class="headerlink" title="ByteBuffer的大小分配"></a>ByteBuffer的大小分配</h3><ul><li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li><li>分配思路可以参考<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul><li>参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li></ul></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h2 id="6、处理Write事件"><a href="#6、处理Write事件" class="headerlink" title="6、处理Write事件"></a>6、处理Write事件</h2><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到</strong></p><p><strong>Channel中，这时便需要分多次写入</strong>，具体步骤如下</p><ul><li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p></li><li><p>若Buffer中还有数据，则<strong>需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></p><pre class="line-numbers language-none"><code class="language-none"> int write &#x3D; socket.write(buffer);&#x2F;&#x2F; 通道中可能无法放入缓冲区中的所有数据if (buffer.hasRemaining()) &#123;    &#x2F;&#x2F; 注册到Selector中，关注可写事件，并将buffer添加到key的附件中    socket.configureBlocking(false);    socket.register(selector, SelectionKey.OP_WRITE, buffer);&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作</p><ul><li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">SocketChannel socket &#x3D; (SocketChannel) key.channel();&#x2F;&#x2F; 获得bufferByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();&#x2F;&#x2F; 执行写操作int write &#x3D; socket.write(buffer);System.out.println(write);&#x2F;&#x2F; 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣if (!buffer.hasRemaining()) &#123;    key.attach(null);    key.interestOps(0);&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>整体代码如下</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">ServerSocketChannel</span> server <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            server<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 处理后就移除事件</span>                    iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 获得客户端的通道</span>                        <span class="token class-name">SocketChannel</span> socket <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 写入数据</span>                        <span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 先执行一次Buffer->Channel的写入，如果未写完，就添加一个可写事件</span>                        <span class="token keyword">int</span> write <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>write<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 通道中可能无法放入缓冲区中的所有数据</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span>                            socket<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            socket<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">SocketChannel</span> socket <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 获得buffer</span>                        <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 执行写操作</span>                        <span class="token keyword">int</span> write <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>write<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            key<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteClient</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> <span class="token class-name">SocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketChannel<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">+=</span>socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、优化"><a href="#7、优化" class="headerlink" title="7、优化"></a>7、优化</h2><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>充分利用多核CPU，分两组选择器</p><ul><li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li><li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p></li><li><p><strong>Boss线程</strong>执行的操作</p><ul><li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建固定数量的WorkerWorker[] workers &#x3D; new Worker[4];&#x2F;&#x2F; 用于负载均衡的原子整数AtomicInteger robin &#x3D; new AtomicInteger(0);&#x2F;&#x2F; 负载均衡，轮询分配Workerworkers[robin.getAndIncrement()% workers.length].register(socket);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p><pre class="line-numbers language-none"><code class="language-none">public void register(final SocketChannel socket) throws IOException &#123;    &#x2F;&#x2F; 只启动一次    if (!started) &#123;       &#x2F;&#x2F; 初始化操作    &#125;    &#x2F;&#x2F; 向同步队列中添加SocketChannel的注册事件    &#x2F;&#x2F; 在Worker线程中执行注册事件    queue.add(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                socket.register(selector, SelectionKey.OP_READ);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    &#x2F;&#x2F; 唤醒被阻塞的Selector    &#x2F;&#x2F; select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark    selector.wakeup();&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>Worker线程执行</strong>的操作</p><ul><li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li></ul></li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre class="line-numbers language-none"><code class="language-none">public class ThreadsServer &#123;    public static void main(String[] args) &#123;        try (ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            &#x2F;&#x2F; 当前线程为Boss线程            Thread.currentThread().setName(&quot;Boss&quot;);            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 负责轮询Accept事件的Selector            Selector boss &#x3D; Selector.open();            server.configureBlocking(false);            server.register(boss, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 创建固定数量的Worker            Worker[] workers &#x3D; new Worker[4];            &#x2F;&#x2F; 用于负载均衡的原子整数            AtomicInteger robin &#x3D; new AtomicInteger(0);            for(int i &#x3D; 0; i &lt; workers.length; i++) &#123;                workers[i] &#x3D; new Worker(&quot;worker-&quot;+i);            &#125;            while (true) &#123;                boss.select();                Set&lt;SelectionKey&gt; selectionKeys &#x3D; boss.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    iterator.remove();                    &#x2F;&#x2F; BossSelector负责Accept事件                    if (key.isAcceptable()) &#123;                        &#x2F;&#x2F; 建立连接                        SocketChannel socket &#x3D; server.accept();                        System.out.println(&quot;connected...&quot;);                        socket.configureBlocking(false);                        &#x2F;&#x2F; socket注册到Worker的Selector中                        System.out.println(&quot;before read...&quot;);                        &#x2F;&#x2F; 负载均衡，轮询分配Worker                        workers[robin.getAndIncrement()% workers.length].register(socket);                        System.out.println(&quot;after read...&quot;);                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    static class Worker implements Runnable &#123;        private Thread thread;        private volatile Selector selector;        private String name;        private volatile boolean started &#x3D; false;        &#x2F;**         * 同步队列，用于Boss线程与Worker线程之间的通信         *&#x2F;        private ConcurrentLinkedQueue&lt;Runnable&gt; queue;        public Worker(String name) &#123;            this.name &#x3D; name;        &#125;        public void register(final SocketChannel socket) throws IOException &#123;            &#x2F;&#x2F; 只启动一次            if (!started) &#123;                thread &#x3D; new Thread(this, name);                selector &#x3D; Selector.open();                queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();                thread.start();                started &#x3D; true;            &#125;                        &#x2F;&#x2F; 向同步队列中添加SocketChannel的注册事件            &#x2F;&#x2F; 在Worker线程中执行注册事件            queue.add(new Runnable() &#123;                @Override                public void run() &#123;                    try &#123;                        socket.register(selector, SelectionKey.OP_READ);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);            &#x2F;&#x2F; 唤醒被阻塞的Selector            &#x2F;&#x2F; select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark            selector.wakeup();        &#125;        @Override        public void run() &#123;            while (true) &#123;                try &#123;                    selector.select();                    &#x2F;&#x2F; 通过同步队列获得任务并运行                    Runnable task &#x3D; queue.poll();                    if (task !&#x3D; null) &#123;                        &#x2F;&#x2F; 获得任务，执行注册操作                        task.run();                    &#125;                    Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                    Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                    while(iterator.hasNext()) &#123;                        SelectionKey key &#x3D; iterator.next();                        iterator.remove();                        &#x2F;&#x2F; Worker只负责Read事件                        if (key.isReadable()) &#123;                            &#x2F;&#x2F; 简化处理，省略细节                            SocketChannel socket &#x3D; (SocketChannel) key.channel();                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);                            socket.read(buffer);                            buffer.flip();                            ByteBufferUtil.debugAll(buffer);                        &#125;                    &#125;                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、NIO与BIO"><a href="#四、NIO与BIO" class="headerlink" title="四、NIO与BIO"></a>四、NIO与BIO</h1><h2 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a>1、Stream与Channel</h2><ul><li><p>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</p></li><li><p>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></p></li><li><p>二者</p><p>均为全双工</p><p>，即读写可以同时进行</p><ul><li>虽然Stream是单向流动的，但是它也是全双工的</li></ul></li></ul><h2 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h2><ul><li><p>同步</p><p>：线程自己去获取结果（一个线程）</p><ul><li>例如：线程调用一个方法后，需要等待方法返回结果</li></ul></li><li><p>异步</p><p>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p><ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别</p><p>为：</p><ul><li><p>等待数据阶段</p></li><li><p>复制数据阶段</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png" alt="img"></a></p></li></ul><p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png" alt="img"></a></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png" alt="img"></a></p><ul><li><p>用户线程</p><p>在一个循环中一直调用read方法</p><p>，若内核空间中还没有数据可读，立即返回</p><ul><li><strong>只是在等待阶段非阻塞</strong></li></ul></li><li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p></li></ul><h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png" alt="img"></a></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件是，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li><li>及阻塞IO是代码驱动，多路复用是事件驱动</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png" alt="img"></a></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h2 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h3><p>传统的 IO 将一个文件通过 socket 写出</p><pre class="line-numbers language-none"><code class="language-none">File f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);RandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);byte[] buf &#x3D; new byte[(int)f.length()];file.read(buf);Socket socket &#x3D; ...;socket.getOutputStream().write(buf);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内部工作流如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png" alt="img"></a></p><ul><li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p></li><li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h3><p>通过 <strong>DirectByteBuf</strong></p><ul><li><p>ByteBuffer.allocate(10)</p><ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li><p>ByteBuffer.</p><p>allocateDirect</p><p>(10)</p><ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png" alt="img"></a></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a>进一步优化1</h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo/transferFrom</strong> 方法拷贝数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><h2 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a>4、AIO</h2><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/2021/11/29/netty/"/>
      <url>/2021/11/29/netty/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>本文转载自：<a href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#Netty">Netty</a></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><pre class="line-numbers language-none"><code class="language-none">Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如</p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><pre class="line-numbers language-none"><code class="language-none">public class HelloServer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器        new ServerBootstrap()                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector                .group(new NioEventLoopGroup())                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现                .channel(NioServerSocketChannel.class)                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作            &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）            &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                    @Override                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String                        nioSocketChannel.pipeline().addLast(new StringDecoder());                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;                            @Override                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;                                System.out.println(s);                            &#125;                        &#125;);                    &#125;                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口                &#125;).bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><pre class="line-numbers language-none"><code class="language-none">public class HelloClient &#123;    public static void main(String[] args) throws InterruptedException &#123;        new Bootstrap()                .group(new NioEventLoopGroup())                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现                .channel(NioSocketChannel.class)                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;                    @Override                    protected void initChannel(Channel channel) throws Exception &#123;                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出                        channel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                &#x2F;&#x2F; 指定要连接的服务器和端口                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕                .sync()                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作                .channel()                &#x2F;&#x2F; 写入消息并清空缓冲区                .writeAndFlush(&quot;hello world&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png" alt="img"></a></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li><p>channel 可以理解为数据的通道</p></li><li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p></li><li><p>handler 可以理解为数据的处理工序</p><ul><li><p>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p><ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li><p>handler 分 Inbound 和 Outbound 两类</p><ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li><p>eventLoop 可以理解为处理数据的工人</p><ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><pre class="line-numbers language-none"><code class="language-none">public class TestEventLoop &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop        System.out.println(group.next());        System.out.println(group.next());        &#x2F;&#x2F; 通过EventLoop执行普通任务        group.next().execute(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);        &#125;);        &#x2F;&#x2F; 通过EventLoop执行定时任务        group.next().scheduleAtFixedRate(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);        &#125;, 0, 1, TimeUnit.SECONDS);                &#x2F;&#x2F; 优雅地关闭        group.shutdownGracefully();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下</p><pre class="line-numbers language-none"><code class="language-none">io.netty.channel.nio.NioEventLoop@7bb11784io.netty.channel.nio.NioEventLoop@33a10788nioEventLoopGroup-2-1 hellonioEventLoopGroup-2-2 hello2nioEventLoopGroup-2-2 hello2nioEventLoopGroup-2-2 hello2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopServer &#123;    public static void main(String[] args) &#123;        new ServerBootstrap()                .group(new NioEventLoopGroup())                .channel(NioServerSocketChannel.class)                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                ByteBuf buf &#x3D; (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopClient &#123;    public static void main(String[] args) throws IOException, InterruptedException &#123;        Channel channel &#x3D; new Bootstrap()                .group(new NioEventLoopGroup())                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))                .sync()                .channel();        System.out.println(channel);        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);        System.in.read();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;    public static void main(String[] args) &#123;        new ServerBootstrap()            &#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))            ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个客户端分别发送 <code>hello</code> 结果</p><pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-3-1 hello1nioEventLoopGroup-3-2 hello2nioEventLoopGroup-3-1 hello3nioEventLoopGroup-3-2 hello4nioEventLoopGroup-3-2 hello4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件，并且根据轮询的形式保证每个EventLoop都有对应的Channel</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png" alt="img"></a></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();                new ServerBootstrap()                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))                .channel(NioServerSocketChannel.class)                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                ByteBuf buf &#x3D; (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));                                &#x2F;&#x2F; 调用下一个handler                                ctx.fireChannelRead(msg);                            &#125;                        &#125;)                        &#x2F;&#x2F; 该handler绑定自定义的Group                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                ByteBuf buf &#x3D; (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动四个客户端发送数据</p><pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-4-1 hello1defaultEventLoopGroup-2-1 hello1nioEventLoopGroup-4-2 hello2defaultEventLoopGroup-2-2 hello2nioEventLoopGroup-4-1 hello3defaultEventLoopGroup-2-3 hello3nioEventLoopGroup-4-2 hello4defaultEventLoopGroup-2-4 hello4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png" alt="img"></a></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><pre class="line-numbers language-none"><code class="language-none">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup    EventExecutor executor &#x3D; next.executor();        &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中    if (executor.inEventLoop()) &#123;        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务        next.invokeChannelRead(m);    &#125; else &#123;        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行        executor.execute(new Runnable() &#123;            public void run() &#123;                next.invokeChannelRead(m);            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class MyClient &#123;    public static void main(String[] args) throws IOException, InterruptedException &#123;        ChannelFuture channelFuture &#x3D; new Bootstrap()                .group(new NioEventLoopGroup())                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程            &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));                &#x2F;&#x2F; 阻塞住，该方法用于等待连接真正建立        &#x2F;&#x2F;不使用该方法会使当前线程继续向下执行，但是因为链接还未建立，导致下面的channel还没有链接，channel对象存在          channelFuture.sync();                &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象        Channel channel &#x3D; channelFuture.channel();        channel.writeAndFlush(&quot;hello world&quot;);        System.in.read();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><pre class="line-numbers language-none"><code class="language-none">public class MyClient &#123;    public static void main(String[] args) throws IOException, InterruptedException &#123;        ChannelFuture channelFuture &#x3D; new Bootstrap()                .group(new NioEventLoopGroup())                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        &#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法        channelFuture.addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;                Channel channel &#x3D; channelFuture.channel();                channel.writeAndFlush(&quot;hello world&quot;);            &#125;        &#125;);        System.in.read();    &#125;&#125;Cop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ReadClient &#123;    public static void main(String[] args) throws InterruptedException &#123;        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();                ChannelFuture channelFuture &#x3D; new Bootstrap()                .group(group)                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        channelFuture.sync();        Channel channel &#x3D; channelFuture.channel();        Scanner scanner &#x3D; new Scanner(System.in);        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送        new Thread(()-&gt;&#123;            while (true) &#123;                String msg &#x3D; scanner.next();                if (&quot;q&quot;.equals(msg)) &#123;                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行                    channel.close();                    break;                &#125;                channel.writeAndFlush(msg);            &#125;        &#125;, &quot;inputThread&quot;).start();        &#x2F;&#x2F; 获得closeFuture对象        ChannelFuture closeFuture &#x3D; channel.closeFuture();        System.out.println(&quot;waiting close...&quot;);                &#x2F;&#x2F; 同步等待NIO线程执行完close操作        &#x2F;&#x2F;sync()阻塞方法        closeFuture.sync();                &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);                &#x2F;&#x2F; 关闭EventLoopGroup        group.shutdownGracefully();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得closeFuture对象ChannelFuture closeFuture &#x3D; channel.closeFuture();&#x2F;&#x2F; 同步等待NIO线程执行完close操作closeFuture.sync();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><pre class="line-numbers language-none"><code class="language-none">closeFuture.addListener(new ChannelFutureListener() &#123;    @Override    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;        &#x2F;&#x2F; 等待channel关闭后才执行的操作        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);        &#x2F;&#x2F; 关闭EventLoopGroup        group.shutdownGracefully();    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>由此可以发现，netty中很多方法都是异步的，针对某些后续操作，不能想当然的在异步方法之后加一些内容，为了保证代码的正确执行，必须保证同步处理或者异步处理。</p><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><pre class="line-numbers language-none"><code class="language-none">public class JdkFuture &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        ThreadFactory factory &#x3D; new ThreadFactory() &#123;            @Override            public Thread newThread(Runnable r) &#123;                return new Thread(r, &quot;JdkFuture&quot;);            &#125;        &#125;;        &#x2F;&#x2F; 创建线程池        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);        &#x2F;&#x2F; 获得Future对象        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;            @Override            public Integer call() throws Exception &#123;                TimeUnit.SECONDS.sleep(1);                return 50;            &#125;        &#125;);        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果        System.out.println(future.get());    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><pre class="line-numbers language-none"><code class="language-none">public class NettyFuture &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        &#x2F;&#x2F; 获得 EventLoop 对象        EventLoop eventLoop &#x3D; group.next();        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;            @Override            public Integer call() throws Exception &#123;                return 50;            &#125;        &#125;);        &#x2F;&#x2F; 主线程中获取结果        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);        System.out.println(&quot;getNow &quot; + future.getNow());        System.out.println(&quot;get &quot; + future.get());        &#x2F;&#x2F; NIO线程中异步获取结果        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;            @Override            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);                System.out.println(&quot;getNow &quot; + future.getNow());            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">main 获取结果getNow nullget 50nioEventLoopGroup-2-1 获取结果getNow 50  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><pre class="line-numbers language-none"><code class="language-none">public class NettyPromise &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        &#x2F;&#x2F; 创建EventLoop        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        EventLoop eventLoop &#x3D; group.next();        &#x2F;&#x2F; 创建Promise对象，用于存放结果        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);        new Thread(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            &#x2F;&#x2F; 自定义线程向Promise中存放结果            promise.setSuccess(50);        &#125;).start();        &#x2F;&#x2F; 主线程从Promise中获取结果        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><pre class="line-numbers language-none"><code class="language-none">public class PipeLineServer &#123;    public static void main(String[] args) &#123;        new ServerBootstrap()                .group(new NioEventLoopGroup())                .channel(NioServerSocketChannel.class)                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为     &#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法                        &#x2F;&#x2F; 入站时，handler是从head向后调用的                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead                                &#x2F;&#x2F; 将数据传递给下一个handler                                super.channelRead(ctx, msg);                            &#125;                        &#125;);                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));                                super.channelRead(ctx, msg);                            &#125;                        &#125;);                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;                            @Override                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);                                super.write(ctx, msg, promise);                            &#125;                        &#125;);                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;                            @Override                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);                                super.write(ctx, msg, promise);                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果如下</strong></p><pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-2-2 Inbound handler 1nioEventLoopGroup-2-2 Inbound handler 2nioEventLoopGroup-2-2 Outbound handler 2nioEventLoopGroup-2-2 Outbound handler 1  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png" alt="img"></a></p><p><strong>调用顺序如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png" alt="img"></a></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" alt="img"></a></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" alt="img"></a></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><pre class="line-numbers language-none"><code class="language-none">public class TestEmbeddedChannel &#123;    public static void main(String[] args) &#123;        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;            @Override            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                System.out.println(&quot;1&quot;);                super.channelRead(ctx, msg);            &#125;        &#125;;        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;            @Override            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                System.out.println(&quot;2&quot;);                super.channelRead(ctx, msg);            &#125;        &#125;;        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;            @Override            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                System.out.println(&quot;3&quot;);                super.write(ctx, msg, promise);            &#125;        &#125;;        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;            @Override            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                System.out.println(&quot;4&quot;);                super.write(ctx, msg, promise);            &#125;        &#125;;        &#x2F;&#x2F; 用于测试Handler的Channel        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);                &#x2F;&#x2F; 执行Inbound操作         channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));        &#x2F;&#x2F; 执行Outbound操作        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void log(ByteBuf buffer) &#123;    int length &#x3D; buffer.readableBytes();    int rows &#x3D; length &#x2F; 16 + (length % 15 &#x3D;&#x3D; 0 ? 0 : 1) + 4;    StringBuilder buf &#x3D; new StringBuilder(rows * 80 * 2)        .append(&quot;read index:&quot;).append(buffer.readerIndex())        .append(&quot; write index:&quot;).append(buffer.writerIndex())        .append(&quot; capacity:&quot;).append(buffer.capacity())        .append(NEWLINE);    appendPrettyHexDump(buf, buffer);    System.out.println(buf.toString());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 向buffer中写入数据        StringBuilder sb &#x3D; new StringBuilder();        for(int i &#x3D; 0; i &lt; 20; i++) &#123;            sb.append(&quot;a&quot;);        &#125;        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));        &#x2F;&#x2F; 查看写入结果        ByteBufUtil.log(buffer);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">read index:0 write index:0 capacity:16read index:0 write index:20 capacity:64         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa||00000010| 61 61 61 61                                     |aaaa            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);        System.out.println(buffer.getClass());        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);        System.out.println(buffer.getClass());        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);        System.out.println(buffer.getClass());    &#125;&#125;&#x2F;&#x2F; 使用池化的直接内存class io.netty.buffer.PooledUnsafeDirectByteBuf    &#x2F;&#x2F; 使用池化的堆内存    class io.netty.buffer.PooledUnsafeHeapByteBuf    &#x2F;&#x2F; 使用池化的直接内存    class io.netty.buffer.PooledUnsafeDirectByteBuf  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可<strong>以通过下面的系统环境变量来设置，也可以作为虚拟机参数传入</strong>。</p><pre class="line-numbers language-none"><code class="language-none">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png" alt="img"></a></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类（如Stringbuilder）的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 向buffer中写入数据        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);        ByteBufUtil.log(buffer);        buffer.writeInt(5);        ByteBufUtil.log(buffer);        buffer.writeIntLE(6);        ByteBufUtil.log(buffer);        buffer.writeLong(7);        ByteBufUtil.log(buffer);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">read index:0 write index:0 capacity:16read index:0 write index:4 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04                                     |....            |+--------+-------------------------------------------------+----------------+read index:0 write index:8 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05                         |........        |+--------+-------------------------------------------------+----------------+read index:0 write index:12 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |+--------+-------------------------------------------------+----------------+read index:0 write index:20 capacity:20         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................||00000010| 00 00 00 07                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><pre class="line-numbers language-none"><code class="language-none">buffer.writeLong(7);ByteBufUtil.log(buffer);  &#x2F;&#x2F; 扩容前read index:0 write index:12 capacity:16...&#x2F;&#x2F; 扩容后read index:0 write index:20 capacity:20         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................||00000010| 00 00 00 07                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p><ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p><p>n</p><ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li></ul></li><li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p></li></ul><pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);        &#x2F;&#x2F; 向buffer中写入数据        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);        buffer.writeInt(5);        &#x2F;&#x2F; 读取4个字节        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 通过mark与reset实现重复读取        buffer.markReaderIndex();        System.out.println(buffer.readInt());        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 恢复到mark标记处        buffer.resetReaderIndex();        ByteBufUtil.log(buffer);    &#125;&#125;1234read index:4 write index:8 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 00 00 05                                     |....            |+--------+-------------------------------------------------+----------------+5read index:8 write index:8 capacity:16read index:4 write index:8 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 00 00 05                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收，放在其他人误调用release 把计数值减为0</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><pre class="line-numbers language-none"><code class="language-none">while (!buffer.release()) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><pre class="line-numbers language-none"><code class="language-none">protected void onUnhandledInboundMessage(Object msg) &#123;    try &#123;        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);    &#125; finally &#123;        &#x2F;&#x2F; 具体的释放方法        ReferenceCountUtil.release(msg);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><pre class="line-numbers language-none"><code class="language-none">public static boolean release(Object msg) &#123;return msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>HeadContext</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HeadContext</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractChannelHandlerContext</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelOutboundHandler</span><span class="token punctuation">,</span> <span class="token class-name">ChannelInboundHandler</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看见出HeadContext实现了ChannelOutboundHandler, ChannelInboundHandler接口，表示可以作为出站和入站。及从Head进Tail出，或者从Head进Head出</p><p><img src="D:\Programs\InterviewNotes\image-20211007194810701.png" alt="image-20211007194810701"></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png" alt="img"></a></p><pre class="line-numbers language-none"><code class="language-none">public class TestSlice &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);        &#x2F;&#x2F; 向buffer中写入数据        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);        &#x2F;&#x2F; 将buffer分成两部分        ByteBuf slice1 &#x3D; buffer.slice(0, 5);        ByteBuf slice2 &#x3D; buffer.slice(5, 5);        &#x2F;&#x2F; 需要让分片的buffer引用计数加一        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用        slice1.retain();        slice2.retain();                ByteBufUtil.log(slice1);        ByteBufUtil.log(slice2);        &#x2F;&#x2F; 更改原始buffer中的值        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        buffer.setByte(0,5);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        ByteBufUtil.log(slice1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">read index:0 write index:5 capacity:5         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 05                                  |.....           |+--------+-------------------------------------------------+----------------+read index:0 write index:5 capacity:5         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 06 07 08 09 0a                                  |.....           |+--------+-------------------------------------------------+----------------+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;read index:0 write index:5 capacity:5         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 05 02 03 04 05                                  |.....           |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><pre class="line-numbers language-none"><code class="language-none">public class StudyServer &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);    void start() &#123;        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        try &#123;            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.group(boss, worker);            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) &#123;                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                        @Override                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;                            &#x2F;&#x2F; 连接建立时会执行该方法，触发active事件                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());                            super.channelActive(ctx);                        &#125;                        @Override                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;                            &#x2F;&#x2F; 连接断开时会执行该方法                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());                            super.channelInactive(ctx);                        &#125;                    &#125;);                &#125;            &#125;);            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());            channelFuture.sync();            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());            &#x2F;&#x2F; 关闭channel            channelFuture.channel().closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            log.error(&quot;server error&quot;, e);        &#125; finally &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();            log.debug(&quot;stopped&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        new StudyServer().start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class StudyClient &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(StudyClient.class);    public static void main(String[] args) &#123;        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        try &#123;            Bootstrap bootstrap &#x3D; new Bootstrap();            bootstrap.channel(NioSocketChannel.class);            bootstrap.group(worker);            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    log.debug(&quot;connected...&quot;);                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                        @Override                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;                            log.debug(&quot;sending...&quot;);                            &#x2F;&#x2F; 每次发送16个字节的数据，共发送10次                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                                ByteBuf buffer &#x3D; ctx.alloc().buffer();                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);                                ctx.writeAndFlush(buffer);                            &#125;                        &#125;                    &#125;);                &#125;            &#125;);            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();            channelFuture.channel().closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            log.error(&quot;client error&quot;, e);        &#125; finally &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器接收结果</strong></p><pre class="line-numbers language-none"><code class="language-none">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:53797] READ: 160B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调整channel的容量serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><pre class="line-numbers language-none"><code class="language-none">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 36B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000020| 00 01 02 03                                     |....            |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000020| 04 05 06 07 08 09 0a 0b                         |........        |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................||00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................||00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000020| 04 05 06 07 08 09 0a 0b                         |........        |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 4B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 0c 0d 0e 0f                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><pre class="line-numbers language-none"><code class="language-none">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;    log.debug(&quot;sending...&quot;);    ByteBuf buffer &#x3D; ctx.alloc().buffer(16);    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);    ctx.writeAndFlush(buffer);    &#x2F;&#x2F; 使用短链接，每次发送完毕后就断开连接    ctx.channel().close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    &#x2F;&#x2F; 发送10次    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        send();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] ACTIVE6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|+--------+-------------------------------------------------+----------------+6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65024] INACTIVE6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] ACTIVE6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|+--------+-------------------------------------------------+----------------+6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65057] INACTIVE...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><pre class="line-numbers language-none"><code class="language-none">ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 约定最大长度为16final int maxLength &#x3D; 16;&#x2F;&#x2F; 被发送的数据char c &#x3D; &#39;a&#39;;&#x2F;&#x2F; 向服务器发送10个报文for (int i &#x3D; 0; i &lt; 10; i++) &#123;    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);    &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充    byte[] bytes &#x3D; new byte[maxLength];    &#x2F;&#x2F; 生成长度为0~15的数据    for (int j &#x3D; 0; j &lt; (int)(Math.random()*(maxLength-1)); j++) &#123;        bytes[j] &#x3D; (byte) c;    &#125;    buffer.writeBytes(bytes);    c++;    &#x2F;&#x2F; 将数据发送给服务器    ctx.writeAndFlush(buffer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过定长解码器对粘包数据进行拆分ch.pipeline().addLast(new FixedLengthFrameDecoder(16));ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|+--------+-------------------------------------------------+----------------+8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|+--------+-------------------------------------------------+----------------+8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|+--------+-------------------------------------------------+----------------+...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 约定最大长度为 64final int maxLength &#x3D; 64;&#x2F;&#x2F; 被发送的数据char c &#x3D; &#39;a&#39;;for (int i &#x3D; 0; i &lt; 10; i++) &#123;    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);    &#x2F;&#x2F; 生成长度为0~62的数据    Random random &#x3D; new Random();    StringBuilder sb &#x3D; new StringBuilder();    for (int j &#x3D; 0; j &lt; (int)(random.nextInt(maxLength-2)); j++) &#123;        sb.append(c);    &#125;    &#x2F;&#x2F; 数据以 \n 结尾    sb.append(&quot;\n&quot;);    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));    c++;    &#x2F;&#x2F; 将数据发送给服务器    ctx.writeAndFlush(buffer);&#125;或者    public static StringBuilder makeString(char c, int len) &#123;        StringBuilder sb &#x3D; new StringBuilder(len + 2);        for (int i &#x3D; 0; i &lt; len; i++) &#123;            sb.append(c);        &#125;        sb.append(&quot;\n&quot;);        return sb;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \n 为分隔符&#x2F;&#x2F; 需要指定最大长度ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 10B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |+--------+-------------------------------------------------+----------------+4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 11B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |+--------+-------------------------------------------------+----------------+4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 2B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 63                                           |cc              |+--------+-------------------------------------------------+----------------+...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><pre class="line-numbers language-none"><code class="language-none">...    &#x2F;&#x2F; 数据以 \c 结尾sb.append(&quot;\\c&quot;);buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将分隔符放入ByteBuf中ByteBuf bufSet &#x3D; ch.alloc().buffer().writeBytes(&quot;\\c&quot;.getBytes(StandardCharsets.UTF_8));&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \c 为分隔符ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 14B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |+--------+-------------------------------------------------+----------------+8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 3B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 62 62 62                                        |bbb             |+--------+-------------------------------------------------+----------------+...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><pre class="line-numbers language-none"><code class="language-none">public LengthFieldBasedFrameDecoder(    int maxFrameLength,    int lengthFieldOffset, int lengthFieldLength,    int lengthAdjustment, int initialBytesToStrip)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png" alt="img"></a></p><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0lengthFieldLength   &#x3D; 2lengthAdjustment    &#x3D; 0initialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)  BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)+--------+----------------+      +--------+----------------+| Length | Actual Content |-----&gt;| Length | Actual Content || 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |+--------+----------------+      +--------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0lengthFieldLength   &#x3D; 2lengthAdjustment    &#x3D; 0initialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)  BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)+--------+----------------+      +----------------+| Length | Actual Content |-----&gt;| Actual Content || 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |+--------+----------------+      +----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)lengthFieldLength   &#x3D; 3lengthAdjustment    &#x3D; 0initialBytesToStrip &#x3D; 0  BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)+----------+----------+----------------+      +----------+----------+----------------+| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content ||  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |+----------+----------+----------------+      +----------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0lengthFieldLength   &#x3D; 3lengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)initialBytesToStrip &#x3D; 0  BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)+----------+----------+----------------+      +----------+----------+----------------+|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content || 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |+----------+----------+----------------+      +----------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)lengthFieldLength   &#x3D; 2lengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)initialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)  BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)+------+--------+------+----------------+      +------+----------------+| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content || 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |+------+--------+------+----------------+      +------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><pre class="line-numbers language-none"><code class="language-none">public class EncoderStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 模拟服务器        &#x2F;&#x2F; 使用EmbeddedChannel测试handler        EmbeddedChannel channel &#x3D; new EmbeddedChannel(                &#x2F;&#x2F; 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 0),                new LoggingHandler(LogLevel.DEBUG)        );        &#x2F;&#x2F; 模拟客户端，写入数据        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();        send(buffer, &quot;Hello&quot;);        channel.writeInbound(buffer);        send(buffer, &quot;World&quot;);        channel.writeInbound(buffer);    &#125;    private static void send(ByteBuf buf, String msg) &#123;        &#x2F;&#x2F; 得到数据的长度        int length &#x3D; msg.length();        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);        &#x2F;&#x2F; 将数据信息写入buf        &#x2F;&#x2F; 写入长度标识前的其他信息        buf.writeByte(0xCA);        &#x2F;&#x2F; 写入数据长度标识        buf.writeInt(length);        &#x2F;&#x2F; 写入长度标识后的其他信息        buf.writeByte(0xFE);        &#x2F;&#x2F; 写入具体的数据        buf.writeBytes(bytes);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |+--------+-------------------------------------------------+----------------+146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><p>Netty提供了很多协议的支持。</p><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 该指令一共有3部分，每条指令之后都要添加回车与换行符*3\r\n&#x2F;&#x2F; 第一个指令的长度是3$3\r\n&#x2F;&#x2F; 第一个指令是set指令set\r\n&#x2F;&#x2F; 下面的指令以此类推$4\r\nname\r\n$5\r\nNyima\r\n  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>客户端代码如下</strong></p><pre class="line-numbers language-none"><code class="language-none">@Slf4jpublic class RedisClient &#123;       public static void main(String[] args) &#123;        NioEventLoopGroup group &#x3D;  new NioEventLoopGroup();        try &#123;            ChannelFuture channelFuture &#x3D; new Bootstrap()                    .group(group)                    .channel(NioSocketChannel.class)                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) &#123;                            &#x2F;&#x2F; 打印日志                            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                                @Override                                public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;                                    &#x2F;&#x2F; 回车与换行符                                    final byte[] LINE &#x3D; &#123;&#39;\r&#39;,&#39;\n&#39;&#125;;                                    &#x2F;&#x2F; 获得ByteBuf                                    ByteBuf buffer &#x3D; ctx.alloc().buffer();                                    &#x2F;&#x2F; 连接建立后，向Redis中发送一条指令，注意添加回车与换行                                    &#x2F;&#x2F; set name Nyima                                    buffer.writeBytes(&quot;*3&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;$3&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;set&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;$4&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;name&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;$5&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;Nyima&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    ctx.writeAndFlush(buffer);                                &#125;                            &#125;);                        &#125;                    &#125;)                    .connect(new InetSocketAddress(&quot;localhost&quot;, 6379));            channelFuture.sync();            &#x2F;&#x2F; 关闭channel            channelFuture.channel().close().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 关闭group            group.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制台打印结果</strong></p><pre class="line-numbers language-none"><code class="language-none">[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0] REGISTERED[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0] CONNECT: &#x2F;127.0.0.1:6379[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] ACTIVE[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] WRITE: 32B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.||00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 77 7a 79 0d 0a |.name..$5..wzy..|+--------+-------------------------------------------------+----------------+[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] FLUSH[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] CLOSE[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 ! R:&#x2F;127.0.0.1:6379] INACTIVE[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 ! R:&#x2F;127.0.0.1:6379] UNREGISTERED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Redis中查询执行结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder&#x2F;&#x2F; Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器public final class HttpServerCodec extends CombinedChannelDuplexHandler&lt;HttpRequestDecoder, HttpResponseEncoder&gt;        implements HttpServerUpgradeHandler.SourceCodec  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NioEventLoopGroup</span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span>                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServerCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 服务器只处理HTTPRequest</span>                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleChannelInboundHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpRequest</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token annotation punctuation">@Override</span>                            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">HttpRequest</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 获得请求uri</span>                                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 获得完整响应，设置版本号与状态码</span>                                <span class="token class-name">DefaultFullHttpResponse</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFullHttpResponse</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">protocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpResponseStatus</span><span class="token punctuation">.</span>OK<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 设置响应内容</span>                                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token string">"&lt;h1>Hello, World!&lt;/h1>"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 设置响应体长度，避免浏览器一直接收响应内容</span>                                response<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span>CONTENT_LENGTH<span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 设置响应体</span>                                response<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeBytes</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 写回响应</span>                                ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 服务器只处理HTTPRequestch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得完整响应，设置版本号与状态码DefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);&#x2F;&#x2F; 设置响应内容byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);&#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容response.headers().setInt(CONTENT_LENGTH, bytes.length);&#x2F;&#x2F; 设置响应体response.content().writeBytes(bytes);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>浏览器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png" alt="img"></a></p><p>控制台</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 请求内容1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] READ: 688B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET &#x2F;favicon.ico||00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP&#x2F;1.1..Host:||00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.||00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee||00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|....&#x2F;&#x2F; 响应内容1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] WRITE: 61B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP&#x2F;1.1 200 OK.||00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:||00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello||00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;&#x2F;h1&gt;   |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;    @Override    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;        &#x2F;&#x2F; 设置魔数 4个字节        out.writeBytes(new byte[]&#123;&#39;N&#39;,&#39;Y&#39;,&#39;I&#39;,&#39;M&#39;&#125;);        &#x2F;&#x2F; 设置版本号 1个字节        out.writeByte(1);        &#x2F;&#x2F; 设置序列化方式 1个字节        out.writeByte(1);        &#x2F;&#x2F; 设置指令类型 1个字节        out.writeByte(msg.getMessageType());        &#x2F;&#x2F; 设置请求序号 4个字节        out.writeInt(msg.getSequenceId());        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据        out.writeByte(0xff);        &#x2F;&#x2F; 获得序列化后的msg        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);        oos.writeObject(msg);        byte[] bytes &#x3D; bos.toByteArray();        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识        out.writeInt(bytes.length);        &#x2F;&#x2F; 设置消息正文        out.writeBytes(bytes);    &#125;    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;        &#x2F;&#x2F; 获取魔数        int magic &#x3D; in.readInt();        &#x2F;&#x2F; 获取版本号        byte version &#x3D; in.readByte();        &#x2F;&#x2F; 获得序列化方式        byte seqType &#x3D; in.readByte();        &#x2F;&#x2F; 获得指令类型        byte messageType &#x3D; in.readByte();        &#x2F;&#x2F; 获得请求序号        int sequenceId &#x3D; in.readInt();        &#x2F;&#x2F; 移除补齐字节        in.readByte();        &#x2F;&#x2F; 获得正文长度        int length &#x3D; in.readInt();        &#x2F;&#x2F; 获得正文        byte[] bytes &#x3D; new byte[length];        in.readBytes(bytes, 0, length);        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));        Message message &#x3D; (Message) ois.readObject();&#x2F;&#x2F; 将信息放入List中，传递给下一个handler        out.add(message);                &#x2F;&#x2F; 打印获得的信息正文        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(magic);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(version);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(seqType);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(messageType);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(sequenceId);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(length);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(message);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestCodec &#123;    static final org.slf4j.Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);    public static void main(String[] args) throws Exception &#123;        EmbeddedChannel channel &#x3D; new EmbeddedChannel();        &#x2F;&#x2F; 添加解码器，避免粘包半包问题        channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0));        channel.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));        channel.pipeline().addLast(new MessageCodec());        LoginRequestMessage user &#x3D; new LoginRequestMessage(&quot;Nyima&quot;, &quot;123&quot;);        &#x2F;&#x2F; 测试编码与解码        ByteBuf byteBuf &#x3D; ByteBufAllocator.DEFAULT.buffer();        new MessageCodec().encode(null, user, byteBuf);        channel.writeInbound(byteBuf);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png" alt="img"></a></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><pre class="line-numbers language-none"><code class="language-none">LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);&#x2F;&#x2F; 不同的channel中使用同一个handler对象，提高复用率channel1.pipeline().addLast(loggingHandler);channel2.pipeline().addLast(loggingHandler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><p><img src="D:\Programs\InterviewNotes\image-20211009114836214.png" alt="image-20211009114836214"></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png" alt="img"></a></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class MessageSharableCodec extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;    @Override    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out) throws Exception &#123;        ...    &#125;    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123;...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface UserService &#123;    &#x2F;**     * 登录     * @param username 用户名     * @param password 密码     * @return 登录成功返回 true, 否则返回 false     *&#x2F;    boolean login(String username, String password);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface Session &#123;    &#x2F;**     * 绑定会话     * @param channel 哪个 channel 要绑定会话     * @param username 会话绑定用户     *&#x2F;    void bind(Channel channel, String username);    &#x2F;**     * 解绑会话     * @param channel 哪个 channel 要解绑会话     *&#x2F;    void unbind(Channel channel);    &#x2F;**     * 获取属性     * @param channel 哪个 channel     * @param name 属性名     * @return 属性值     *&#x2F;    Object getAttribute(Channel channel, String name);    &#x2F;**     * 设置属性     * @param channel 哪个 channel     * @param name 属性名     * @param value 属性值     *&#x2F;    void setAttribute(Channel channel, String name, Object value);    &#x2F;**     * 根据用户名获取 channel     * @param username 用户名     * @return channel     *&#x2F;    Channel getChannel(String username);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface GroupSession &#123;    &#x2F;**     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null     * @param name 组名     * @param members 成员     * @return 成功时返回组对象, 失败返回 null     *&#x2F;    Group createGroup(String name, Set&lt;String&gt; members);    &#x2F;**     * 加入聊天组     * @param name 组名     * @param member 成员名     * @return 如果组不存在返回 null, 否则返回组对象     *&#x2F;    Group joinMember(String name, String member);    &#x2F;**     * 移除组成员     * @param name 组名     * @param member 成员名     * @return 如果组不存在返回 null, 否则返回组对象     *&#x2F;    Group removeMember(String name, String member);    &#x2F;**     * 移除聊天组     * @param name 组名     * @return 如果组不存在返回 null, 否则返回组对象     *&#x2F;    Group removeGroup(String name);    &#x2F;**     * 获取组成员     * @param name 组名     * @return 成员集合, 如果群不存在或没有成员会返回 empty set     *&#x2F;    Set&lt;String&gt; getMembers(String name);    &#x2F;**     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回     * @param name 组名     * @return 成员 channel 集合     *&#x2F;    List&lt;Channel&gt; getMembersChannel(String name);        &#x2F;**     * 判断群聊是否一被创建     * @param name 群聊名称     * @return 是否存在     *&#x2F;    boolean isCreated(String name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png" alt="img"></a></p><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><pre class="line-numbers language-none"><code class="language-none">public class ChatClient &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatClient.class);    public static void main(String[] args) &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        try &#123;            Bootstrap bootstrap &#x3D; new Bootstrap();            bootstrap.group(group);            bootstrap.channel(NioSocketChannel.class);            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                &#125;            &#125;);            Channel channel &#x3D; bootstrap.connect().sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;           group.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><pre class="line-numbers language-none"><code class="language-none">public class ChatServer &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);    public static void main(String[] args) &#123;        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        try &#123;            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();            bootstrap.group(boss, worker);            bootstrap.channel(NioServerSocketChannel.class);            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                &#125;            &#125;);            Channel channel &#x3D; bootstrap.bind(8080).sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><pre class="line-numbers language-none"><code class="language-none">ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;    &#x2F;**     * 创建连接时执行的处理器，用于执行登陆操作     *&#x2F;    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        &#x2F;&#x2F; 开辟额外线程，用于用户登陆及后续操作        new Thread(()-&gt;&#123;            Scanner scanner &#x3D; new Scanner(System.in);            System.out.println(&quot;请输入用户名&quot;);            String username &#x3D; scanner.next();            System.out.println(&quot;请输入密码&quot;);            String password &#x3D; scanner.next();            &#x2F;&#x2F; 创建包含登录信息的请求体            LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);            &#x2F;&#x2F; 发送到channel中            ctx.writeAndFlush(message);            System.out.println(&quot;等待后续操作...&quot;);            &#x2F;&#x2F; 阻塞，直到登陆成功后CountDownLatch被设置为0            try &#123;                waitLogin.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            &#x2F;&#x2F; 执行后续操作            if (!loginStatus.get()) &#123;                &#x2F;&#x2F; 登陆失败，关闭channel并返回                ctx.channel().close();                return;            &#125;            &#x2F;&#x2F; 登录成功后，执行其他操作            while (true) &#123;                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);                System.out.println(&quot;send [username] [content]&quot;);                System.out.println(&quot;gsend [group name] [content]&quot;);                System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);                System.out.println(&quot;gmembers [group name]&quot;);                System.out.println(&quot;gjoin [group name]&quot;);                System.out.println(&quot;gquit [group name]&quot;);                System.out.println(&quot;quit&quot;);                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);                String command &#x3D; scanner.nextLine();                &#x2F;&#x2F; 获得指令及其参数，并发送对应类型消息                String[] commands &#x3D; command.split(&quot; &quot;);                switch (commands[0])&#123;                    case &quot;send&quot;:                        ctx.writeAndFlush(new ChatRequestMessage(username, commands[1], commands[2]));                        break;                    case &quot;gsend&quot;:                        ctx.writeAndFlush(new GroupChatRequestMessage(username,commands[1], commands[2]));                        break;                    case &quot;gcreate&quot;:                        &#x2F;&#x2F; 分割，获得群员名                        String[] members &#x3D; commands[2].split(&quot;,&quot;);                        Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(members));                        &#x2F;&#x2F; 把自己加入到群聊中                        set.add(username);                        ctx.writeAndFlush(new GroupCreateRequestMessage(commands[1],set));                        break;                    case &quot;gmembers&quot;:                        ctx.writeAndFlush(new GroupMembersRequestMessage(commands[1]));                        break;                    case &quot;gjoin&quot;:                        ctx.writeAndFlush(new GroupJoinRequestMessage(username, commands[1]));                        break;                    case &quot;gquit&quot;:                        ctx.writeAndFlush(new GroupQuitRequestMessage(username, commands[1]));                        break;                    case &quot;quit&quot;:                        ctx.channel().close();                        return;                    default:                        System.out.println(&quot;指令有误，请重新输入&quot;);                        continue;                &#125;            &#125;        &#125;, &quot;login channel&quot;).start();    &#125;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        log.debug(&quot;&#123;&#125;&quot;, msg);        if (msg instanceof LoginResponseMessage) &#123;            &#x2F;&#x2F; 如果是登录响应信息            LoginResponseMessage message &#x3D; (LoginResponseMessage) msg;            boolean isSuccess &#x3D; message.isSuccess();            &#x2F;&#x2F; 登录成功，设置登陆标记            if (isSuccess) &#123;                loginStatus.set(true);            &#125;            &#x2F;&#x2F; 登陆后，唤醒登陆线程            waitLogin.countDown();        &#125;    &#125;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable &#x2F;&#x2F; 必须添加该注解public class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;        &#x2F;&#x2F; 获得登录信息        String username &#x3D; msg.getUsername();        String password &#x3D; msg.getPassword();        &#x2F;&#x2F; 校验登录信息        boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);        LoginResponseMessage message;        if (login) &#123;            message &#x3D; new LoginResponseMessage(true, &quot;登陆成功&quot;);            &#x2F;&#x2F; 绑定channel与user            SessionFactory.getSession().bind(ctx.channel(), username);        &#125; else &#123;            message &#x3D; new LoginResponseMessage(false, &quot;登陆失败&quot;);        &#125;        ctx.writeAndFlush(message);    &#125;&#125;&#x2F;&#x2F; 该handler处理登录请求LoginRequestMessageHandler loginRequestMessageHandler &#x3D; new LoginRequestMessageHandler();ch.pipeline().addLast(new LoginRequestMessageHandler());  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><pre class="line-numbers language-none"><code class="language-none">5665 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 1, 0, 2795667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;登陆成功&#39;&#125;5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;登陆成功&#39;&#125;success  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 21711919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username&#x3D;&#39;Nyima&#39;, password&#x3D;&#39;123&#39;&#125;7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:60572] WRITE: 295B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 4e 59 49 4d 01 01 01 00 00 00 00 ff 00 00 01 17 |NYIM............||00000010| ac ed 00 05 73 72 00 31 63 6e 2e 6e 79 69 6d 61 |....sr.1cn.nyima||00000020| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes||00000030| 73 61 67 65 2e 4c 6f 67 69 6e 52 65 73 70 6f 6e |sage.LoginRespon||00000040| 73 65 4d 65 73 73 61 67 65 e2 34 49 24 72 52 f3 |seMessage.4I$rR.||00000050| 07 02 00 00 78 72 00 34 63 6e 2e 6e 79 69 6d 61 |....xr.4cn.nyima||00000060| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes||00000070| 73 61 67 65 2e 41 62 73 74 72 61 63 74 52 65 73 |sage.AbstractRes||00000080| 70 6f 6e 73 65 4d 65 73 73 61 67 65 b3 7e 19 32 |ponseMessage.~.2||00000090| 9b 88 4d 7b 02 00 02 5a 00 07 73 75 63 63 65 73 |..M&#123;...Z..succes||000000a0| 73 4c 00 06 72 65 61 73 6f 6e 74 00 12 4c 6a 61 |sL..reasont..Lja||000000b0| 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 78 |va&#x2F;lang&#x2F;String;x||000000c0| 72 00 24 63 6e 2e 6e 79 69 6d 61 63 2e 73 74 75 |r.$cn.nyimac.stu||000000d0| 64 79 2e 64 61 79 38 2e 6d 65 73 73 61 67 65 2e |dy.day8.message.||000000e0| 4d 65 73 73 61 67 65 dd e9 84 b7 21 db 18 52 02 |Message....!..R.||000000f0| 00 02 49 00 0b 6d 65 73 73 61 67 65 54 79 70 65 |..I..messageType||00000100| 49 00 0a 73 65 71 75 65 6e 63 65 49 64 78 70 00 |I..sequenceIdxp.||00000110| 00 00 00 00 00 00 00 01 74 00 0c e7 99 bb e9 99 |........t.......||00000120| 86 e6 88 90 e5 8a 9f                            |.......         |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable &#x2F;&#x2F; 必须添加该注解public class ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception &#123;        &#x2F;&#x2F; 获得user所在的channel        Channel channel &#x3D; SessionFactory.getSession().getChannel(msg.getTo());        &#x2F;&#x2F; 如果双方都在线        if (channel !&#x3D; null) &#123;            &#x2F;&#x2F; 通过接收方与服务器之间的channel发送信息            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));        &#125; else &#123;            &#x2F;&#x2F; 通过发送方与服务器之间的channel发送消息            ctx.writeAndFlush(new ChatResponseMessage(false, &quot;对方用户不存在或离线，发送失败&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理单聊请求ChatRequestMessageHandler chatRequestMessageHandler &#x3D; new ChatRequestMessageHandler();ch.pipeline().addLast(chatRequestMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><pre class="line-numbers language-none"><code class="language-none">send Nyima hello  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接收方（Nyima）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 收到zhangsan发来的消息20230 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;hello&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupCreateMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception &#123;        &#x2F;&#x2F; 获得要创建的群聊名        String groupName &#x3D; msg.getGroupName();        &#x2F;&#x2F; 获得要创建的群聊的成员组        Set&lt;String&gt; members &#x3D; msg.getMembers();        &#x2F;&#x2F; 判断该群聊是否创建过，未创建返回null并创建群聊        Group group &#x3D; GroupSessionFactory.getGroupSession().createGroup(groupName, members);        if (group &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 发送创建成功消息            GroupCreateResponseMessage groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(true, groupName + &quot;创建成功&quot;);            ctx.writeAndFlush(groupCreateResponseMessage);            &#x2F;&#x2F; 获得在线群员的channel，给群员发送入群聊消息            List&lt;Channel&gt; membersChannel &#x3D; GroupSessionFactory.getGroupSession().getMembersChannel(groupName);            groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(true, &quot;您已被拉入&quot;+groupName);            &#x2F;&#x2F; 给每个在线群员发送消息            for(Channel channel : membersChannel) &#123;                channel.writeAndFlush(groupCreateResponseMessage);            &#125;        &#125; else &#123;            &#x2F;&#x2F; 发送失败消息            GroupCreateResponseMessage groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(false, groupName + &quot;已存在&quot;);            ctx.writeAndFlush(groupCreateResponseMessage);        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理创建群聊请求GroupCreateMessageHandler groupCreateMessageHandler &#x3D; new GroupCreateMessageHandler();ch.pipeline().addLast(groupCreateMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>创建者客户端</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 首次创建gcreate Netty学习 zhangsan,lisi31649 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;Netty学习创建成功&#39;&#125;15244 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;您已被拉入Netty学习&#39;&#125;&#x2F;&#x2F; 再次创建gcreate Netty学习 zhangsan,lisi40771 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;Netty学习已存在&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>群员客户端</p><pre class="line-numbers language-none"><code class="language-none">28788 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;您已被拉入Netty学习&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupChatMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception &#123;        String groupName &#x3D; msg.getGroupName();        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();        &#x2F;&#x2F; 判断群聊是否存在        boolean isCreated &#x3D; groupSession.isCreated(groupName);        if (isCreated) &#123;            &#x2F;&#x2F; 给群员发送信息            List&lt;Channel&gt; membersChannel &#x3D; groupSession.getMembersChannel(groupName);            for(Channel channel : membersChannel) &#123;                channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));            &#125;        &#125; else &#123;            ctx.writeAndFlush(new GroupChatResponseMessage(false, &quot;群聊不存在&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理群聊聊天GroupChatMessageHandler groupChatMessageHandler &#x3D; new GroupChatMessageHandler();ch.pipeline().addLast(groupChatMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><pre class="line-numbers language-none"><code class="language-none">gsend Netty学习 你们好45408 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;你们好&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接收方</p><pre class="line-numbers language-none"><code class="language-none">48082 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;你们好&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发送方（群聊不存在）</p><pre class="line-numbers language-none"><code class="language-none">gsend Spring学习 你们好25140 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;群聊不存在&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupJoinMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception &#123;        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();        &#x2F;&#x2F; 判断该用户是否在群聊中        Set&lt;String&gt; members &#x3D; groupSession.getMembers(msg.getGroupName());        boolean joinFlag &#x3D; false;        &#x2F;&#x2F; 群聊存在且用户未加入，才能加入        if (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;            joinFlag &#x3D; true;        &#125;        if (joinFlag) &#123;            &#x2F;&#x2F; 加入群聊            groupSession.joinMember(msg.getGroupName(), msg.getUsername());            ctx.writeAndFlush(new GroupJoinResponseMessage(true,&quot;加入&quot;+msg.getGroupName()+&quot;成功&quot;));        &#125; else &#123;            ctx.writeAndFlush(new GroupJoinResponseMessage(false, &quot;加入失败，群聊未存在或您已加入该群聊&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理加入群聊GroupJoinMessageHandler groupJoinMessageHandler &#x3D; new GroupJoinMessageHandler();ch.pipeline().addLast(groupJoinMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>正常加入群聊</p><pre class="line-numbers language-none"><code class="language-none">94921 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;加入Netty学习成功&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加入不能存在或已加入的群聊</p><pre class="line-numbers language-none"><code class="language-none">44025 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;加入失败，群聊未存在或您已加入该群聊&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupQuitMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception &#123;        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();        String groupName &#x3D; msg.getGroupName();        Set&lt;String&gt; members &#x3D; groupSession.getMembers(groupName);        String username &#x3D; msg.getUsername();        &#x2F;&#x2F; 判断用户是否在群聊中以及群聊是否存在        boolean joinFlag &#x3D; false;        if (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;            &#x2F;&#x2F; 可以退出            joinFlag &#x3D; true;        &#125;        if (joinFlag) &#123;            &#x2F;&#x2F; 退出成功            groupSession.removeMember(groupName, username);            ctx.writeAndFlush(new GroupQuitResponseMessage(true, &quot;退出&quot;+groupName+&quot;成功&quot;));        &#125; else &#123;            &#x2F;&#x2F; 退出失败            ctx.writeAndFlush(new GroupQuitResponseMessage(false, &quot;群聊不存在或您未加入该群，退出&quot;+groupName+&quot;失败&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理退出群聊GroupQuitMessageHandler groupQuitMessageHandler &#x3D; new GroupQuitMessageHandler();ch.pipeline().addLast(groupQuitMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>正常退出</p><pre class="line-numbers language-none"><code class="language-none">32282 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;退出Netty学习成功&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出不存在或未加入的群聊</p><pre class="line-numbers language-none"><code class="language-none">67404 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;群聊不存在或您未加入该群，退出Netty失败&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupMembersMessageHandler extends SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception &#123;        ctx.writeAndFlush(new GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));    &#125;&#125;&#x2F;&#x2F; 该handler处理查看成员GroupMembersMessageHandler groupMembersMessageHandler &#x3D; new GroupMembersMessageHandler();ch.pipeline().addLast(groupMembersMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">46557 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members&#x3D;[zhangsan, Nyima]&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class QuitHandler extends ChannelInboundHandlerAdapter &#123;    &#x2F;**     * 断开连接时触发 Inactive事件     *&#x2F;    @Override    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;        &#x2F;&#x2F; 解绑        SessionFactory.getSession().unbind(ctx.channel());    &#125;    &#x2F;**     * 异常退出，需要解绑     *&#x2F;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        &#x2F;&#x2F; 解绑        SessionFactory.getSession().unbind(ctx.channel());    &#125;&#125; &#x2F;&#x2F; 该handler处理退出聊天室ch.pipeline().addLast(quitHandler);GroupMembersMessageHandler groupMembersMessageHandler &#x3D; new GroupMembersMessageHandler();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出时，客户端会关闭channel并返回</strong></p><pre class="line-numbers language-none"><code class="language-none">case &quot;quit&quot;:&#x2F;&#x2F; 关闭channel并返回    ctx.channel().close();    return;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" alt="img"></a></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));&#x2F;&#x2F; 添加双向处理器，负责处理READER_IDLE事件ch.pipeline().addLast(new ChannelDuplexHandler() &#123;    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;        &#x2F;&#x2F; 获得事件        IdleStateEvent event &#x3D; (IdleStateEvent) evt;        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE) &#123;            &#x2F;&#x2F; 断开连接            ctx.channel().close();        &#125;    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>使用<code>IdleStateHandler</code>进行空闲检测</p></li><li><p>使用双向处理器</p><pre class="line-numbers language-none"><code class="language-none">ChannelDuplexHandler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对入站与出站事件进行处理</p><ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 发送心跳包，让服务器知道客户端在线&#x2F;&#x2F; 3s未发生WRITER_IDLE，就像服务器发送心跳包&#x2F;&#x2F; 该值为服务器端设置的READER_IDLE触发时间的一半左右ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));ch.pipeline().addLast(new ChannelDuplexHandler() &#123;    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;        IdleStateEvent event &#x3D; (IdleStateEvent) evt;        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;            &#x2F;&#x2F; 发送心跳包            ctx.writeAndFlush(new PingMessage());        &#125;    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><pre class="line-numbers language-none"><code class="language-none">public interface Serializer &#123;    &#x2F;**     * 序列化     * @param object 被序列化的对象     * @param &lt;T&gt; 被序列化对象类型     * @return 序列化后的字节数组     *&#x2F;    &lt;T&gt; byte[] serialize(T object);    &#x2F;**     * 反序列化     * @param clazz 反序列化的目标类的Class对象     * @param bytes 被反序列化的字节数组     * @param &lt;T&gt; 反序列化目标类     * @return 反序列化后的对象     *&#x2F;    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><pre class="line-numbers language-none"><code class="language-none">public enum SerializerAlgorithm implements Serializer &#123;    &#x2F;&#x2F; Java的序列化和反序列化    Java &#123;        @Override        public &lt;T&gt; byte[] serialize(T object) &#123;            &#x2F;&#x2F; 序列化后的字节数组            byte[] bytes &#x3D; null;            try (ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();                 ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos)) &#123;                oos.writeObject(object);                bytes &#x3D; bos.toByteArray();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            return bytes;        &#125;        @Override        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;            T target &#x3D; null;            System.out.println(Arrays.toString(bytes));            try (ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);                 ObjectInputStream ois &#x3D; new ObjectInputStream(bis)) &#123;                target &#x3D; (T) ois.readObject();            &#125; catch (IOException | ClassNotFoundException e) &#123;                e.printStackTrace();            &#125;            &#x2F;&#x2F; 返回反序列化后的对象            return target;        &#125;    &#125;         &#x2F;&#x2F; Json的序列化和反序列化    Json &#123;        @Override        public &lt;T&gt; byte[] serialize(T object) &#123;            String s &#x3D; new Gson().toJson(object);            System.out.println(s);            &#x2F;&#x2F; 指定字符集，获得字节数组            return s.getBytes(StandardCharsets.UTF_8);        &#125;        @Override        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;            String s &#x3D; new String(bytes, StandardCharsets.UTF_8);            System.out.println(s);            &#x2F;&#x2F; 此处的clazz为具体类型的Class对象，而不是父类Message的            return new Gson().fromJson(s, clazz);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得序列化后的msg&#x2F;&#x2F; 使用指定的序列化方式SerializerAlgorithm[] values &#x3D; SerializerAlgorithm.values();&#x2F;&#x2F; 获得序列化后的对象byte[] bytes &#x3D; values[out.getByte(5)-1].serialize(msg);Cop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得反序列化方式SerializerAlgorithm[] values &#x3D; SerializerAlgorithm.values();&#x2F;&#x2F; 通过指定方式进行反序列化&#x2F;&#x2F; 需要通过Message的方法获得具体的消息类型Message message &#x3D; values[seqType-1].deserialize(Message.getMessageClass(messageType), bytes);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><pre class="line-numbers language-none"><code class="language-none">public class TestParam &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常        new Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);                &#x2F;&#x2F; ServerSocketChannel 5s内未建立连接就抛出异常        new ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常        new ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p></li><li><p>服务器通过</p><pre class="line-numbers language-none"><code class="language-none">ServerBootstrap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来配置参数，但是对于不同的 Channel 需要选择不同的方法</p><ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><pre class="line-numbers language-none"><code class="language-none">public final void connect(                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;        ...            &#x2F;&#x2F; Schedule connect timeout.    &#x2F;&#x2F; 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();    &#x2F;&#x2F; 如果超时时间大于0    if (connectTimeoutMillis &gt; 0) &#123;        &#x2F;&#x2F; 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行        &#x2F;&#x2F; schedule(Runnable command, long delay, TimeUnit unit)        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 判断是否建立连接，Promise进行NIO线程与主线程之间的通信                &#x2F;&#x2F; 如果超时，则通过tryFailure方法将异常放入Promise中                &#x2F;&#x2F; 在主线程中抛出                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;                ConnectTimeoutException cause &#x3D; new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;                    close(voidPromise());                &#125;            &#125;        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);    &#125;       ...        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png" alt="img"></a></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png" alt="img"></a></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png" alt="img"></a></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 设置全连接队列，大小为2new ServerBootstrap().option(ChannelOption.SO_BACKLOG, 2);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doBind(SocketAddress localAddress) throws Exception &#123;    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; else &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><pre class="line-numbers language-none"><code class="language-none">private volatile int backlog &#x3D; NetUtil.SOMAXCONN;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的赋值操作如下</p><pre class="line-numbers language-none"><code class="language-none">SOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;    @Override    public Integer run() &#123;        &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.        &#x2F;&#x2F; The known defaults:        &#x2F;&#x2F; - Windows NT Server 4.0+: 200        &#x2F;&#x2F; - Linux and Mac OS X: 128        int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);        BufferedReader in &#x3D; null;        try &#123;            &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the            &#x2F;&#x2F; try &#x2F; catch block.            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936            if (file.exists()) &#123;                in &#x3D; new BufferedReader(new FileReader(file));                &#x2F;&#x2F; 将somaxconn设置为Linux配置文件中设置的值                somaxconn &#x3D; Integer.parseInt(in.readLine());                if (logger.isDebugEnabled()) &#123;                    logger.debug(&quot;&#123;&#125;: &#123;&#125;&quot;, file, somaxconn);                &#125;            &#125; else &#123;                ...            &#125;            ...        &#125;          &#x2F;&#x2F; 返回backlog的值        return somaxconn;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux/Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型&#x2F;&#x2F; 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型new ServerBootstrap().childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator());  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; true表示使用直接内存new PooledByteBufAllocator(true);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>池化并使用堆内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; false表示使用堆内存new PooledByteBufAllocator(false);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>非池化并使用直接内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; ture表示使用直接内存new UnpooledByteBufAllocator(true);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>非池化并使用堆内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; false表示使用堆内存new UnpooledByteBufAllocator(false);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><pre class="line-numbers language-none"><code class="language-none">public abstract class Message implements Serializable &#123;    ...    &#x2F;&#x2F; 添加RPC消息类型    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;    static &#123;        &#x2F;&#x2F; 将消息类型放入消息类对象Map中        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RPC请求消息</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RpcRequestMessage extends Message &#123;    &#x2F;**     * 调用的接口全限定名，服务端根据它找到实现     *&#x2F;    private String interfaceName;        &#x2F;**     * 调用接口中的方法名     *&#x2F;    private String methodName;        &#x2F;**     * 方法返回类型     *&#x2F;    private Class&lt;?&gt; returnType;        &#x2F;**     * 方法参数类型数组     *&#x2F;    private Class[] parameterTypes;        &#x2F;**     * 方法参数值数组     *&#x2F;    private Object[] parameterValue;    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;        super.setSequenceId(sequenceId);        this.interfaceName &#x3D; interfaceName;        this.methodName &#x3D; methodName;        this.returnType &#x3D; returnType;        this.parameterTypes &#x3D; parameterTypes;        this.parameterValue &#x3D; parameterValue;    &#125;    @Override    public int getMessageType() &#123;        return RPC_MESSAGE_TYPE_REQUEST;    &#125;         public String getInterfaceName() &#123;        return interfaceName;    &#125;    public String getMethodName() &#123;        return methodName;    &#125;    public Class&lt;?&gt; getReturnType() &#123;        return returnType;    &#125;    public Class[] getParameterTypes() &#123;        return parameterTypes;    &#125;    public Object[] getParameterValue() &#123;        return parameterValue;    &#125;        @Override    public String toString() &#123;        return &quot;RpcRequestMessage&#123;&quot; +                &quot;interfaceName&#x3D;&#39;&quot; + interfaceName + &#39;\&#39;&#39; +                &quot;, methodName&#x3D;&#39;&quot; + methodName + &#39;\&#39;&#39; +                &quot;, returnType&#x3D;&quot; + returnType +                &quot;, parameterTypes&#x3D;&quot; + Arrays.toString(parameterTypes) +                &quot;, parameterValue&#x3D;&quot; + Arrays.toString(parameterValue) +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RpcResponseMessage extends Message &#123;    &#x2F;**     * 返回值     *&#x2F;    private Object returnValue;    &#x2F;**     * 异常值     *&#x2F;    private Exception exceptionValue;    @Override    public int getMessageType() &#123;        return RPC_MESSAGE_TYPE_RESPONSE;    &#125;            public void setReturnValue(Object returnValue) &#123;        this.returnValue &#x3D; returnValue;    &#125;    public void setExceptionValue(Exception exceptionValue) &#123;        this.exceptionValue &#x3D; exceptionValue;    &#125;         public Object getReturnValue() &#123;        return returnValue;    &#125;    public Exception getExceptionValue() &#123;        return exceptionValue;    &#125;        @Override    public String toString() &#123;        return &quot;RpcResponseMessage&#123;&quot; +                &quot;returnValue&#x3D;&quot; + returnValue +                &quot;, exceptionValue&#x3D;&quot; + exceptionValue +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RPCServer &#123;    public static void main(String[] args) &#123;        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        &#x2F;&#x2F; PRC 请求消息处理器        RpcRequestMessageHandler rpcRequestMessageHandler &#x3D; new RpcRequestMessageHandler();        try &#123;            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.group(boss, worker);            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                    ch.pipeline().addLast(rpcRequestMessageHandler);                &#125;            &#125;);            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RPCClient &#123;    public static void main(String[] args) &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        &#x2F;&#x2F; PRC 请求消息处理器        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();        try &#123;            Bootstrap bootstrap &#x3D; new Bootstrap();            bootstrap.channel(NioSocketChannel.class);            bootstrap.group(group);            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                    ch.pipeline().addLast(rpcResponseMessageHandler);                &#125;            &#125;);            Channel channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过接口Class获取实例对象的<strong>Factory</strong></p><pre class="line-numbers language-none"><code class="language-none">public class ServicesFactory &#123;    static HashMap&lt;Class&lt;?&gt;, Object&gt; map &#x3D; new HashMap&lt;&gt;(16);    public static Object getInstance(Class&lt;?&gt; interfaceClass) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;        &#x2F;&#x2F; 根据Class创建实例        try &#123;            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloService&quot;);            Object instance &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;).newInstance();                       &#x2F;&#x2F; 放入 InterfaceClass -&gt; InstanceObject 的映射            map.put(clazz, instance);        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;            e.printStackTrace();        &#125;          return map.get(interfaceClass);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage) &#123;        RpcResponseMessage rpcResponseMessage &#x3D; new RpcResponseMessage();        try &#123;            &#x2F;&#x2F; 设置返回值的属性            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());            &#x2F;&#x2F; 返回一个实例            HelloService service &#x3D; (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));                        &#x2F;&#x2F; 通过反射调用方法，并获取返回值            Method method &#x3D; service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());            &#x2F;&#x2F; 获得返回值            Object invoke &#x3D; method.invoke(service, rpcMessage.getParameterValue());            &#x2F;&#x2F; 设置返回值            rpcResponseMessage.setReturnValue(invoke);        &#125; catch (Exception e) &#123;            e.printStackTrace();            &#x2F;&#x2F; 设置异常            rpcResponseMessage.setExceptionValue(e);        &#125;    &#125;    &#x2F;&#x2F; 向channel中写入Message    ctx.writeAndFlush(rpcResponseMessage);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;        log.debug(&quot;&#123;&#125;&quot;, msg);        System.out.println((String)msg.getReturnValue());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><pre class="line-numbers language-none"><code class="language-none">public class RPCClient &#123;    public static void main(String[] args) &#123;...                   &#x2F;&#x2F; 创建请求并发送RpcRequestMessage message &#x3D; new RpcRequestMessage(1,               &quot;cn.nyimac.study.day8.server.service.HelloService&quot;,               &quot;sayHello&quot;,               String.class,               new Class[]&#123;String.class&#125;,               new Object[]&#123;&quot;Nyima&quot;&#125;);        channel.writeAndFlush(message);                       ...        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>客户端</p><pre class="line-numbers language-none"><code class="language-none">1606 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue&#x3D;你好，Nyima, exceptionValue&#x3D;null&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><pre class="line-numbers language-none"><code class="language-none">public class RPCClientManager &#123;    &#x2F;**     * 产生SequenceId     *&#x2F;    private static AtomicInteger sequenceId &#x3D; new AtomicInteger(0);    private static volatile Channel channel &#x3D; null;    private static final Object lock &#x3D; new Object();    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建代理对象        HelloService service &#x3D; (HelloService) getProxy(HelloService.class);        &#x2F;&#x2F; 通过代理对象执行方法        System.out.println(service.sayHello(&quot;Nyima&quot;));        System.out.println(service.sayHello(&quot;Hulu&quot;));    &#125;    &#x2F;**     * 单例模式创建Channel     *&#x2F;    public static Channel getChannel() &#123;        if (channel &#x3D;&#x3D; null) &#123;            synchronized (lock) &#123;                if (channel &#x3D;&#x3D; null) &#123;                    init();                &#125;            &#125;        &#125;        return channel;    &#125;    &#x2F;**     * 使用代理模式，帮助我们创建请求消息并发送     *&#x2F;    public static Object getProxy(Class&lt;?&gt; serviceClass) &#123;        Class&lt;?&gt;[] classes &#x3D; new Class&lt;?&gt;[]&#123;serviceClass&#125;;        &#x2F;&#x2F; 使用JDK代理，创建代理对象        Object o &#x3D; Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                &#x2F;&#x2F; 创建请求消息                int id &#x3D; sequenceId.getAndIncrement();                RpcRequestMessage message &#x3D; new RpcRequestMessage(id, serviceClass.getName(),                        method.getName(), method.getReturnType(),                        method.getParameterTypes(),                        args);                &#x2F;&#x2F; 发送消息                getChannel().writeAndFlush(message);                &#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的                DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());                &#x2F;&#x2F; 将Promise放入Map中                RpcResponseMessageHandler.promiseMap.put(id, promise);                &#x2F;&#x2F; 等待被放入Promise中结果                promise.await();                if (promise.isSuccess()) &#123;                    &#x2F;&#x2F; 调用方法成功，返回方法执行结果                    return promise.getNow();                &#125; else &#123;                    &#x2F;&#x2F; 调用方法失败，抛出异常                    throw new RuntimeException(promise.cause());                &#125;            &#125;        &#125;);        return o;    &#125;    private static void init() &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        &#x2F;&#x2F; PRC 请求消息处理器        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();        Bootstrap bootstrap &#x3D; new Bootstrap();        bootstrap.channel(NioSocketChannel.class);        bootstrap.group(group);        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;            @Override            protected void initChannel(SocketChannel ch) throws Exception &#123;                ch.pipeline().addLast(new ProtocolFrameDecoder());                ch.pipeline().addLast(loggingHandler);                ch.pipeline().addLast(messageSharableCodec);                ch.pipeline().addLast(rpcResponseMessageHandler);            &#125;        &#125;);        try &#123;            channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();            &#x2F;&#x2F; 异步关闭 group，避免Channel被阻塞            channel.closeFuture().addListener(future -&gt; &#123;                group.shutdownGracefully();            &#125;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获得Channel</strong></p><ul><li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li><li>通过<strong>单例模式</strong>创建与获取Channel</li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());&#x2F;&#x2F; 将Promise放入Map中RpcResponseMessageHandler.promiseMap.put(id, promise);&#x2F;&#x2F; 等待被放入Promise中结果promise.await();if (promise.isSuccess()) &#123;    &#x2F;&#x2F; 调用方法成功，返回方法执行结果    return promise.getNow();&#125; else &#123;    &#x2F;&#x2F; 调用方法失败，抛出异常    throw new RuntimeException(promise.cause());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的PromisePromise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());Object returnValue &#x3D; msg.getReturnValue();Exception exception &#x3D; msg.getExceptionValue();if (promise !&#x3D; null) &#123;    if (exception !&#x3D; null) &#123;        &#x2F;&#x2F; 返回结果中有异常信息        promise.setFailure(exception);    &#125; else &#123;        &#x2F;&#x2F; 方法正常执行，没有异常        promise.setSuccess(returnValue);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);    &#x2F;**     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值     *&#x2F;    public static Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap &#x3D; new ConcurrentHashMap&lt;&gt;(16);    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;        &#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的Promise        Promise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());        Object returnValue &#x3D; msg.getReturnValue();        Exception exception &#x3D; msg.getExceptionValue();        if (promise !&#x3D; null) &#123;            if (exception !&#x3D; null) &#123;                &#x2F;&#x2F; 返回结果中有异常信息                promise.setFailure(exception);            &#125; else &#123;                &#x2F;&#x2F; 方法正常执行，没有异常                promise.setSuccess(returnValue);            &#125;        &#125;        &#x2F;&#x2F; 拿到返回结果并打印        log.debug(&quot;&#123;&#125;&quot;, msg);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selectorSelector selector &#x3D; Selector.open(); &#x2F;&#x2F; 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 configNioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();&#x2F;&#x2F; 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannelServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false);&#x2F;&#x2F; 启动 nio boss 线程执行接下来的操作&#x2F;&#x2F;注册（仅关联 selector 和 NioServerSocketChannel），未关注事件SelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);&#x2F;&#x2F; head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor&#x2F;&#x2F; 绑定端口serverSocketChannel.bind(new InetSocketAddress(8080));&#x2F;&#x2F; 触发 channel active 事件，在 head 中关注 op_accept 事件selectionKey.interestOps(SelectionKey.OP_ACCEPT);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><pre class="line-numbers language-none"><code class="language-none">public ChannelFuture bind(SocketAddress localAddress) &#123;validate();return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><pre class="line-numbers language-none"><code class="language-none">private ChannelFuture doBind(final SocketAddress localAddress) &#123;    &#x2F;&#x2F; 负责NioServerSocketChannel和ServerSocketChannel的创建    &#x2F;&#x2F; ServerSocketChannel的注册工作    &#x2F;&#x2F; init由main线程完成，regisetr由NIO线程完成    final ChannelFuture regFuture &#x3D; initAndRegister();    final Channel channel &#x3D; regFuture.channel();    if (regFuture.cause() !&#x3D; null) &#123;        return regFuture;    &#125;    &#x2F;&#x2F; 因为register操作是异步的    &#x2F;&#x2F; 所以要判断主线程执行到这里时，register操作是否已经执行完毕    if (regFuture.isDone()) &#123;        &#x2F;&#x2F; At this point we know that the registration was complete and successful.        ChannelPromise promise &#x3D; channel.newPromise();                &#x2F;&#x2F; 执行doBind0绑定操作        doBind0(regFuture, channel, localAddress, promise);        return promise;    &#125; else &#123;        &#x2F;&#x2F; Registration future is almost always fulfilled already, but just in case it&#39;s not.        &#x2F;&#x2F; 如果register操作还没执行完，就会到这个分支中来        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);                &#x2F;&#x2F; 添加监听器，NIO线程异步进行doBind0操作        regFuture.addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture future) throws Exception &#123;                Throwable cause &#x3D; future.cause();                if (cause !&#x3D; null) &#123;                    &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an                    &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.                    promise.setFailure(cause);                &#125; else &#123;                    &#x2F;&#x2F; Registration was successful, so set the correct executor to use.                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        return promise;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><pre class="line-numbers language-none"><code class="language-none">final ChannelFuture initAndRegister() &#123;    Channel channel &#x3D; null;    try &#123;        channel &#x3D; channelFactory.newChannel();        init(channel);    &#125; catch (Throwable t) &#123;        if (channel !&#x3D; null) &#123;            &#x2F;&#x2F; channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))            channel.unsafe().closeForcibly();            &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);        &#125;        &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);    &#125;    ChannelFuture regFuture &#x3D; config().group().register(channel);    if (regFuture.cause() !&#x3D; null) &#123;        if (channel.isRegistered()) &#123;            channel.close();        &#125; else &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;    &#x2F;&#x2F; If we are here and the promise is not failed, it&#39;s one of the following cases:    &#x2F;&#x2F; 1) If we attempted registration from the event loop, the registration has been completed at this point.    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now because the channel has been registered.    &#x2F;&#x2F; 2) If we attempted registration from the other thread, the registration request has been successfully    &#x2F;&#x2F;    added to the event loop&#39;s task queue for later execution.    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now:    &#x2F;&#x2F;         because bind() or connect() will be executed *after* the scheduled registration task is executed    &#x2F;&#x2F;         because register(), bind(), and connect() are all bound to the same thread.    return regFuture;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre class="line-numbers language-none"><code class="language-none">Channel channel &#x3D; null;try &#123;    &#x2F;&#x2F; 通过反射初始化NioServerSocketChannel    channel &#x3D; channelFactory.newChannel();    init(channel);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newChannel方法</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic T newChannel() &#123;    try &#123;        &#x2F;&#x2F; 通过反射调用NioServerSocketChannel的构造方法        &#x2F;&#x2F; 创建NioServerSocketChannel对象        return constructor.newInstance();    &#125; catch (Throwable t) &#123;        throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NioServerSocketChannel构造方法</p><pre class="line-numbers language-none"><code class="language-none">public NioServerSocketChannel() &#123;    &#x2F;&#x2F; 创建了ServerSocketChannel实例    this(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>newSocket方法</p><pre class="line-numbers language-none"><code class="language-none">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;    try &#123;        &#x2F;&#x2F; ServerSocketChannel.open方法：        &#x2F;&#x2F; SelectorProvider.provider().openServerSocketChannel()    &#x2F;&#x2F; 所以此处相当于ServerSocketChannel.open()        &#x2F;&#x2F; 创建了ServerSocketChannel实例    return provider.openServerSocketChannel();&#125; catch (IOException e) &#123;    throw new ChannelException(&quot;Failed to open a server socket.&quot;, e);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>init方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridevoid init(Channel channel) &#123;   ...    &#x2F;&#x2F; NioSocketChannl的Pipeline        ChannelPipeline p &#x3D; channel.pipeline();    ...    &#x2F;&#x2F; 向Pipeline中添加了一个handler，该handler等待被调用    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;        @Override        &#x2F;&#x2F; register之后才调用该方法        public void initChannel(final Channel ch) &#123;            final ChannelPipeline pipeline &#x3D; ch.pipeline();                        &#x2F;&#x2F; 创建handler并加入到pipeline中            ChannelHandler handler &#x3D; config.handler();            if (handler !&#x3D; null) &#123;                pipeline.addLast(handler);            &#125;            ch.eventLoop().execute(new Runnable() &#123;                @Override                public void run() &#123;                    &#x2F;&#x2F; 添加新的handler，在发生Accept事件后建立连接                    pipeline.addLast(new ServerBootstrapAcceptor(                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));                &#125;            &#125;);        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>init主要完成了以下三个操作</strong></p><ul><li><p>创建NioServerSocketChannel</p></li><li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p></li><li><p>由</p><pre class="line-numbers language-none"><code class="language-none">initChannel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法向NioServerSocketChannel中添加了两个handler，</p><p>添加操作在register之后被执行</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;    ...    &#x2F;&#x2F; 获取EventLoop    AbstractChannel.this.eventLoop &#x3D; eventLoop;   &#x2F;&#x2F; 此处完成了由 主线程 到 NIO线程 的切换    &#x2F;&#x2F; eventLoop.inEventLoop()用于判断当前线程是否为NIO线程    if (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; else &#123;        try &#123;            &#x2F;&#x2F; 向NIO线程中添加任务            eventLoop.execute(new Runnable() &#123;                @Override                public void run() &#123;                    &#x2F;&#x2F; 该方法中会执行doRegister                    &#x2F;&#x2F; 执行真正的注册操作                    register0(promise);                &#125;            &#125;);        &#125; catch (Throwable t) &#123;           ...        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>register0方法</p><pre class="line-numbers language-none"><code class="language-none">private void register0(ChannelPromise promise) &#123;    try &#123;       ...                    &#x2F;&#x2F; 执行真正的注册操作        doRegister();        neverRegistered &#x3D; false;        registered &#x3D; true;        &#x2F;&#x2F; Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the        &#x2F;&#x2F; user may already fire events through the pipeline in the ChannelFutureListener.                &#x2F;&#x2F; 调用init中的initChannel方法        pipeline.invokeHandlerAddedIfNeeded();        ...    &#125; catch (Throwable t) &#123;        ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>doRegister方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doRegister() throws Exception &#123;    boolean selected &#x3D; false;    for (;;) &#123;        try &#123;            &#x2F;&#x2F; javaChannel()即为ServerSocketChannel            &#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector            &#x2F;&#x2F; this为NIOServerSocketChannel，作为附件            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);            return;        &#125; catch (CancelledKeyException e) &#123;            ...                   &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调initChannel</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void initChannel(final Channel ch) &#123;    final ChannelPipeline pipeline &#x3D; ch.pipeline();    ChannelHandler handler &#x3D; config.handler();    if (handler !&#x3D; null) &#123;        pipeline.addLast(handler);    &#125;    &#x2F;&#x2F; 添加新任务，任务负责添加handler    &#x2F;&#x2F; 该handler负责发生Accepet事件后建立连接    ch.eventLoop().execute(new Runnable() &#123;        @Override        public void run() &#123;            pipeline.addLast(new ServerBootstrapAcceptor(                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; javaChannel()即为ServerSocketChannel&#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector&#x2F;&#x2F; this为NIOServerSocketChannel，作为附件selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; initAndRegister为异步方法，会返回ChannelFuture对象final ChannelFuture regFuture &#x3D; initAndRegister();regFuture.addListener(new ChannelFutureListener() &#123;    @Override    public void operationComplete(ChannelFuture future) throws Exception &#123;        Throwable cause &#x3D; future.cause();        if (cause !&#x3D; null) &#123;            &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an            &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.            promise.setFailure(cause);        &#125; else &#123;            &#x2F;&#x2F; Registration was successful, so set the correct executor to use.            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586            promise.registered();            &#x2F;&#x2F; 如果没有异常，则执行绑定操作            doBind0(regFuture, channel, localAddress, promise);        &#125;    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><pre class="line-numbers language-none"><code class="language-none">@SuppressJava6Requirement(reason &#x3D; &quot;Usage guarded by java version check&quot;)@Overrideprotected void doBind(SocketAddress localAddress) throws Exception &#123;    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;        &#x2F;&#x2F; 调用ServerSocketChannel的bind方法，绑定端口        javaChannel().bind(localAddress, config.getBacklog());    &#125; else &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><pre class="line-numbers language-none"><code class="language-none">if (!wasActive &amp;&amp; isActive()) &#123;    invokeLater(new Runnable() &#123;        @Override        public void run() &#123;            pipeline.fireChannelActive();        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doBeginRead() throws Exception &#123;    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called    final SelectionKey selectionKey &#x3D; this.selectionKey;    if (!selectionKey.isValid()) &#123;        return;    &#125;    readPending &#x3D; true;    final int interestOps &#x3D; selectionKey.interestOps();    &#x2F;&#x2F; 如果ServerSocketChannel没有关注Accept事件    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 则让其关注Accepet事件        &#x2F;&#x2F; readInterestOp 取值是 16        &#x2F;&#x2F; 在 NioServerSocketChannel 创建时初始化        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><pre class="line-numbers language-none"><code class="language-none">final int interestOps &#x3D; selectionKey.interestOps();  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后再设置其感兴趣的事件</p><pre class="line-numbers language-none"><code class="language-none">selectionKey.interestOps(interestOps | readInterestOp);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>各个事件对应的值</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png" alt="img"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><pre class="line-numbers language-none"><code class="language-none">public final class NioEventLoop extends SingleThreadEventLoop &#123;        ...            &#x2F;&#x2F; selector中的selectedKeys是基于数组的    &#x2F;&#x2F; unwrappedSelector中的selectedKeys是基于HashSet的        private Selector selector;    private Selector unwrappedSelector;    private SelectedSelectionKeySet selectedKeys;        ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Thread与TaskQueue</strong></p><pre class="line-numbers language-none"><code class="language-none">public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor &#123;    &#x2F;&#x2F; 任务队列    private final Queue&lt;Runnable&gt; taskQueue;    &#x2F;&#x2F; 线程    private volatile Thread thread;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><pre class="line-numbers language-none"><code class="language-none">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;            ...                   &#x2F;&#x2F; 初始化selector，初始化过程在openSelector中        final SelectorTuple selectorTuple &#x3D; openSelector();        this.selector &#x3D; selectorTuple.selector;        this.unwrappedSelector &#x3D; selectorTuple.unwrappedSelector;&#125;private SelectorTuple openSelector() &#123;    final Selector unwrappedSelector;    try &#123;        &#x2F;&#x2F; 此处等同于 Selector.open()方法        &#x2F;&#x2F; 创建了unwrappedSelector对象        unwrappedSelector &#x3D; provider.openSelector();    &#125; catch (IOException e) &#123;        throw new ChannelException(&quot;failed to open a new selector&quot;, e);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><pre class="line-numbers language-none"><code class="language-none">unwrappedSelector &#x3D; provider.openSelector();  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><pre class="line-numbers language-none"><code class="language-none">private static final class SelectorTuple &#123;    final Selector unwrappedSelector;    final Selector selector;    SelectorTuple(Selector unwrappedSelector) &#123;        this.unwrappedSelector &#x3D; unwrappedSelector;        this.selector &#x3D; unwrappedSelector;    &#125;    &#x2F;**    * 一般调用的是这个构造方法    *&#x2F;    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;        this.unwrappedSelector &#x3D; unwrappedSelector;        this.selector &#x3D; selector;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><pre class="line-numbers language-none"><code class="language-none">private SelectorTuple openSelector() &#123;    final Selector unwrappedSelector;    try &#123;        unwrappedSelector &#x3D; provider.openSelector();    &#125; catch (IOException e) &#123;        throw new ChannelException(&quot;failed to open a new selector&quot;, e);    &#125;    ...        &#x2F;&#x2F; 获得基于数组的selectedKeySet实现    final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();    Object maybeException &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;        @Override        public Object run() &#123;            try &#123;                &#x2F;&#x2F; 通过反射拿到unwrappedSelector中的selectedKeys属性                Field selectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);                Field publicSelectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);                ...                &#x2F;&#x2F; 暴力反射，修改私有属性                Throwable cause &#x3D; ReflectionUtil.trySetAccessible(selectedKeysField, true);                if (cause !&#x3D; null) &#123;                    return cause;                &#125;                cause &#x3D; ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);                if (cause !&#x3D; null) &#123;                    return cause;                &#125;                &#x2F;&#x2F; 替换为基于数组的selectedKeys实现                selectedKeysField.set(unwrappedSelector, selectedKeySet);                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);                return null;            &#125; catch (NoSuchFieldException e) &#123;                return e;            &#125; catch (IllegalAccessException e) &#123;                return e;            &#125;        &#125;    &#125;);    selectedKeys &#x3D; selectedKeySet;        &#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector    return new SelectorTuple(unwrappedSelector,                             new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得基于数组的selectedKeySet实现final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();SelectedSelectionKeySet() &#123;keys &#x3D; new SelectionKey[1024];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><pre class="line-numbers language-none"><code class="language-none">new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selectorreturn new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestNioEventLoop &#123;    public static void main(String[] args) &#123;        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();        &#x2F;&#x2F; 使用NioEventLoop执行任务        eventLoop.execute(()-&gt;&#123;            System.out.println(&quot;hello&quot;);        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入<code>execute</code>执行任务</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void execute(Runnable task) &#123;    &#x2F;&#x2F; 检测传入的任务是否为空，为空会抛出NullPointerException    ObjectUtil.checkNotNull(task, &quot;task&quot;);    &#x2F;&#x2F; 执行任务    &#x2F;&#x2F; 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true    execute(task, !(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入上述代码的<code>execute</code>方法</p><pre class="line-numbers language-none"><code class="language-none">private void execute(Runnable task, boolean immediate) &#123;    &#x2F;&#x2F; 判断当前线程是否为NIO线程    &#x2F;&#x2F; 判断方法为 return thread &#x3D;&#x3D; this.thread;    &#x2F;&#x2F; this.thread即为NIO线程，首次执行任务时，其为null    boolean inEventLoop &#x3D; inEventLoop();        &#x2F;&#x2F; 向任务队列taskQueue中添加任务    addTask(task);        &#x2F;&#x2F; 当前线程不是NIO线程，则进入if语句    if (!inEventLoop) &#123;        &#x2F;&#x2F; 启动NIO线程的核心方法        startThread();                ...            &#125;    &#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程    if (!addTaskWakesUp &amp;&amp; immediate) &#123;        wakeup(inEventLoop);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入<code>startThread</code>方法</p><pre class="line-numbers language-none"><code class="language-none">private void startThread() &#123;    &#x2F;&#x2F; 查看NIO线程状态是否为未启动    &#x2F;&#x2F; 该if代码块只会执行一次    &#x2F;&#x2F; state一开始的值就是ST_NOT_STARTED    &#x2F;&#x2F; private volatile int state &#x3D; ST_NOT_STARTED;    if (state &#x3D;&#x3D; ST_NOT_STARTED) &#123;        &#x2F;&#x2F; 通过原子属性更新器将状态更新为启动（ST_STARTED）        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;            boolean success &#x3D; false;            try &#123;                &#x2F;&#x2F; 执行启动线程                doStartThread();                success &#x3D; true;            &#125; finally &#123;                if (!success) &#123;                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><pre class="line-numbers language-none"><code class="language-none">private void doStartThread() &#123;    assert thread &#x3D;&#x3D; null;    &#x2F;&#x2F; 创建NIO线程并执行任务    executor.execute(new Runnable() &#123;        @Override        public void run() &#123;            &#x2F;&#x2F; thread即为NIO线程            thread &#x3D; Thread.currentThread();            if (interrupted) &#123;                thread.interrupt();            &#125;            boolean success &#x3D; false;            updateLastExecutionTime();            try &#123;                &#x2F;&#x2F; 执行内部run方法                SingleThreadEventExecutor.this.run();                success &#x3D; true;            &#125;                         ...    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void run() &#123;    int selectCnt &#x3D; 0;    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行    for (;;) &#123;      &#x2F;&#x2F; 执行各种任务   try &#123;            int strategy;            try &#123;                strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());                switch (strategy) &#123;                case SelectStrategy.CONTINUE:                    continue;                case SelectStrategy.BUSY_WAIT:                    &#x2F;&#x2F; fall-through to SELECT since the busy-wait is not supported with NIO                case SelectStrategy.SELECT:                    long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();                    if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;                        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar                    &#125;                    nextWakeupNanos.set(curDeadlineNanos);                    try &#123;                        if (!hasTasks()) &#123;                            strategy &#x3D; select(curDeadlineNanos);                        &#125;                    &#125; finally &#123;                        &#x2F;&#x2F; This update is just to help block unnecessary selector wakeups                        &#x2F;&#x2F; so use of lazySet is ok (no race condition)                        nextWakeupNanos.lazySet(AWAKE);                    &#125;                    &#x2F;&#x2F; fall through                default:                &#125;       &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void run() &#123;    int selectCnt &#x3D; 0;    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行    for (;;) &#123;      &#x2F;&#x2F; 执行各种任务   ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><pre class="line-numbers language-none"><code class="language-none">case SelectStrategy.SELECT:long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar    &#125;nextWakeupNanos.set(curDeadlineNanos);try &#123;    if (!hasTasks()) &#123;            &#x2F;&#x2F; 执行select方法            strategy &#x3D; select(curDeadlineNanos);        &#125;    &#125;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><pre class="line-numbers language-none"><code class="language-none">private int select(long deadlineNanos) throws IOException &#123;    &#x2F;&#x2F; 如果没有指定阻塞事件，就调用select()    if (deadlineNanos &#x3D;&#x3D; NONE) &#123;        return selector.select();    &#125;    &#x2F;&#x2F; 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞    &#x2F;&#x2F; Timeout will only be 0 if deadline is within 5 microsecs    long timeoutMillis &#x3D; deadlineToDelayNanos(deadlineNanos + 995000L) &#x2F; 1000000L;    return timeoutMillis &lt;&#x3D; 0 ? selector.selectNow() : selector.select(timeoutMillis);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p><p>唤醒是通过execute最后的if代码块来完成的</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程if (!addTaskWakesUp &amp;&amp; immediate) &#123;    wakeup(inEventLoop);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void wakeup(boolean inEventLoop) &#123;    &#x2F;&#x2F; 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒    &#x2F;&#x2F; 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功    if (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) !&#x3D; AWAKE) &#123;        &#x2F;&#x2F; 唤醒被selector.select方法阻塞的NIO线程        selector.wakeup();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><pre class="line-numbers language-none"><code class="language-none">int strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());switch (strategy) &#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>strategy的值由<code>calculateStrategy</code>方法确定</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;    &#x2F;&#x2F; selectSupplier.get() 底层是 selector.selectNow();    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><pre class="line-numbers language-none"><code class="language-none">private final IntSupplier selectNowSupplier &#x3D; new IntSupplier() &#123;    public int get() throws Exception &#123;        return NioEventLoop.this.selectNow();    &#125;&#125;;int selectNow() throws IOException &#123;    return this.selector.selectNow();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void run() &#123;    ...    for(;;)&#123;        ...        &#x2F;&#x2F; 可能发生空轮询，无法阻塞NIO线程        strategy &#x3D; select(curDeadlineNanos);          ...              if(...) &#123;...     &#125; else if (unexpectedSelectorWakeup(selectCnt) )&#123;            &#x2F;&#x2F; 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector            &#x2F;&#x2F; 并将selectCnt重置为0            selectCnt &#x3D; 0;        &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><pre class="line-numbers language-none"><code class="language-none">if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;    &#x2F;&#x2F; The selector returned prematurely many times in a row.    &#x2F;&#x2F; Rebuild the selector to work around the problem.    logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,selectCnt, selector);    &#x2F;&#x2F; 重建selector，将原selector的配置信息传给新selector    &#x2F;&#x2F; 再用新selector覆盖旧selector    rebuildSelector();    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 处理IO事件时间比例，默认为50%final int ioRatio &#x3D; this.ioRatio;&#x2F;&#x2F; 如果IO事件时间比例设置为100%if (ioRatio &#x3D;&#x3D; 100) &#123;    try &#123;        &#x2F;&#x2F; 如果需要去处理IO事件        if (strategy &gt; 0) &#123;            &#x2F;&#x2F; 先处理IO事件            processSelectedKeys();        &#125;    &#125; finally &#123;        &#x2F;&#x2F; Ensure we always run tasks.        &#x2F;&#x2F; 剩下的时间都去处理普通任务和定时任务        ranTasks &#x3D; runAllTasks();    &#125;&#125; else if (strategy &gt; 0) &#123; &#x2F;&#x2F; 如果需要去处理IO事件    &#x2F;&#x2F; 记录处理IO事件前的时间    final long ioStartTime &#x3D; System.nanoTime();    try &#123;        &#x2F;&#x2F; 去处理IO事件        processSelectedKeys();    &#125; finally &#123;        &#x2F;&#x2F; Ensure we always run tasks.        &#x2F;&#x2F; ioTime为处理IO事件耗费的事件        final long ioTime &#x3D; System.nanoTime() - ioStartTime;        &#x2F;&#x2F; 计算出处理其他任务的事件        &#x2F;&#x2F; 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行        ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);    &#125;&#125; else &#123; &#x2F;&#x2F; 没有IO事件需要处理    &#x2F;&#x2F; This will run the minimum number of tasks    &#x2F;&#x2F; 直接处理普通和定时任务    ranTasks &#x3D; runAllTasks(0); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 没有指定执行任务的时间ranTasks &#x3D; runAllTasks();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 比如ioTime为10s，ioRatio为50&#x2F;&#x2F; 那么通过 10*(100-50)&#x2F;50&#x3D;10 计算出其他任务可用的时间为 10s&#x2F;&#x2F; 处理IO事件占用的事件总比例为50%ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 运行最少数量的任务ranTasks &#x3D; runAllTasks(0);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><pre class="line-numbers language-none"><code class="language-none">private void processSelectedKeys() &#123;    &#x2F;&#x2F; 如果selectedKeys是基于数组的    &#x2F;&#x2F; 一般情况下都走这个分支    if (selectedKeys !&#x3D; null) &#123;        &#x2F;&#x2F; 处理各种IO事件        processSelectedKeysOptimized();    &#125; else &#123;        processSelectedKeysPlain(selector.selectedKeys());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>processSelectedKeysOptimized方法</p><pre class="line-numbers language-none"><code class="language-none">private void processSelectedKeysOptimized() &#123;    for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;        &#x2F;&#x2F; 拿到SelectionKeyec        final SelectionKey k &#x3D; selectedKeys.keys[i];        &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363        selectedKeys.keys[i] &#x3D; null;        &#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel        final Object a &#x3D; k.attachment();        if (a instanceof AbstractNioChannel) &#123;            &#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel            processSelectedKey(k, (AbstractNioChannel) a);        &#125; else &#123;            @SuppressWarnings(&quot;unchecked&quot;)            NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;            processSelectedKey(k, task);        &#125;        if (needsToSelectAgain) &#123;            &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363            selectedKeys.reset(i + 1);            selectAgain();            i &#x3D; -1;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><pre class="line-numbers language-none"><code class="language-none">final SelectionKey k &#x3D; selectedKeys.keys[i];  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannelfinal Object a &#x3D; k.attachment();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果附件继承自AbstractNioChannel，则会调用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannelprocessSelectedKey(k, (AbstractNioChannel) a);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><pre class="line-numbers language-none"><code class="language-none">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();    if (!k.isValid()) &#123;        final EventLoop eventLoop;        try &#123;            eventLoop &#x3D; ch.eventLoop();        &#125; catch (Throwable ignored) &#123;            &#x2F;&#x2F; If the channel implementation throws an exception because there is no event loop, we ignore this            &#x2F;&#x2F; because we are only trying to determine if ch is registered to this event loop and thus has authority            &#x2F;&#x2F; to close ch.            return;        &#125;        &#x2F;&#x2F; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop        &#x2F;&#x2F; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is        &#x2F;&#x2F; still healthy and should not be closed.        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;5125        if (eventLoop &#x3D;&#x3D; this) &#123;            &#x2F;&#x2F; close the channel if the key is not valid anymore            unsafe.close(unsafe.voidPromise());        &#125;        return;    &#125;    try &#123;        int readyOps &#x3D; k.readyOps();        &#x2F;&#x2F; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise        &#x2F;&#x2F; the NIO JDK channel implementation may throw a NotYetConnectedException.        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;            &#x2F;&#x2F; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;924            int ops &#x3D; k.interestOps();            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;            k.interestOps(ops);            unsafe.finishConnect();        &#125;        &#x2F;&#x2F; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;            &#x2F;&#x2F; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write            ch.unsafe().forceFlush();        &#125;        &#x2F;&#x2F; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead        &#x2F;&#x2F; to a spin loop        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;            unsafe.read();        &#125;    &#125; catch (CancelledKeyException ignored) &#123;        unsafe.close(unsafe.voidPromise());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 阻塞直到事件发生selector.select();Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectionKeys().iterator();while (iter.hasNext()) &#123;        &#x2F;&#x2F; 拿到一个事件    SelectionKey key &#x3D; iter.next();        &#x2F;&#x2F; 如果是 accept 事件    if (key.isAcceptable()) &#123;                &#x2F;&#x2F; 执行accept，获得SocketChannel        SocketChannel channel &#x3D; serverSocketChannel.accept();        channel.configureBlocking(false);                &#x2F;&#x2F; 将SocketChannel注册到selector中，并关注read事件        channel.register(selector, SelectionKey.OP_READ);    &#125;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><pre class="line-numbers language-none"><code class="language-none">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;unsafe.read();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>NioMessageUnsafe.read</code>方法</p><pre class="line-numbers language-none"><code class="language-none">public void read() &#123;    ...        try &#123;        try &#123;            do &#123;&#x2F;&#x2F; doReadMessages中执行了accept获得了SocketChannel                &#x2F;&#x2F; 并创建NioSocketChannel作为消息放入readBuf                &#x2F;&#x2F; readBuf是一个ArrayList用来缓存消息                &#x2F;&#x2F; private final List&lt;Object&gt; readBuf &#x3D; new ArrayList&lt;Object&gt;();                int localRead &#x3D; doReadMessages(readBuf);                                ...                &#x2F;&#x2F; localRead值为1，就一条消息，即接收一个客户端连接                allocHandle.incMessagesRead(localRead);            &#125; while (allocHandle.continueReading());        &#125; catch (Throwable t) &#123;            exception &#x3D; t;        &#125;        int size &#x3D; readBuf.size();        for (int i &#x3D; 0; i &lt; size; i ++) &#123;            readPending &#x3D; false;            &#x2F;&#x2F; 触发read事件，让pipeline上的handler处理            &#x2F;&#x2F; ServerBootstrapAcceptor.channelRead            pipeline.fireChannelRead(readBuf.get(i));        &#125;                ...            &#125; finally &#123;        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;    &#x2F;&#x2F; 处理accpet事件，获得SocketChannel    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());    try &#123;        if (ch !&#x3D; null) &#123;            &#x2F;&#x2F; 创建了NioSocketChannel，作为消息放在了readBuf中            buf.add(new NioSocketChannel(this, ch));            return 1;        &#125;    &#125; catch (Throwable t) &#123;       ...    &#125;    return 0;&#125;ServerBootstrapAcceptor.channelReadpublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123;    &#x2F;&#x2F; 这时的msg是NioSocketChannel    final Channel child &#x3D; (Channel) msg;    &#x2F;&#x2F; NioSocketChannel添加childHandler，即初始化器    child.pipeline().addLast(childHandler);    &#x2F;&#x2F; 设置选项    setChannelOptions(child, childOptions, logger);    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());    &#125;    try &#123;        &#x2F;&#x2F; 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程        childGroup.register(child).addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture future) throws Exception &#123;                if (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; catch (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><pre class="line-numbers language-none"><code class="language-none">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;        ...    AbstractChannel.this.eventLoop &#x3D; eventLoop;    if (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; else &#123;        try &#123;            &#x2F;&#x2F; 这行代码完成的是nio boss -&gt; nio worker线程的切换            eventLoop.execute(new Runnable() &#123;                @Override                public void run() &#123;                    &#x2F;&#x2F; 真正的注册操作                    register0(promise);                &#125;            &#125;);        &#125; catch (Throwable t) &#123;            ...        &#125;    &#125;&#125;AbstractChannel.AbstractUnsafe.register0private void register0(ChannelPromise promise) &#123;    try &#123;                ...                    &#x2F;&#x2F; 该方法将SocketChannel注册到Selector中        doRegister();                &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail        pipeline.invokeHandlerAddedIfNeeded();        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail        safeSetSuccess(promise);        pipeline.fireChannelRegistered();                if (isActive()) &#123;            if (firstRegistration) &#123;                &#x2F;&#x2F; 触发pipeline上active事件                pipeline.fireChannelActive();            &#125; else if (config().isAutoRead()) &#123;                beginRead();            &#125;        &#125;    &#125; catch (Throwable t) &#123;        closeForcibly();        closeFuture.setClosed();        safeSetFailure(promise, t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doRegister() throws Exception &#123;    boolean selected &#x3D; false;    for (;;) &#123;        try &#123;            &#x2F;&#x2F; 将Selector注册到Selector中            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);            return;        &#125; catch (CancelledKeyException e) &#123;            ...        &#125;    &#125;&#125;HeadContext.channelActivepublic void channelActive(ChannelHandlerContext ctx) &#123;    ctx.fireChannelActive();&#x2F;&#x2F; 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)    readIfIsAutoRead();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><pre class="line-numbers language-none"><code class="language-none">protected void doBeginRead() throws Exception &#123;    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called    final SelectionKey selectionKey &#x3D; this.selectionKey;    if (!selectionKey.isValid()) &#123;        return;    &#125;    readPending &#x3D; true;&#x2F;&#x2F; 这时候 interestOps是0    final int interestOps &#x3D; selectionKey.interestOps();    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 关注read事件        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><pre class="line-numbers language-none"><code class="language-none">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;unsafe.read();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic final void read() &#123;    &#x2F;&#x2F; 获得Channel的配置    final ChannelConfig config &#x3D; config();    if (shouldBreakReadReady(config)) &#123;        clearReadPending();        return;    &#125;    final ChannelPipeline pipeline &#x3D; pipeline();&#x2F;&#x2F; 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）final ByteBufAllocator allocator &#x3D; config.getAllocator();    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();    allocHandle.reset(config);    ByteBuf byteBuf &#x3D; null;    boolean close &#x3D; false;    try &#123;        do &#123;            &#x2F;&#x2F; 创建ByteBuf            byteBuf &#x3D; allocHandle.allocate(allocator);            &#x2F;&#x2F; 读取内容，放入ByteBUf中            allocHandle.lastBytesRead(doReadBytes(byteBuf));            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;                byteBuf.release();                byteBuf &#x3D; null;                close &#x3D; allocHandle.lastBytesRead() &lt; 0;                if (close) &#123;                    readPending &#x3D; false;                &#125;                break;            &#125;            allocHandle.incMessagesRead(1);            readPending &#x3D; false;            &#x2F;&#x2F; 触发read 事件，让pipeline上的handler处理            &#x2F;&#x2F; 这时是处理NioSocketChannel上的handler            pipeline.fireChannelRead(byteBuf);            byteBuf &#x3D; null;        &#125;         &#x2F;&#x2F; 是否要继续循环        while (allocHandle.continueReading());        allocHandle.readComplete();        &#x2F;&#x2F; 触发 read complete事件        pipeline.fireChannelReadComplete();        if (close) &#123;            closeOnRead(pipeline);        &#125;    &#125; catch (Throwable t) &#123;        handleReadException(pipeline, byteBuf, t, close, allocHandle);    &#125; finally &#123;         &#x2F;&#x2F; Check if there is a readPending which was not processed yet.         &#x2F;&#x2F; This could be for two reasons:         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method         &#x2F;&#x2F;         &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2254        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;    return            &#x2F;&#x2F; 一般为true           config.isAutoRead() &amp;&amp;           &#x2F;&#x2F; respectMaybeMoreData默认为true           &#x2F;&#x2F; maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead默认16           totalMessages &lt; maxMessagePerRead &amp;&amp;           &#x2F;&#x2F; 实际读到了数据           totalBytesRead &gt; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记</title>
      <link href="/2021/11/29/springcloud/"/>
      <url>/2021/11/29/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183152316.png" alt="image-20211129183152316"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183232116.png" alt="image-20211129183232116"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183252144.png" alt="image-20211129183252144"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183306276.png" alt="image-20211129183306276"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183320178.png" alt="image-20211129183320178"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="SpringBoot父子工程搭建"><a href="#SpringBoot父子工程搭建" class="headerlink" title="SpringBoot父子工程搭建"></a>SpringBoot父子工程搭建</h1><p>参考文档：<a href="https://www.hangge.com/blog/cache/detail_2833.html">https://www.hangge.com/blog/cache/detail_2833.html</a></p><h3 id="1、创建父工程"><a href="#1、创建父工程" class="headerlink" title="1、创建父工程"></a>1、创建父工程</h3><ol><li><p>先使用<strong>Spring Initializr</strong>创建demo的父工程，这边建议使用<a href="https://start.aliyun.com/%E8%80%8C%E4%B8%8D%E6%98%AFhttps://start.spring.io/">https://start.aliyun.com/而不是https://start.spring.io/</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190738996.png"></p><p>在不选择任何依赖的时候，默认的pom文件如下</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-boot.version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-boot.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-boot.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.example.demo.DemoApplication<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按需添加或者删除即可</p></li><li><p>删除工程中不需要的文件，及保留下图对应的文件即可</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121185800439.png" alt="image-20211121185800439"></p><p>只保留：**.idea** 文件夹 、项目 <strong>pom</strong> 文件、以及一个 <em><strong>.iml</strong> 文件，使用git的话，也可保留</em>*.gitignore**文件。</p><p><strong>注意</strong>： 因为父模块只做依赖管理，不需要编写代码，所以 <strong>src</strong> 文件夹可以直接删除。</p></li></ol><h3 id="2、创建子模块"><a href="#2、创建子模块" class="headerlink" title="2、创建子模块"></a>2、创建子模块</h3><ol><li><p>右键父工程，依次创建模块demo-01和demo-02</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211120171956114.png" alt="image-20211120171956114"></p></li><li><p>注意创建的模块所属的父工程</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190038939.png" alt="image-20211121190038939"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190100808.png" alt="image-20211121190100808"></p></li><li><p>删除不需要的文件</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190007792.png" alt="image-20211121190007792"></p></li></ol><h3 id="3、编辑父工程pom-xml-文件"><a href="#3、编辑父工程pom-xml-文件" class="headerlink" title="3、编辑父工程pom.xml 文件"></a>3、编辑父工程pom.xml 文件</h3><p>将父工程 <strong>pom.xml</strong> 文件修改成如下内容，里面声明该父工程包含的子模块，同时抽取统一的配置信息和依赖版本控制，这样可以方便子 <strong>pom</strong> 直接引用，简化子 <strong>pom</strong> 的配置。</p><blockquote><ul><li>多模块项目中，父模块打包类型必须是pom</li><li>因为开发框架是SpringBoot，夫模块默认继承spring-boot-starter-parent，因此可以删除spring-boot-starter和spring-boot-starter-test（父模块已经包含了）</li></ul></blockquote><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 父模块打包类型必须为pom --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- parent指明继承关系，给出被继承的父项目的具体信息，可以删除spring-boot-starter和spring-boot-starter-test依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 模块说明：这里声明多个子模块 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>demo-01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>demo-02<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--定义版本号的，下面dependencies或者dependencyManagement会引用--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--下面的dependencyManagement引用到的--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-cloud.version</span><span class="token punctuation">></span></span>Hoxton.SR10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-cloud.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--统一父子模块版本用的--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-boot.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--同上--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、编辑子模块pom-xml文件"><a href="#4、编辑子模块pom-xml文件" class="headerlink" title="4、编辑子模块pom.xml文件"></a>4、编辑子模块pom.xml文件</h3><p>子模块的<strong>pom.xml</strong>需要继承本项目的父工程，其中 <strong>parent</strong> 要使用顶层的父模块</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.wzy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 继承本项目的父工程 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--不需要了，引用的父工程的--></span>    &lt;!--<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--引入自己需要的依赖即可--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        ....    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>同上    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-<a href="####%E5%85%B3%E4%BA%8E%E5%AD%90%E5%B7%A5%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E4%BE%9D%E8%B5%96%E4%B8%8D%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E5%8F%B7">关于dependencyManagement和dependencies关系</a></p><h1 id="SpringCloud项目基础搭建"><a href="#SpringCloud项目基础搭建" class="headerlink" title="SpringCloud项目基础搭建"></a>SpringCloud项目基础搭建</h1><h3 id="1、父工程demo-cloud"><a href="#1、父工程demo-cloud" class="headerlink" title="1、父工程demo-cloud"></a>1、父工程demo-cloud</h3><p>创建SpringBoot工程</p><p>删除不需要的文件</p><p>添加配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--依赖的父工程--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-cloud.version</span><span class="token punctuation">></span></span>Hoxton.SR10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-cloud.version</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--先行准备的--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mysql.version</span><span class="token punctuation">></span></span>5.1.47<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mysql.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mybatis.version</span><span class="token punctuation">></span></span>2.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mybatis.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--父工程下的子模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>service-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>service-order<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--必须要的--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- springCloud --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-cloud.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- mysql驱动 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mysql.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--mybatis--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mybatis.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、子工程service-user"><a href="#2、子工程service-user" class="headerlink" title="2、子工程service-user"></a>2、子工程service-user</h3><p>创建项目，删除不需要的文件</p><p>添加配置文件，配置文件同service-order</p><p>依次创建包mapper，pojo，service，web包</p><p>pojo.User</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper.UserMapper</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from tb_user where id = #&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>service.UserService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>web.UserController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token comment">/**     * @param id 用户id     * @return 用户     */</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8081spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud_user?charsetEncoding&#x3D;utf8&amp;serverTimeZone&#x3D;UTC&amp;useSSL&#x3D;false    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Drivermybatis:  type-aliases-package: com.wzy.serviceuser.pojo  configuration:    map-underscore-to-camel-case: truelogging:  level:    cn.itcast: debug  pattern:    dateformat: MM-dd HH:mm:ss:SSS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、子工程service-order"><a href="#3、子工程service-order" class="headerlink" title="3、子工程service-order"></a>3、子工程service-order</h3><p>创建项目，删除不需要的文件</p><p>添加配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.wzy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>service-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>service-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-boot.version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-boot.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--mybatis--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">></span></span>app<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依次创建包mapper，pojo，service，web包</p><p>mapper.OrderMapper</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OrderMapper</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from tb_order where id = #&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">Order</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>pojo.Order</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> num<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> userId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">User</span> user<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pojo.User</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>service.OrderService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">OrderMapper</span> orderMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.查询订单</span>        <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.利用RestTemplate发起http请求，查询用户</span>        <span class="token comment">// 2.1.url路径</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/user/"</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2.发送http请求，实现远程调用</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.封装user到Order</span>        order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.返回</span>        <span class="token keyword">return</span> order<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>web.OrderController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">OrderService</span> orderService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"&#123;orderId&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderByUserId</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"orderId"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 根据id查询订单并返回</span>        <span class="token keyword">return</span> orderService<span class="token punctuation">.</span><span class="token function">queryOrderById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ServiceOrderApplication</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.wzy.serviceorder.mapper"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceOrderApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ServiceOrderApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 创建RestTemplate并注入Spring容器     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//添加负载均衡</span>    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8088spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud_order?charsetEncoding&#x3D;utf8&amp;serverTimeZone&#x3D;UTC&amp;useSSL&#x3D;false    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver  application:    name: service-ordermybatis:  type-aliases-package: com.wzy.serviceorder.pojo  configuration:    map-underscore-to-camel-case: truelogging:  level:    cn.itcast: debug  pattern:    dateformat: MM-dd HH:mm:ss:SSS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a>.</p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211120141319992.png" alt="image-20211120141319992"></p><h3 id="消费者和提供者"><a href="#消费者和提供者" class="headerlink" title="消费者和提供者"></a>消费者和提供者</h3><ul><li>服务提供者:一次业务中，被其它微服务调用的服务。(提供接口给其它微服务)</li><li>服务消费者:一次业务中，调用其它微服务的服务。(调用其它微服务提供的接口)</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211120163221429.png" alt="image-20211120163221429"></p><blockquote><p>Q:服务A调用服务B，服务B调用服务C，那么服务B是什么角色?</p><p>A:既是服务提供者也是服务消费者</p></blockquote><p><strong>服务调用关系</strong></p><ul><li>服务提供者:暴露接口给其它微服务调用</li><li>服务消费者:调用其它微服务提供的接口</li><li>提供者与消费者角色其实是相对的</li><li>一个服务可以同时是服务提供者和服务消费者</li></ul><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><h3 id="eureka搭建"><a href="#eureka搭建" class="headerlink" title="eureka搭建"></a>eureka搭建</h3><ol><li><p>创建项目</p><p>eureka-server模块</p></li><li><p>导入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--父工程如果引入了cloud的依赖，版本号不用声明--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意cloud和boot版本的对应关系,版本对应不上会出现下面的异常</p><p>Failed to process import candidates for configuration class [com.wzy.EurekaApplication]; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</p></li><li><p>编写启动类，添加@EnableEurekaServer注解</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaApplication.class, args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加application.yml文件，编写下面的配置</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8082spring:  application:    name: eurekaserver # 服务名称，配置文件中的服务名称如果改了，记得改类里面的服务路径eureka:  client:    service-url: #erueka的地址信息      defaultZone: http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;eureka  #自己注册自己，配置集群时，让其他的注册中心发现自己<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>输入<a href="http://127.0.0.1:8082/eureka">http://127.0.0.1:8082/eureka</a></p><p><img src="C:\Users\WZY\AppData\Roaming\Typora\typora-user-images\image-20211121115007279.png" alt="image-20211121115007279"></p></li></ol><h3 id="eureka注册"><a href="#eureka注册" class="headerlink" title="eureka注册"></a>eureka注册</h3><p>将service-order和service-user注册到注册中心</p><ol><li><p>service-order和service-user添加依赖，不同于eureka-server模块的依赖，这里添加的是客户端依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--eureka客户端依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加配置</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  application:    name: eurekaserver # 服务名称eureka:  client:    service-url: #erueka的地址信息      defaultZone: http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;eureka  #向eureka注册中心注册自己的服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动服务就可以在注册中心看到实例了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121120356620.png" alt="image-20211121120356620"></p></li></ol><h3 id="单机模拟多实例"><a href="#单机模拟多实例" class="headerlink" title="单机模拟多实例"></a>单机模拟多实例</h3><p>可以在Services看到web项目</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121134043848.png" alt="image-20211121134043848"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121133834174.png" alt="image-20211121133834174"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121133950988.png" alt="image-20211121133950988"></p><h3 id="eureka拉取服务"><a href="#eureka拉取服务" class="headerlink" title="eureka拉取服务"></a>eureka拉取服务</h3><p>在service-order中完成服务的拉取</p><ol><li><p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡</p><p><code>String url = &quot;http://SERVICE-USER/user/&quot; + order.getUserId();</code></p></li><li><p>在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//添加负载均衡</span><span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><h3 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a>负载均衡流程</h3><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121141123680.png" alt="image-20211121141123680"></p><p><strong>@LoadBalanced //添加负载均衡</strong>，RestTemplate发起的http请求被Ribbon拦截到</p><p>那么是如何被拦截的呢？</p><p>首先看下面这个拦截器类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalancerInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">ClientHttpRequestInterceptor</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个拦截器实现了ClientHttpRequestInterceptor接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 拦截客户端发出的HTTP请求 * Intercepts client-side HTTP requests. Implementations of this interface can be * &#123;@linkplain org.springframework.web.client.RestTemplate#setInterceptors registered&#125; * with the &#123;@link org.springframework.web.client.RestTemplate RestTemplate&#125;, * as to modify the outgoing &#123;@link ClientHttpRequest&#125; and/or the incoming * &#123;@link ClientHttpResponse&#125;. */</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ClientHttpRequestInterceptor</span> <span class="token punctuation">&#123;</span><span class="token class-name">ClientHttpResponse</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span> <span class="token class-name">ClientHttpRequestExecution</span> execution<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoadBalancerInterceptor实现了intercept方法，从而拦截了RestTemplate发起的http请求</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ClientHttpResponse</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span><span class="token keyword">final</span> <span class="token class-name">ClientHttpRequestExecution</span> execution<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">final</span> <span class="token class-name">URI</span> originalUri <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> serviceName <span class="token operator">=</span> originalUri<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>serviceName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">"Request URI does not contain a valid hostname: "</span> <span class="token operator">+</span> originalUri<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>requestFactory<span class="token punctuation">.</span><span class="token function">createRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> body<span class="token punctuation">,</span> execution<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>URI处打上断点</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121141719952.png" alt="image-20211121141719952"></p><p>查看request，可以看到RestTemplate发出的请求</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121141856908.png" alt="image-20211121141856908"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142035836.png" alt="image-20211121142035836"></p><p>获取服务名称SERVICE-USER</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142121571.png" alt="image-20211121142121571"></p><p>开始接触Ribbon负载均衡客户端</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142214668.png" alt="image-20211121142214668"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142241897.png" alt="image-20211121142241897"></p><p>获取服务，观察loadBalancer对象，loadBalancer中会有获取到的服务列表。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142621585.png" alt="image-20211121142621585"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//代码解释</span><span class="token class-name">ILoadBalancer</span> loadBalancer <span class="token operator">=</span> <span class="token function">getLoadBalancer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>从注册中心获取服务列表<span class="token class-name">Server</span> server <span class="token operator">=</span> <span class="token function">getServer</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">,</span> hint<span class="token punctuation">)</span><span class="token punctuation">;</span>做负载均衡，选择一个服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142833812.png" alt="image-20211121142833812"></p><p>进入方法，可以看见正在选择服务</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143154496.png" alt="image-20211121143154496"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143257174.png" alt="image-20211121143257174"></p><p>开始选择负载均衡的规则，可以看到选择的是ZoneAvoidanceRule</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143341683.png" alt="image-20211121143341683"></p><p>观察这个rule对象，是IRule类型的对象，查看IRule的实现类，可以看见常见的负载均衡策略</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143709371.png" alt="image-20211121143709371"></p><p>继续向下就可以看到拿到8083的服务了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143843066.png" alt="image-20211121143843066"></p><h4 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a><strong>整体流程图</strong></h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121145253232.png" alt="image-20211121145253232"></p><h3 id="Ribbon负载均衡-1"><a href="#Ribbon负载均衡-1" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h3><h4 id="Ribbon中的负载均衡类"><a href="#Ribbon中的负载均衡类" class="headerlink" title="Ribbon中的负载均衡类"></a>Ribbon中的负载均衡类</h4><p>Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121154441429.png" alt="image-20211121154441429"></p><table><thead><tr><th>内置负载均衡规则类</th><th>规则描述</th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略:<br/>(1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。<br/>(2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<br/><clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>weightedResponseTimeRule</td><td>每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td>zoneAvoidanceRule</td><td>为以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。（平常使用是没有Zone这个概念的，相当于RoundRobin）</td></tr><tr><td>BestAvailableRule</td><td>忽略哪些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><h4 id="调整负载均衡策略"><a href="#调整负载均衡策略" class="headerlink" title="调整负载均衡策略"></a>调整负载均衡策略</h4><p>通过定义IRule实现可以修改负载均衡规则，有两种方式:</p><p>1.代码方式，在service-order中配置类中，定义一个新的IRule</p><p>作用于全局，无论调用那个微服务都是这个策略</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic IRule randomRule() &#123;    return new RandomRule();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.配置文件方式，在application.yml中，添加新的配置来修改规则</p><p>这种是针对某个微服务的</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">userservice:  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbanlancer.RandomRule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Ribbon饥饿加载"><a href="#Ribbon饥饿加载" class="headerlink" title="Ribbon饥饿加载"></a>Ribbon饥饿加载</h3><p>Ribbon默认是采用懒加载，即第一次访问时（请求经过LoadBalancerInterceptor拦截器处理））才会去创建LoadBalanceClient，请求</p><p>时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">ribbon:  eager-load:    enabled: true #开启饥饿加载    clients: SERVICE-USER #指定对SERVICE-USER这个服务饥饿加载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>Nacos官网<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p><h3 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h3><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161304634.png" alt="image-20211121161304634"></p><h4 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h4><ol><li><p>GitHub下载</p><p><a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161825178.png" alt="image-20211121161825178"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161757603.png" alt="image-20211121161757603"></p><ol start="2"><li><p>解压，目录结构</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161917330.png" alt="image-20211121161917330"></p></li><li><p>修改配置问价</p><p>如果8848端口被占用，去conf目录下修改配置文件</p></li><li><p>启动</p><ul><li>双击启动</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121162008190.png" alt="image-20211121162008190"></p><ul><li>windwos命令行启动</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">startup.cmd -m standaloner #单机模式启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>启动效果</strong></p><p><img src="C:\Users\WZY\AppData\Roaming\Typora\typora-user-images\image-20211121164825447.png" alt="image-20211121164825447"></p><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p>界面，账号密码都是nacos</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121165215491.png" alt="image-20211121165215491"></p><p>控制台</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121165457590.png" alt="image-20211121165457590"></p></li></ol><blockquote><p>Q:Nacos启动报错：java.io.IOException: java.lang.IllegalArgumentException: db.num is null</p><p>A:：Notepad++打开<code>startup.cmd</code>文件</p><p>修改27行的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span><span class="token string">"cluster"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span><span class="token string">"standalone"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说把启动模式从<strong>集群</strong>改为<strong>单机</strong></p></blockquote><h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><p>Linux或者Mac安装方式与Windows类似。</p><p><strong>安装JDK</strong></p><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xvf jdk-8u144-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重命名为java</p><p>配置环境变量：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;javaexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置环境变量：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">source &#x2F;etc&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>上传安装包</strong></p><p>如图：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210402161102887.png" alt="image-20210402161102887"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402163715580.png" alt="image-20210402163715580"></p><p><strong>解压</strong></p><p>命令解压缩安装包：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xvf nacos-server-1.4.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后删除安装包：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">rm -rf nacos-server-1.4.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录中最终样式：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402164414827.png" alt="image-20210402164414827"></p><p><strong>端口配置</strong></p><p>与windows中类似</p><p><strong>启动</strong></p><p>在nacos/bin目录中，输入命令启动Nacos：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sh startup.sh -m standalone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Nacos使用"><a href="#Nacos使用" class="headerlink" title="Nacos使用"></a>Nacos使用</h3><h4 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a>服务注册到Nacos</h4><ol><li><p>父工程demo-cloud添加spring-cloud-alilbaba的管理依赖:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注释掉service-order和service-user中原有的eureka依赖。</p></li><li><p>添加nacos的客户端依赖:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- nacos客户端依赖包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>service-order和service-user添加配置，注掉eureka的配置，ribbon等配置不需要注掉，因为是通用的</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring: #nacos配置是spring下的  cloud:    nacos:      server-addr: localhost:8848  #nacos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>注册界面</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121171845744.png" alt="image-20211121171845744"></p><h3 id="Nacos服务分级存储模型"><a href="#Nacos服务分级存储模型" class="headerlink" title="Nacos服务分级存储模型"></a>Nacos服务分级存储模型</h3><p><strong>Nacos服务分级</strong></p><ul><li><p>一级是服务，例如service</p></li><li><p>二级是集群，例如杭州或上海</p></li><li><p>三级是实例，例如杭州机房的某台部署了service的服务器</p></li></ul><p>图示</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121194712839.png" alt="image-20211121194712839"></p><h4 id="服务集群调用问题"><a href="#服务集群调用问题" class="headerlink" title="服务集群调用问题"></a>服务集群调用问题</h4><p>服务调用尽可能选择本地集群的服务，跨集群调用延迟较高</p><p>本地集群不可访问时，再去访问其它集群</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121200229569.png" alt="image-20211121200229569"></p><h4 id="服务集群属性"><a href="#服务集群属性" class="headerlink" title="服务集群属性"></a>服务集群属性</h4><p><strong>设置服务集群属性</strong></p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  cloud:nacos:  server-addr: localhost:8848 # nacos服务端地址  discovery:   cluster-name: HZ #配置集群名称，也就是机房位置，例如:HZ，杭州<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Nacos控制台可以看到集群的变化</strong></p><p>这里配置了service-user的集群</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121195759746.png" alt="image-20211121195759746"></p><p>这里配置了service-order的集群</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121203637993.png" alt="image-20211121203637993"></p><p>但是我们多次访问<a href="http://localhost:8088/order/103%EF%BC%8C%E5%8F%91%E7%8E%B0%E4%B8%89%E4%B8%AAservice-user%E5%AE%9E%E4%BE%8B%E9%83%BD%E4%BC%9A%E8%A2%AB%E8%AE%BF%E9%97%AE%E5%88%B0%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82">http://localhost:8088/order/103，发现三个service-user实例都会被访问到，而不是访问本地集群的服务。</a></p><p>这时就需要在service-order中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">userservice:  ribbon:NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRlue#负载均衡规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在多次访问，service-order会在本地集群中找service-user服务随机访问，不是轮询访问。即确定了可用实例列表后，再采用随机负载均衡挑选实例。</p><p>当HZ集群的service-user实例服务全部挂掉，会发生什么呢？红色表示服务已经挂掉</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121204756763.png" alt="image-20211121204756763"></p><p>此时HZ集群的service-order会发生跨集群访问，去存在服务实例的SH集群去调用服务。并且会报警告</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121205021701.png"></p><h4 id="根据权重负载均衡"><a href="#根据权重负载均衡" class="headerlink" title="根据权重负载均衡"></a>根据权重负载均衡</h4><p>实际部署中会出现这样的场景:</p><p>​        服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求</p><p>Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高</p><p><strong>实例的权重控制</strong></p><p>Nacos控制台可以设置实例的权重值，0~1之间</p><p>同集群内的多个实例，权重越高被访问的频率越高</p><p>权重设置为0则完全不会被访问</p><p><strong>Nacos设置权重</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121205804446.png" alt="image-20211121205804446"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121205829508.png" alt="image-20211121205829508"></p><h3 id="Nacos环境隔离"><a href="#Nacos环境隔离" class="headerlink" title="Nacos环境隔离"></a>Nacos环境隔离</h3><p>在微服务体系中，一个系统往往被拆分为多个服务，每个服务都有自己的配置文件，然后每个系统往往还会准备开发环境、测试环境、正</p><p>式环境。</p><p>我们来说算一算，假设某系统有10个微服务，那么至少有10个配置文件吧，三个环境（dev\test\prod），那就有30个配置文件需要进行</p><p>管理。</p><p>这么多的配置文件，要修改一个或者多个的时候，稍有不慎可能就会出现改错了、不生效…等等问题。</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121215104767.png" alt="image-20211121215104767" style="zoom:50%;" /><p>Nacos引入了命名空间(Namespace)的概念来进行多环境配置和服务的管理及隔离</p><p>Namespace也是官方推荐的多环境支持方案。</p><h5 id="如何进行配置和服务的管理、隔离"><a href="#如何进行配置和服务的管理、隔离" class="headerlink" title="如何进行配置和服务的管理、隔离"></a>如何进行配置和服务的管理、隔离</h5><p>当我们的服务达到一定的数量，集中式的管理许多服务会十分不便，</p><p>那我们可以将这些具有相同特征或属性的服务进行分组管理，服务对应的配置也进行分组隔离</p><p>这里的分组就是Namespace的概念，将服务和配置纳入相同的Namespace进行管理</p><p>不同Namespace下的服务和配置之间就隔离开来,<strong>不同namespace下的服务不可见</strong>。</p><h5 id="创建和获取NamespaceID，并配置"><a href="#创建和获取NamespaceID，并配置" class="headerlink" title="创建和获取NamespaceID，并配置"></a>创建和获取NamespaceID，并配置</h5><p>每个namespace都有唯一id</p><p>NamespaceId值是在配置文件配置时必须要填入的配置项，所以需要我们先创建Namespace和Id，步骤如下：</p><ul><li>可以发现默认都在public命名空间下，nacos 的控制台左边功能栏看到有一个命名空间的功能，点击就可以看到新建命名空间的按钮</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121214312716.png" alt="image-20211121214312716"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121214236492.png" alt="image-20211121214236492"></p><ul><li><p>新建成功后，可以在命名空间列表中查看到你所创建的Namespace和他生成的ID值<br><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121214341349.png" alt="image-20211121214341349"></p></li><li><p>service-order项目中引入,在application中添加namespace</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8088spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud_order?charsetEncoding&#x3D;utf8&amp;serverTimeZone&#x3D;UTC&amp;useSSL&#x3D;false    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver  application:    name: service-order  cloud:    nacos:      server-addr: localhost:8848  #nacos      discovery:        cluster-name: HZ #配置集群名称，也就是机房位置，例如:HZ，杭州        namespace: 774391eb-8c2d-41a9-bc57-71f913f3c61d #测试用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重启service-order后，我们可以在dev命名空间下看到，此时已经和public命名空间下的服务实例隔离开了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121215526967.png" alt="image-20211121215526967"></p></li></ul><h3 id="Nacos注册中心细节"><a href="#Nacos注册中心细节" class="headerlink" title="Nacos注册中心细节"></a>Nacos注册中心细节</h3><p><img src="C:\Users\WZY\AppData\Roaming\Typora\typora-user-images\image-20211122141427597.png" alt="image-20211122141427597"></p><h4 id="设置临时实例和非临时实例"><a href="#设置临时实例和非临时实例" class="headerlink" title="设置临时实例和非临时实例"></a>设置临时实例和非临时实例</h4><p>服务注册到Nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  cloud:nacos:    discovery :ephemeral: false #设置为非临时实例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h3><h4 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122143228584.png" alt="image-20211122143228584"></p><h5 id="将配置交给Nacos管理的步骤"><a href="#将配置交给Nacos管理的步骤" class="headerlink" title="将配置交给Nacos管理的步骤"></a>将配置交给Nacos管理的步骤</h5><ol><li>在Nacos中添加配置文件</li><li>在微服务中引入nacos的config依赖</li><li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件</li></ol><h5 id="Nacos创建配置"><a href="#Nacos创建配置" class="headerlink" title="Nacos创建配置"></a>Nacos创建配置</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122153954495.png" alt="image-20211122153954495"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122153933324.png" alt="image-20211122153933324"></p><h5 id="Nacos配置和本地配置的区别"><a href="#Nacos配置和本地配置的区别" class="headerlink" title="Nacos配置和本地配置的区别"></a>Nacos配置和本地配置的区别</h5><p><strong>本地配置</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122143903440.png" alt="image-20211122143903440"></p><p><strong>Nacos配 置</strong></p><p>把读取nacos的流程加入其中</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122143937200.png" alt="image-20211122143937200"></p><p>但是存在问题，Nacos注册中心的配置在本地的application.yml中，怎样发现注册中心呢？</p><p>我们把和Nacos相关的配置放到<strong>bootstrap.yml</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122144233551.png" alt="image-20211122144233551"></p><h5 id="服务添加配置"><a href="#服务添加配置" class="headerlink" title="服务添加配置"></a>服务添加配置</h5><ol><li><p>引入Nacos的配置管理客户端依赖:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在service-user中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml</p><p>注意要将application.yml中的相同配置删除掉</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> serviceuser <span class="token comment"># 服务名称</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev <span class="token comment">#开发环境，这里是dev</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment">#Nacos地址</span>      <span class="token key atrule">config</span><span class="token punctuation">:</span>        <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yaml <span class="token comment">#文件后缀名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加新方法，测试能否读取到我们添加的配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;pattern.dateformat&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/now"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>dateformat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="配置自动更新"><a href="#配置自动更新" class="headerlink" title="配置自动更新"></a>配置自动更新</h4><p>Nacos中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现:·</p><h5 id="方式一-在-Value注入的变量所在类上添加注解-RefreshScope"><a href="#方式一-在-Value注入的变量所在类上添加注解-RefreshScope" class="headerlink" title="方式一:在@Value注入的变量所在类上添加注解@RefreshScope"></a>方式一:在@Value注入的变量所在类上添加注解@RefreshScope</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150454113.png" alt="image-20211122150454113"></p><p>效果如下</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150701932.png" alt="image-20211122150701932"><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150713697.png" alt="image-20211122150713697"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150737481.png" alt="image-20211122150737481"><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150746134.png" alt="image-20211122150746134"></p><h5 id="方式二-使用-ConfigurationProperties注解"><a href="#方式二-使用-ConfigurationProperties注解" class="headerlink" title="方式二:使用@ConfigurationProperties注解"></a>方式二:使用@ConfigurationProperties注解</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"pattern"</span><span class="token punctuation">)</span><span class="token comment">//prefix和变量名拼接，只要配置文件中有一致的，就自动完成注入</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122151632876.png" alt="image-20211122151632876"></p><h4 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h4><h5 id="微服务启动时会从nacos读取多个配置文件"><a href="#微服务启动时会从nacos读取多个配置文件" class="headerlink" title="微服务启动时会从nacos读取多个配置文件:"></a>微服务启动时会从nacos读取多个配置文件:</h5><ul><li><p>[spring.application.name]-[spring.profiles.active].yaml，例如: userservice-dev.yaml</p></li><li><p>[spring.application.name].yaml，例如: service-user.yaml</p></li></ul><p>无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件。</p><p>这里service-user会读取下面两个nacos配置</p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122154259638.png" alt="image-20211122154259638" style="zoom:50%;" /><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122154411447.png" style="zoom:50%;" /><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122154055151.png" alt="image-20211122154055151"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>service-user中添加要读取的配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"pattern"</span><span class="token punctuation">)</span><span class="token comment">//prefix和变量名拼接，只要配置文件中有一致的，就自动完成注入</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> envSharedValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//UserController</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">PatternProperties</span> <span class="token function">getPatternProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> patternProperties<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别以dev和test环境启动俩个实例</p><p><strong>如何在不修改配置文件的情况下修改启动环境</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122152915159.png" alt="image-20211122152915159"></p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122153018887.png" alt="image-20211122153018887" style="zoom:50%;" /><p>查看启动的两个实例</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122155248715.png" alt="image-20211122155248715"></p><h3 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h3><h4 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h4><p>官方给出的Nacos集群图：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day02-SpringCloud02\资料\assets\image-20210409210621117.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210409211355037.png" alt="image-20210409211355037"></p><h4 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h4><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h5 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h5><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'content'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'md5'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">COMMENT</span> <span class="token string">'source user'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'source ip'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>c_desc<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>c_use<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>effect<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">type</span><span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>c_schema<span class="token punctuation">`</span> <span class="token keyword">text</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfo_datagrouptenant<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_info'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_info_aggr   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info_aggr<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>datum_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'datum_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'内容'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfoaggr_datagrouptenantdatum<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>datum_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'增加租户字段'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_info_beta   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info_beta<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'app_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'content'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>beta_ips<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'betaIps'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'md5'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">COMMENT</span> <span class="token string">'source user'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'source ip'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfobeta_datagrouptenant<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_info_beta'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_info_tag   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info_tag<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tag_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tag_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'app_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'content'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'md5'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">COMMENT</span> <span class="token string">'source user'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'source ip'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfotag_datagrouptenanttag<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tag_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_info_tag'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_tags_relation   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_tags_relation<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tag_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tag_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tag_type<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tag_type'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>nid<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>nid<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configtagrelation_configidtag<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tag_name<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tag_type<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_tenant_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_tag_relation'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = group_capacity   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>group_capacity<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键ID'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'Group ID，空字符表示整个集群'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>quota<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'配额，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">usage</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'聚合子配置最大个数，，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_history_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'最大变更历史数量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_group_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'集群、各Group容量信息表'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = his_config_info   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>his_config_info<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>nid<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'app_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>op_type<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>nid<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_gmt_create<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_gmt_modified<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_did<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'多租户改造'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = tenant_capacity   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tenant_capacity<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键ID'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'Tenant ID'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>quota<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'配额，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">usage</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'聚合子配置最大个数'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_history_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'最大变更历史数量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_tenant_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'租户容量信息表'</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tenant_info<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>kp<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'kp'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_desc<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_desc'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>create_source<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'create_source'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_tenant_info_kptenantid<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>kp<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_tenant_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'tenant_info'</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>users<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span><span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>enabled<span class="token punctuation">`</span> <span class="token keyword">boolean</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>roles<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>role<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>idx_user_role<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">ASC</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>role<span class="token punctuation">`</span> <span class="token keyword">ASC</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>permissions<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>role<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>resource<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span><span class="token keyword">action</span><span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>uk_role_permission<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>role<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>resource<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span><span class="token keyword">action</span><span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> enabled<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'nacos'</span><span class="token punctuation">,</span> <span class="token string">'$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu'</span><span class="token punctuation">,</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> roles <span class="token punctuation">(</span>username<span class="token punctuation">,</span> role<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'nacos'</span><span class="token punctuation">,</span> <span class="token string">'ROLE_ADMIN'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h5><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.2版本：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day02-SpringCloud02\资料\assets\image-20210409212119411.png" alt="image-20210409212119411"></p><h5 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h5><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122164216637.png" alt="image-20211122164216637"></p><p>然后添加内容：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:8844127.0.0.1.8846127.0.0.1.8848<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后修改application.properties文件，添加数据库配置，去掉注释即可</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">spring.datasource.platform</span><span class="token punctuation">=</span><span class="token attr-value">mysql</span><span class="token attr-name">db.num</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token attr-name">db.url.0</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><span class="token attr-name">db.user.0</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">db.password.0</span><span class="token punctuation">=</span><span class="token attr-value">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h5><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210409213335538.png" alt="image-20210409213335538"> </p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8844</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nacos2:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8846</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nacos3:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8848</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后分别启动三个nacos节点：</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h5><p> <img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122164804563.png" alt="image-20211122164804563"></p><p>解压到任意非中文目录下：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122164750397.png" alt="image-20211122164750397"> </p><p>修改conf/nginx.conf文件，在http {}下添加，配置如下：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> nacos-cluster</span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8844</span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8846</span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8848</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">80</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server_name</span>  localhost</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">location</span> /nacos</span> <span class="token punctuation">&#123;</span>        <span class="token directive"><span class="token keyword">proxy_pass</span> http://nacos-cluster</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">80</span> <span class="token comment"># Nacos地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h5><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul><h2 id="Nacos和Eureka区别"><a href="#Nacos和Eureka区别" class="headerlink" title="Nacos和Eureka区别"></a>Nacos和Eureka区别</h2><h3 id="Nacos与eureka的共同点"><a href="#Nacos与eureka的共同点" class="headerlink" title="Nacos与eureka的共同点"></a>Nacos与eureka的共同点</h3><p>都支持服务注册和服务拉取</p><p>都支持服务提供者心跳方式做健康检测</p><h3 id="Nacos与Eureka的区别"><a href="#Nacos与Eureka的区别" class="headerlink" title="Nacos与Eureka的区别"></a><strong>Nacos与Eureka的区别</strong></h3><p>Nacos支持服务端主动检测提供者状态:临时实例采用心跳模式，非临时实例采用主动检测模式（会消耗服务器资源）</p><p>临时实例心跳不正常会被剔除，非临时实例则不会被剔除（会等到实例恢复）</p><p>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p><p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式;Eureka采用AP方式</p><h2 id="HTTP客户端Feign"><a href="#HTTP客户端Feign" class="headerlink" title="HTTP客户端Feign"></a>HTTP客户端Feign</h2><h3 id="Feign替代RestTemplate"><a href="#Feign替代RestTemplate" class="headerlink" title="Feign替代RestTemplate"></a>Feign替代RestTemplate</h3><h4 id="RestTemplate方式调用存在的问题"><a href="#RestTemplate方式调用存在的问题" class="headerlink" title="RestTemplate方式调用存在的问题"></a>RestTemplate方式调用存在的问题</h4><p>先来看我们以前利用RestTemplate发起远程调用的代码:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122170842824.png" alt="image-20211122170842824"></p><p>存在下面的问题:</p><ul><li><p>代码可读性差，编程体验不统一</p></li><li><p>参数复杂URL难以维护</p></li></ul><h4 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h4><p>Feign是一个声明式的http客户端，官方地址: https:/ /github.com/OpenFeign/feign其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122171112369.png" alt="image-20211122171112369"></p><h4 id="定义和使用Feign客户端"><a href="#定义和使用Feign客户端" class="headerlink" title="定义和使用Feign客户端"></a>定义和使用Feign客户端</h4><p>Feign的使用步骤</p><p>1.引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.添加@EnableFeignClients注解</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122185520894.png" alt="image-20211122185520894"></p><p>3.编写FeignClient接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"serviceuser"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是基于SpringMVC的注解来声明远程调用的信息，比如:</p><ul><li><p>服务名称: userservice</p></li><li><p>请求方式:GET</p></li><li><p>请求路径: /user/{id}</p></li><li><p>请求参数:Long id</p></li><li><p>返回值类型:User</p></li></ul><p>4.使用Feignclient中定义的方法代替RestTemplate</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">UserClient</span> userClient<span class="token punctuation">;</span><span class="token comment">//使用Feign发请求</span><span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.查询订单</span>    <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.使用Feign发请求</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.封装user到Order</span>    order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.返回</span>    <span class="token keyword">return</span> order<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><h4 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h4><p>Feign运行自定义配置来覆盖默认配置，可以修改的配置如下:</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>feign.Logger.Level</td><td>修改日志级别</td><td>包含四种不同的级别:NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign.Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试，feign底层依赖ribbon</td></tr></tbody></table><h4 id="配置Feign日志"><a href="#配置Feign日志" class="headerlink" title="配置Feign日志"></a>配置Feign日志</h4><p>Feign的自定义配置，用到的最多的就是日志配置</p><p>配置Feign日志有两种方式:</p><ul><li><p>方式一:配置文件方式</p><p>全局生效:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment">#日志级别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>局部生效</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment">#日志级别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置Feign日志的方式二: java代码方式，需要先声明一个Bean:</p><p>bean上没有@Configuration注解，需要按照下面的方式让bean生效</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFeignConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span> <span class="token function">logLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span><span class="token punctuation">.</span>BASIC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后如果是全局配置，则把它放到@EnableFeignClients这个注解中:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是局部配置，则把它放到@FeignClient这个注解中:这里只针对serviceuser这个服务</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"serviceuser"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="Feign优化使用"><a href="#Feign优化使用" class="headerlink" title="Feign优化使用"></a>Feign优化使用</h3><p>因此优化Feign的性能主要包括</p><p>使用连接池代替默认的URLConnection（使用线程池来减少线程创建和销毁时带来的资源消耗）</p><p>日志级别，最好用basic或none（日志内容太多也会消耗资源）</p><h4 id="Feign客户端优化"><a href="#Feign客户端优化" class="headerlink" title="Feign客户端优化"></a>Feign客户端优化</h4><p><strong>Feign底层的客户端实现:</strong></p><p>URLConnection:默认实现，不支持连接池</p><p>Apache HttpClient :支持连接池</p><p>OKHttp:支持连接池</p><p><strong>使用HttpClient</strong> </p><ol><li><p>引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--httpClient的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置连接池</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> BASIC <span class="token comment">#日志级别，BASIC就是基本的请求和响应信息</span>  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#开启feign对HttpClient的支持</span>    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">200</span> <span class="token comment">#最大的连接数</span>    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50</span> <span class="token comment">#每个路径的最大连接数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="方式一（继承）"><a href="#方式一（继承）" class="headerlink" title="方式一（继承）"></a>方式一（继承）</h4><p>给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122200440093.png" alt="image-20211122200440093"></p><h4 id="方式二（抽取"><a href="#方式二（抽取" class="headerlink" title="方式二（抽取)"></a>方式二（抽取)</h4><p>将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122200515495.png" alt="image-20211122200515495" style="zoom:80%;" /><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122200531476.png" alt="image-20211122200531476"></p><p>实现最佳实践方式二的步骤如下:</p><p>1．首先创建一个module，命名为feign-client，然后引入feign的starter依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--feign客户端--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2．将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中,删除掉service-order中的UserClient、User、DefaultFeignConfiguration</p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122203107489.png" alt="image-20211122203107489" style="zoom:67%;" /><p>3．在order-service中引入feign-api的依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--引入feign的统一api--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4．修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包</p><p>5．重启测试</p><p>6．发现问题</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122204711888.png" alt="image-20211122204711888"></p><p>UserClient属于外部引入的包，Spring默认扫描的是和启动类同级的目录，Spring容器中找不到，我们添加外部的扫描即可；</p><p>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决:</p><p>方式一:指定FeignClient所在包</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.wzy.feign.client"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二︰指定FeignClient字节码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>clients <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token class-name">UserClient</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h2><h3 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h3><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123154958199.png" alt="image-20211123154958199"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123155007912.png" alt="image-20211123155007912"></p><h4 id="网关功能"><a href="#网关功能" class="headerlink" title="网关功能:"></a>网关功能:</h4><ul><li><p>身份认证和权限校验</p></li><li><p>服务路由、负载均衡</p></li><li><p>请求限流，</p></li></ul><h4 id="网关的技术实现"><a href="#网关的技术实现" class="headerlink" title="网关的技术实现"></a>网关的技术实现</h4><p>在SpringCloud中网关的实现包括两种:</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloud Gateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h3 id="Gateway快速入门"><a href="#Gateway快速入门" class="headerlink" title="Gateway快速入门"></a>Gateway快速入门</h3><h4 id="搭建网关服务"><a href="#搭建网关服务" class="headerlink" title="搭建网关服务"></a>搭建网关服务</h4><p>1.创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖（Gateway从nacos拉取服务列表）:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- nacos客户端依赖包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- gateway网关依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.编写路由配置及nacos地址</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10010</span> <span class="token comment">#网关端口</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway <span class="token comment">#服务名称</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span> <span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">80</span> <span class="token comment">#nacos地址</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>user           <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//serviceuser           <span class="token key atrule">predicates</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>         <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>order          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//service<span class="token punctuation">-</span>order          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/order/<span class="token important">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置参数routes，可以是数组</p><ul><li>id：路由id，自定义，只要唯一即可</li><li>uri：路由的目标地址<ul><li>http就是固定地址     http:/ /127.0.0.2:8881  </li><li>lb就是负载均街，后面跟服务名称    lb://serviceuser</li></ul></li><li>predicates: 路由断言，也就是判断请求是否符合路由规则的条件<ul><li>Path=/user/** 这个是按照路径匹配，只要以/user/开头就符合要求，就会匹配到//serviceuser/user/**路径下</li></ul></li><li>filters：路由过滤器，对请求或响应做处理</li></ul><h4 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123164245348.png" alt="image-20211123164245348"></p><h3 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h3><h4 id="路由断言工厂Route-Predicate-Factory"><a href="#路由断言工厂Route-Predicate-Factory" class="headerlink" title="路由断言工厂Route Predicate Factory"></a>路由断言工厂Route Predicate Factory</h4><ul><li>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</li><li>例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的</li><li>像这样的断言工厂在SpringCloudGateway还有十几个</li></ul><h4 id="Predicate工厂"><a href="#Predicate工厂" class="headerlink" title="Predicate工厂"></a>Predicate工厂</h4><p>Spring提供了11种基本的Predicate工厂:</p><p>官网：<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories</a></p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>- Before=2031-04-13T15:14:47.433+08:OO[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denverj</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=x-Request-ld,\d+</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名)</td><td>- Host=<em>.somehost.org,”</em>.anotherhost.org</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment}. /blue/*</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=narne,Jack或者- Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1,24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><h3 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h3><h4 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h4><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理:</p><p>请求在网关经历了什么</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123171321338.png" alt="image-20211123171321338"></p><p>过滤器是链式的</p><h4 id="Spring提供的过滤器工厂"><a href="#Spring提供的过滤器工厂" class="headerlink" title="Spring提供的过滤器工厂"></a>Spring提供的过滤器工厂</h4><p>官网：<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories</a></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr></tbody></table><p><strong>示例</strong></p><p>给所有进入serviceuser的请求添加一个请求头:Truth=freaking awesome!</p><p>实现方式:在gateway中修改application.yml文件，给serviceuser的路由添加过滤器:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>user           <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//serviceuser           <span class="token key atrule">predicates</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>           <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment">#过速器</span>              <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span>freaking awesome<span class="token tag">!</span> <span class="token comment">#添加请求头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="默认过滤器DefaultFilter"><a href="#默认过滤器DefaultFilter" class="headerlink" title="默认过滤器DefaultFilter"></a>默认过滤器DefaultFilter</h4><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>user           <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//serviceuser           <span class="token key atrule">predicates</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>       <span class="token key atrule">default-filters</span><span class="token punctuation">:</span> <span class="token comment">#默认过滤器，会对所有的路由请求都生效</span>      <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span>freaking awesome<span class="token tag">!</span> <span class="token comment">#添加请求头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>前面了解的都是局部的过滤器和默认过滤器</p><h4 id="全局过滤器GlobalFilter"><a href="#全局过滤器GlobalFilter" class="headerlink" title="全局过滤器GlobalFilter"></a>全局过滤器GlobalFilter</h4><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter默认过滤器的作用一样。</p><p>区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现，做一些业务的判断。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 处理当前请求，有必要的话通过 &#123;@link GatewayFilterChain&#125;     *     * 将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息*     * @param chain 用来把请求委托给下一个过滤器     * @return &#123;@code Mono&lt;Void>&#125;返回标示当前过滤嚣业务结束     */</span>    <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span><span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>过滤authorization不等于admin的用户请求</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorizeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.获取请求</span>        <span class="token class-name">ServerHttpRequest</span> request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取请求中的authorization参数</span>        <span class="token class-name">MultiValueMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> params <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> auth <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.判断参数值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//4.放行，交由下一个exchange去处理</span>            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//5.设置响应状态码</span>        exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span><span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>UNAUTHORIZED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//6.拦截请求</span>        <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h4><p>请求进入网关会碰到三类过滤器:当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合)中，排序后依次执行每个过滤器</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123190334075.png" alt="image-20211123190334075"></p><ul><li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。<ul><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li></ul></li><li>当过滤器的order值一样时，会按照defaultFilter &gt;路由过滤器&gt;GlobalFilter的顺序执行。</li></ul><p>可以参考下面几个类的源码来查看:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123192610791.png" alt="image-20211123192610791"></p><p><strong>关于为什么过滤器会放在一个集合里</strong></p><p>按道理一个集合中数据类型应该相同，但是Gateway会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中。这是因为当前路由过滤器和DefaultFilter都是在配置文件中定义，AddRequestHeaderGatewayFilterFactory这个类会加载配置文件，生成真正的路由器，返回的是GatewayFilter。GlobalFilter是通过适配器适配成GatewayFilter的。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123192035213.png" alt="image-20211123192035213"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123192306559.png" alt="image-20211123192306559"></p><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p><a href="###%E4%BD%95%E4%B8%BA%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">跨域问题</a></p><p>跨域:域名不一致就是跨域，主要包括:</p><ul><li><p>域名不同: <a href="http://www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com/">www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com</a></p></li><li><p>域名相同，端口不同: localhost:8080和localhost8081</p></li></ul><p>跨域问题:<strong>浏览器禁止</strong>请求的发起者与服务端发生<strong>跨域ajax请求</strong>，请求被浏览器拦截的问题</p><p>解决方案: <strong><a href="###%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS">CORS</a></strong></p><p>网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span> <span class="token comment">#。。 o</span>      <span class="token key atrule">globalcors</span><span class="token punctuation">:</span> <span class="token comment">#全局的跨域处理</span>        <span class="token key atrule">add-to-simple-url-handler-mapping</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#解决options请求被拦截问题,浏览器会发一个option类型的请求去询问服务器是否可以访问，但是网关是会拦截options请求的，true表示不拦截</span>        <span class="token key atrule">corsConfigurations</span><span class="token punctuation">:</span>          <span class="token key atrule">'[/**]'</span><span class="token punctuation">:</span>  <span class="token comment">#拦截那些请求，这里表示拦截所有</span>            <span class="token key atrule">allowed0rigins</span><span class="token punctuation">:</span> <span class="token comment">#允许哪些网站的跨域请求</span>              <span class="token punctuation">-</span> <span class="token string">"http://localhost:8090"</span>            <span class="token key atrule">allowedMethods</span><span class="token punctuation">:</span> <span class="token comment">#允许的跨域ajax的请求方式</span>            <span class="token punctuation">-</span> <span class="token string">"GET"</span>            <span class="token punctuation">-</span> <span class="token string">"POST"</span>            <span class="token punctuation">-</span> <span class="token string">"DELETE"</span>            <span class="token punctuation">-</span> <span class="token string">"PUT"</span>            <span class="token punctuation">-</span> <span class="token string">"OPTIONS"</span>            <span class="token key atrule">allowedHeaders</span><span class="token punctuation">:</span> “<span class="token important">*"</span> <span class="token comment">#允许在请求中携带的头信息</span>            <span class="token key atrule">allowCredentials</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#是否允许携带cookie</span>            <span class="token key atrule">maxAge</span><span class="token punctuation">:</span> <span class="token number">360000</span> <span class="token comment">#这次跨域检测的有效期,有效期内不校验直接放行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="关于子工程为什么有些依赖不需要添加版本号"><a href="#关于子工程为什么有些依赖不需要添加版本号" class="headerlink" title="关于子工程为什么有些依赖不需要添加版本号"></a>关于子工程为什么有些依赖不需要添加版本号</h3><p>可以参考文章<a href="https://www.jianshu.com/p/c8666474cf9a">https://www.jianshu.com/p/c8666474cf9a</a></p><p><strong>父工程</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- springCloud --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-cloud.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>子工程</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变</p><p>更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中</p><p>声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p><strong>dependencyManagement与dependencies区别：</strong></p><p>1)Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。</p><p>2)dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继</p><p>承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版</p><p>本号，那么会使用子项目中指定的jar版本。</p><h3 id="何为跨域问题"><a href="#何为跨域问题" class="headerlink" title="何为跨域问题"></a>何为跨域问题</h3><h4 id="一、为什么会出现跨域问题"><a href="#一、为什么会出现跨域问题" class="headerlink" title="一、为什么会出现跨域问题"></a>一、为什么会出现跨域问题</h4><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h4 id="二、什么是跨域"><a href="#二、什么是跨域" class="headerlink" title="二、什么是跨域"></a>二、什么是跨域</h4><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123205457040.png" alt="image-20211123205457040">)</p><h4 id="三、非同源限制"><a href="#三、非同源限制" class="headerlink" title="三、非同源限制"></a>三、非同源限制</h4><p>【1】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>【2】无法接触非同源网页的 DOM</p><p>【3】无法向非同源地址发送 AJAX 请求</p><h3 id="跨域问题解决方案CORS"><a href="#跨域问题解决方案CORS" class="headerlink" title="跨域问题解决方案CORS"></a>跨域问题解决方案CORS</h3><p>参考文档：<a href="https://zhuanlan.zhihu.com/p/24411090">https://zhuanlan.zhihu.com/p/24411090</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Nacos </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2021/11/29/nginx/"/>
      <url>/2021/11/29/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><h2 id="1、Nginx-是什么"><a href="#1、Nginx-是什么" class="headerlink" title="1、Nginx 是什么"></a>1、Nginx 是什么</h2><p>Nginx (“engine x”) 是一个开源的，支持高性能、高并发的 Web 服务和代理服务软件。它是由俄罗斯人 Igor Sysoev 开发的，最初被应用在俄罗斯的大型网站 <a href="https://www.rambler.ru/">www.rambler.ru</a> 上。后来作者将源代码以类 BSD 许可的形式开源出来供全球使用。</p><p>Nginx 的官方介绍见 <a href="http://nginx.org/en/">http://nginx.org/en/</a><br>Nginx 中文介绍见 <a href="http://tengine.taobao.org/nginx_docs/cn/">http://tengine.taobao.org/nginx_docs/cn/</a></p><h2 id="2、Nginx作为web服务器"><a href="#2、Nginx作为web服务器" class="headerlink" title="2、Nginx作为web服务器"></a>2、Nginx作为web服务器</h2><p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><p><img src="https://pic1.zhimg.com/v2-e1826bab1d07df8e97d61aa809b94a10_r.jpg" alt="preview">z</p><h2 id="3、正向代理-amp-反向代理"><a href="#3、正向代理-amp-反向代理" class="headerlink" title="3、正向代理&amp;反向代理"></a>3、正向代理&amp;反向代理</h2><h3 id="3-1、正向代理"><a href="#3-1、正向代理" class="headerlink" title="3.1、正向代理"></a>3.1、正向代理</h3><p>​        在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法</p><p>访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理</p><p>服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>　　上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服</p><p>务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><p><img src="https://pic4.zhimg.com/80/v2-c8ac111c267ae0745f984e326ef0c47f_720w.jpg" alt="img"></p><p>​    客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p><p>总结来说：正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原</p><p>始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户</p><p>端。客户端必须要进行一些特别的设置才能使用正向代理。</p><p>　　正向代理的用途：</p><p>（1）访问原来无法访问的资源，如Google</p><p>（2）可以做缓存，加速访问资源</p><p>（3）对客户端访问授权，上网进行认证</p><p>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h3 id="3-2、反向代理"><a href="#3-2、反向代理" class="headerlink" title="3.2、反向代理"></a>3.2、反向代理</h3><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代</p><p>理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器</p><p>地址，隐藏了真实服务器IP地址。</p><p><img src="https://pic2.zhimg.com/80/v2-4787a512240b238ebf928cd0651e1d99_720w.jpg" alt="img"></p><p>反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。</p><p>　　反向代理的作用：</p><p>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h3 id="3-3、二者区别"><a href="#3-3、二者区别" class="headerlink" title="3.3、二者区别"></a>3.3、二者区别</h3><p>　　截了一张图来说明正向代理和反向代理二者之间的区别，如图。</p><p><img src="https://img2018.cnblogs.com/blog/1202586/201812/1202586-20181211122806997-940664368.png" alt="img"></p><p><strong>图解：</strong></p><p>在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息；</p><p>在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息；</p><p>实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代</p><p>理方式称为反向代理了。</p><h2 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h2><p>​        我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p><p>　　这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。</p><p>　　请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。</p><p>　　所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p><p>　　负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵</p><p>成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到</p><p>成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。</p><h2 id="5、动静分离"><a href="#5、动静分离" class="headerlink" title="5、动静分离"></a>5、动静分离</h2><p>为了提高网站的响应速度，减轻程序服务器（Tomcat，Jboss等）的负载，对于静态资源，如图片、js、css等文件，可以在反向代理服务</p><p>器中进行缓存，这样浏览器在请求一个静态资源时，代理服务器就可以直接处理，而不用将请求转发给后端服务器。对于用户请求的动态</p><p>文件，如servlet、jsp，则转发给Tomcat，Jboss服务器处理，这就是动静分离。即动态文件与静态文件的分离。</p><h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><h3 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h3><p>官网：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209170756783.png" alt="image-20211209170756783"></p><p>下载，解压即可</p><p>目录</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209170822593.png" alt="image-20211209170822593"></p><p>启动命令</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">start nginx.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209170914680.png" alt="image-20211209170914680"></p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>1.获取nginx镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.拉取镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.启动nginx</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d --name mynginx -p 80:80 nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-d   指定容器以守护进程方式在后台运行</li><li>–name 指定容器名称，此处我指定的是mynginx</li><li>-p 指定主机与容器内部的端口号映射关系，格式 -p  [宿主机端口号]：[容器内部端口]，此处我使用了主机80端口，映射容器80端口</li><li>nginx:latest 是nginx的镜像名称和版本号</li></ul><blockquote><p>docker安装的镜像只有基本的功能，当我们想要使用vi/vim编辑器时，镜像中是没有的，所以我们要挂载数据卷。将nginx容器内部配置文件挂载到主机，之后就可以在主机对应目录修改即可。适合频繁修改，复杂使用的情况</p></blockquote><p>1.进入到nginx容器内部，</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker exec -it mynginx &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>exec 命令代表附着到运行着的容器内部</li><li>-it 是 -i 与 -t两个参数合并写法，-i -t 标志着为我们指定的容器创建了TTY并捕捉了STDIN</li><li>mynginx 是我们要进入的容器名</li><li>/bin/bash 指定了执行命令的shell</li></ul><p>进入到nginx容器内部后，我们可以<code>cd /etc/nginx</code>，可以看到相关的nginx配置文件都在<code>/etc/nginx</code>目录下</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209204053435.png" alt="image-20211209204053435"></p><p>进入到nginx容器内部后，我们可以<code>cd /etc/nginx</code>，可以看到相关的nginx配置文件都在<code>/etc/nginx</code>目录下</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209204436002.png" alt="image-20211209204436002"></p><p>而nginx容器内的默认首页html文件目录为<code>/usr/share/nginx/html</code>，日志文件位于<code>/var/log/nginx</code></p><p>1.在主机/mnt目录下执行命令创建挂载目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p .&#x2F;nginx&#x2F;&#123;conf,html,logs&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209204611177.png" alt="image-20211209204611177"></p><p>2.将容器内的<code>nginx.conf</code>与<code>default.conf</code>文件分别拷贝到主机<code>/mnt/nginx</code>与目录<code>/mnt/nginx/conf</code>下，分别执行 </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker cp mynginx:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf .&#x2F;dokcer cp mynginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf .&#x2F;conf&#x2F;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>cp 命令代表复制</li><li>mynginx是我们nginx容器名</li><li>/etc/nginx/nginx.conf 是容器内部nginx.conf 路径</li></ul><p>此时我们的目录结构是这样的，这就是我们等会儿要与nginx容器挂载的目录</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209204833700.png" alt="image-20211209204833700"></p><p>3.执行命令停止刚刚创建的nginx容器，eab12db是容器Id，然后执行命令移除容器，</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker stop eab12dbdocker rm eab12db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4.执行启动docker</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d --name mynginx -p 80:80 \-v &#x2F;mnt&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \-v &#x2F;mnt&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \-v &#x2F;mnt&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \-v &#x2F;mnt&#x2F;nginx&#x2F;conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d --privileged&#x3D;true nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>-v 挂载目录，格式 -v: 表示将主机目录与容器目录之间进行共享,</li><li>–privileged=true 容器内部对挂载的目录拥有读写等特权</li></ul><p>5.访问nginx，发现出现403。因为我们的主机挂载 <code>/mnt/nginx/html</code>目录还为空</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209205119801.png" alt="image-20211209205119801"></p><p>这时我们在容器的挂载 <code>/mnt/nginx/html</code>目录下创建<code>index.html,</code>内容随便写上<code>hello nginx</code>，再次访问主机IP</p><p>可以看见内容了</p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/83890573">https://zhuanlan.zhihu.com/p/83890573</a></p><h1 id="Nginx常用命令以及配置文件"><a href="#Nginx常用命令以及配置文件" class="headerlink" title="Nginx常用命令以及配置文件"></a>Nginx常用命令以及配置文件</h1><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>命令行命令</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209215647433.png" alt="image-20211209215647433"></p><p>下面分别对这些参数做下说明</p><ul><li>nginx -h：查看帮助</li><li>nginx -v：查看nginx的版本</li><li>nginx -V：查看版本和nginx的配置选项</li><li>nginx -t：测试配置文件的正确性</li><li>Nginx -T: 测试配置文件，并显示配置文件（这个命令可以快速查看配置文件）</li><li>nginx -q：测试配置文件，但是只显示错误信息</li><li>nginx -s：发送信号，下面详细介绍</li><li>nginx -p：设置前缀</li><li>nginx -c：设置配置文件</li><li>nginx -g：附加配置文件路径</li></ul><p><strong>运维命令</strong></p><ul><li><p>nginx  #打开 nginx</p></li><li><p>nginx -t     #测试配置文件是否有语法错误</p></li><li><p>nginx -s reopen  #重启Nginx</p></li><li><p>nginx -s reload    #重新加载Nginx配置文件，然后以优雅的方式重启Nginx</p></li><li><p>nginx -s stop   #强制停止Nginx服务</p></li><li><p>nginx -s quit   #优雅地停止Nginx服务（即处理完所有请求后再停止服务）</p></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为<strong>全局块、events块和http块</strong>。在http块中，又包含http全局</p><p>块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌套的配置块，各个之间不存在次序关</p><p>系。</p><p>配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。同一个指令放在不同层级的块中，其作用域也不同，一般情况</p><p>下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。如果某个指令在两个不同层级的块中同时出现，则采用“就</p><p>近原则”，即以较低层级块中的配置为准。比如，某指令同时出现在http全局块中和server块中，并且配置不同，则应该以server块中的配</p><p>置为准。</p><p>这里操作Linux下的nginx</p><p>1.进入配置文件的位置，安装目录的conf目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211209212658848.png" alt="image-20211209212658848"></p><p>2.打开配置文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="nginx配置文件组成"><a href="#nginx配置文件组成" class="headerlink" title="nginx配置文件组成"></a>nginx配置文件组成</h4><p>参考：<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html">https://www.cnblogs.com/54chensongxia/p/12938929.html</a></p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token comment">#全局块</span><span class="token comment">#user  nobody;</span><span class="token directive"><span class="token keyword">worker_processes</span>  <span class="token number">1</span></span><span class="token punctuation">;</span><span class="token comment">#event块</span><span class="token directive"><span class="token keyword">events</span></span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">worker_connections</span>  <span class="token number">1024</span></span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#http块</span><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">#http全局块</span>    <span class="token directive"><span class="token keyword">include</span>       mime.types</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">default_type</span>  application/octet-stream</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">sendfile</span>        <span class="token boolean">on</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">keepalive_timeout</span>  <span class="token number">65</span></span><span class="token punctuation">;</span>    <span class="token comment">#server块</span>    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">#server全局块</span>        <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8000</span></span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">server_name</span>  localhost</span><span class="token punctuation">;</span>        <span class="token comment">#location块</span>        <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span>            <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span>            <span class="token directive"><span class="token keyword">index</span>  index.html index.htm</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token directive"><span class="token keyword">error_page</span>   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">location</span> = /50x.html</span> <span class="token punctuation">&#123;</span>            <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">#这边可以有多个server块</span>    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>      ...    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>全局块</strong></p><p>全局块是默认配置文件从开始到events块之间的一部分内容，主要设置一些影响Nginx服务器整体运行的配置指令，因此，这些指令的作用域是Nginx服务器全局。</p><p>通常包括配置运行Nginx服务器的用户（组）、允许生成的worker process数、Nginx进程PID存放路径、日志的存放路径和类型以及配置文件引入等。</p><p><strong>events块</strong></p><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个worker process可以同时支持的最大连接数等。</p><p>这一部分的指令对Nginx服务器的性能影响较大，在实际配置中应该根据实际情况灵活调整。</p><p><strong>http块</strong></p><p>http块是Nginx服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。</p><p>前面已经提到，http块中可以包含自己的全局块，也可以包含server块，server块中又可以进一步包含location块，在本书中我们使用“http全局块”来表示http中自己的全局块，即http块中不包含在server块中的部分。</p><p>可以在http全局块中配置的指令包括文件引入、MIME-Type定义、日志自定义、是否使用sendfile传输文件、连接超时时间、单连接请求数上限等。</p><h1 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例1</strong></p><p>使用Nginx反向代理RabbitMQ，隐藏掉服务器中的RabbieMQ，这里IP地址为124.70.143.45:80。</p><p>这里配置Nginx在宿主机的挂载配置文件，<strong>修改配置前记得备份原配置文件</strong></p><p>外挂配置文件位置/mnt/nginx</p><p><img src="https://gitee.com/kisstt/typora/raw/master/images/image-20211210134235686.png" alt="image-20211210134235686"></p><p>访问124.70.145.43（默认80端口）会被代理到124.70.143.45:15672</p><p><strong>示例2</strong></p><p>输入124.70.145.43:9000/t1/ 跳转到124.70.145.43:8080，输入124.70.145.43:9000/t2/ 跳转到124.70.145.43:8081</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">9000</span></span><span class="token punctuation">;</span> <span class="token comment">#监听的端口</span>    <span class="token directive"><span class="token keyword">server_name</span> 124.70.145.43</span><span class="token punctuation">;</span>           <span class="token directive"><span class="token keyword">location</span> ~ /t1/</span> <span class="token punctuation">&#123;</span>      <span class="token directive"><span class="token keyword">proxy_pass</span> http://124.70.145.43:8080</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token directive"><span class="token keyword">location</span> ~ /t2/</span> <span class="token punctuation">&#123;</span>      <span class="token directive"><span class="token keyword">proxy_pass</span> http://124.70.145.43:8081</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们访问 124.70.145.43:9000/t1时会被代理到proxy_pass定义的地址上</p><h3 id="Location块"><a href="#Location块" class="headerlink" title="Location块"></a>Location块</h3><p>参考文章：<a href="https://segmentfault.com/a/1190000022315733">https://segmentfault.com/a/1190000022315733</a></p><h5 id="location-语法"><a href="#location-语法" class="headerlink" title="location 语法"></a><strong>location 语法</strong></h5><p>Location 块通过指定模式来与客户端请求的URI相匹配。</p><p>Location基本语法：</p><ul><li>匹配 URI 类型，有四种参数可选，当然也可以不带参数。</li><li>命名location，用@来标识，类似于定义goto语句块。</li></ul><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> [ = | ~ | ~* | ^~ ] /URI</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token directive"><span class="token keyword">location</span> @/name/</span> <span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="location匹配命令解释"><a href="#location匹配命令解释" class="headerlink" title="location匹配命令解释"></a><strong>location匹配命令解释</strong></h5><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><strong><code>空</code></strong></td><td>location 后没有参数直接跟着 <strong>标准 URI</strong>，表示前缀匹配，代表跟请求中的 URI 从头开始匹配。</td></tr><tr><td><strong><code>=</code></strong></td><td>用于<strong>标准 URI</strong> 前，要求请求字符串与其精准匹配，成功则立即处理，nginx停止搜索其他匹配。</td></tr><tr><td><strong><code>^~</code></strong></td><td>用于<strong>标准 URI</strong> 前，并要求一旦匹配到就会立即处理，不再去匹配其他的那些个正则 URI，一般用来匹配目录</td></tr><tr><td><strong><code>~</code></strong></td><td>用于<strong>正则 URI</strong> 前，表示 URI 包含正则表达式， <strong>区分</strong>大小写</td></tr><tr><td><strong><code>~\*</code></strong></td><td>用于<strong>正则 URI</strong> 前， 表示 URI 包含正则表达式， <strong>不区分</strong>大小写</td></tr><tr><td><strong><code>@</code></strong></td><td>@ 定义一个命名的 location，@ 定义的locaiton名字一般用在内部定向，例如error_page, try_files命令中。它的功能类似于编程中的goto。</td></tr></tbody></table><h5 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h5><p>nginx有两层指令来匹配请求 URI 。第一个层次是 server 指令，它通过域名、ip 和端口来做第一层级匹配，当找到匹配的 server 后就进入此 server 的 location 匹配。</p><p>location 的匹配并不完全按照其在配置文件中出现的顺序来匹配，请求URI 会按如下规则进行匹配：</p><ol><li>先精准匹配 <strong><code>=</code></strong> ，精准匹配成功则会立即停止其他类型匹配；</li><li>没有精准匹配成功时，进行前缀匹配。先查找带有 <strong><code>^~</code></strong> 的前缀匹配，带有 <strong><code>^~</code></strong> 的前缀匹配成功则立即停止其他类型匹配，普通前缀匹配（不带参数 <strong><code>^~</code></strong> ）成功则会暂存，继续查找正则匹配；</li><li><strong><code>=</code></strong> 和 <strong><code>^~</code></strong> 均未匹配成功前提下，查找正则匹配 <strong><code>~</code></strong> 和 <strong><code>~\*</code></strong> 。当同时有多个正则匹配时，按其在配置文件中出现的先后顺序优先匹配，命中则立即停止其他类型匹配；</li><li>所有正则匹配均未成功时，返回步骤 2 中暂存的普通前缀匹配（不带参数 <strong><code>^~</code></strong> ）结果</li></ol><p>以上规则简单总结就是优先级从高到低依次为（<strong>序号越小优先级越高</strong>）：</p><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p><a href="https://xuexb.github.io/learn-nginx/example/proxy_pass.html">https://xuexb.github.io/learn-nginx/example/proxy_pass.html</a></p><p>nginx中有两个模块都有<code>proxy_pass</code>指令。</p><ul><li><p><code>ngx_http_proxy_module</code>的<code>proxy_pass</code>：</p><pre class="line-numbers language-none"><code class="language-none">语法: proxy_pass URL;场景: location, if in location, limit_except说明: 设置后端代理服务器的协议(protocol)和地址(address),以及location中可以匹配的一个可选的URI。协议可以是&quot;http&quot;或&quot;https&quot;。地址可以是一个域名或ip地址和端口，或者一个 unix-domain socket 路径。详见官方文档: http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx_http_proxy_module.html#proxy_passURI的匹配，本文第四部分重点讨论。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>ngx_stream_proxy_module</code>的<code>proxy_pass</code>：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">语法: <span class="token directive"><span class="token keyword">proxy_pass</span> address</span><span class="token punctuation">;</span>场景: server说明: 设置后端代理服务器的地址。这个地址(address)可以是一个域名或ip地址和端口，或者一个 unix-domain socket路径。  详见官方文档: http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>两个<code>proxy_pass</code>的关系和区别</strong></p><p>在两个模块中，两个<code>proxy_pass</code>都是用来做后端代理的指令。<br><code>ngx_stream_proxy_module</code>模块的<code>proxy_pass</code>指令只能在server段使用使用, 只需要提供域名或ip地址和端口。可以理解为端口转发，可以是tcp端口，也可以是udp端口。<br><code>ngx_http_proxy_module</code>模块的<code>proxy_pass</code>指令需要在location段，location中的if段，limit_except段中使用，处理需要提供域名或ip地址和端口外，还需要提供协议，如”http”或”https”，还有一个可选的uri可以配置。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token comment"># 待选服务器列表</span><span class="token directive"><span class="token keyword">upstream</span> tomcat_server</span><span class="token punctuation">&#123;</span>     <span class="token directive"><span class="token keyword">server</span> ip1:port1</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server</span> ip2:port1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">9000</span></span><span class="token punctuation">;</span> <span class="token comment">#监听的端口</span>    <span class="token directive"><span class="token keyword">server_name</span> 124.70.145.43</span><span class="token punctuation">;</span>           <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span>      <span class="token directive"><span class="token keyword">proxy_pass</span> tomcat_server</span><span class="token punctuation">;</span> 引用上面定义好的    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><h5 id="1、轮询（默认）"><a href="#1、轮询（默认）" class="headerlink" title="1、轮询（默认）"></a>1、轮询（默认）</h5><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> backserver</span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">server</span> ip1:port1</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server</span> ip2:port1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、weight"><a href="#2、weight" class="headerlink" title="2、weight"></a>2、weight</h5><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的<br>情况。</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> backserver</span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">server</span> ip1:port1 weight=3</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server</span> ip2:port1 weight=7</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>权重越高，在被访问的概率越大，如上例，分别是30%，70%。</p><h5 id="3、ip-hash"><a href="#3、ip-hash" class="headerlink" title="3、ip_hash"></a>3、ip_hash</h5><p>上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么<em><strong>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的*<strong>。<br>我们可以采用</strong>*ip_hash**<em>指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过</em></strong>哈希算法，自动定位到该服务器*<strong>。<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决</strong></em>session的问题***。</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> backserver</span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">ip_hash</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server</span> ip1:port1</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server</span> ip2:port1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4、fair（第三方）"><a href="#4、fair（第三方）" class="headerlink" title="4、fair（第三方）"></a>4、fair（第三方）</h5><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> backserver</span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">server</span> ip1:port1</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server</span> ip2:port1</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">fair</span></span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台</p><p>应用访问。</p><p><strong>动静分离的一种常用做法：</strong>将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求调度到nginx服务</p><p>器，达到动静分离的目标。</p><img src="https://gitee.com/kisstt/typora/raw/master/images/15900165-cd94e5d2325a9a8a.png" alt="img" style="zoom:67%;" /><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>        <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">server_name</span>  kevin.com</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">access_log</span>  /data/nginx/logs/kevin.com-access.log main</span><span class="token punctuation">;</span>        <span class="token directive"><span class="token keyword">error_log</span>  /data/nginx/logs/kevin.com-error.log</span><span class="token punctuation">;</span>         <span class="token comment">#动态访问请求转给tomcat应用处理</span>        <span class="token directive"><span class="token keyword">location</span> ~ .(jsp|page|do)?$</span> <span class="token punctuation">&#123;</span>      <span class="token comment">#以这些文件结尾的</span>           <span class="token directive"><span class="token keyword">proxy_set_header</span>  Host <span class="token variable">$host</span></span><span class="token punctuation">;</span>           <span class="token directive"><span class="token keyword">proxy_set_header</span>  X-Real-IP  <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>           <span class="token directive"><span class="token keyword">proxy_pass</span> http://tomcat地址</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token comment">#设定访问静态文件直接读取不经过tomcat</span>        <span class="token directive"><span class="token keyword">location</span> ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$</span>  <span class="token punctuation">&#123;</span>     <span class="token comment">#以这些文件结尾的</span>           <span class="token directive"><span class="token keyword">expires</span>      <span class="token number">30d</span></span><span class="token punctuation">;</span> <span class="token comment"># 过期时间</span>           <span class="token directive"><span class="token keyword">root</span> /data/web/html</span> <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo&amp;Zookeeper</title>
      <link href="/2021/11/18/dubbo-zookeeper/"/>
      <url>/2021/11/18/dubbo-zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>传统项目和互联网项目的区别</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114143831649.png" alt="image-20211114143831649"></p><h3 id="大型互联网项目架构的目标"><a href="#大型互联网项目架构的目标" class="headerlink" title="大型互联网项目架构的目标"></a>大型互联网项目架构的目标</h3><h5 id="衡量网站的性能指标"><a href="#衡量网站的性能指标" class="headerlink" title="衡量网站的性能指标"></a>衡量网站的性能指标</h5><ul><li>响应时间: 指执行一个请求从开始到最后收到响应数据所花费的总体时间。</li><li>并发数:指系统同时能处理的请求数量。<ul><li>并发连接数:指的是客户端向服务器发起请求，并建立了TCP连接。每秒钟服务器连接的总TCP数量（一次链接可能有多个请求，一次链接也可能复用）</li><li>请求数:也称为QPS(Query Per Second)指每秒多少请求.</li><li>并发用户数:单位时间内有多少用户</li></ul></li><li>吞吐量:指单位时间内系统能处理的请求数量。<ul><li>QPS: Query Per Second每秒查询数。</li><li>TPS: Transactions Per Second每秒事务数。</li><li>一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。（比如点击一个链接，当这个链接的全部请求都已经到位时，表示一个事务结束）</li><li>一个页面的一次访问，只会形成一个TPS;但一次页面请求，可能产生多次对服务器的请求，就会有多个QPS<br>QPS &gt;= 并发连接数&gt;=TPS</li></ul></li><li>高性能:提供快速的访问体验。</li><li>高可用:网站服务一直可以正常访问。</li><li>可伸缩:通过硬件增加/减少，提高/降低处理能力。</li><li>高可扩展:系统间耦合低，方便的通过新增/移除方式，增加/减少新的功能/模块。</li><li>安全性:提供网站安全访问和数据加密，安全存储等策略。。</li><li>敏捷性:随需应变，快速响应。</li></ul><h3 id="分布式和集群"><a href="#分布式和集群" class="headerlink" title="分布式和集群"></a>分布式和集群</h3><ul><li><p>集群:很多“人”一起，干一样的事。</p><p>一个业务模块，部署在多台服务器上（完整的一个项目）。</p></li><li><p>分布式:很多“人”一起，干不一样的事。这些不一样的事，合起来是一件大事。</p><p>一个大的业务系统，拆分为小的业务模块，分别部署在不同的机器上。</p></li></ul><p>集群和分布式是并存的</p><p>单机系统</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211110205317868.png" alt="image-20211110205317868"></p><p>集群系统</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211110205430647.png" alt="image-20211110205430647"></p><p>缺点是：不好做扩展，不方便伸缩（配置新的机器）</p><p>集群加分布式</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211110205557256.png" alt="image-20211110205557256"></p><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>官网 ： <a href="https://dubbo.apache.org/zh/">https://dubbo.apache.org/zh/</a></p><p>官方文档：<a href="https://dubbo.apache.org/zh/docs/introduction/">https://dubbo.apache.org/zh/docs/introduction/</a></p><h4 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211111154928311.png" alt="image-20211111154928311"></p><p>节点说明</p><ul><li>Provider:暴露服务的服务提供方.</li><li>Container:服务运行容器</li><li>Consumer:调用远程服务的服务消费方</li><li>Registry:服务注册与发现的注册中心</li><li>Monitor:统计服务的调用次数和调用时间的监控中心</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h4><p> 使用Maven创建SpringMvc项目</p><p>1.创建空项目</p><p>2.创建两个module</p><p>导入相关依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- servlet3.0规范的坐标 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--spring的坐标--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--springmvc的坐标--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--日志--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-log4j12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--Dubbo的起步依赖，版本2.7之后统一为rg.apache.dubb --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;dubbo.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--ZooKeeper客户端实现 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.curator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>curator-framework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;zookeeper.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--ZooKeeper客户端实现 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.curator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>curator-recipes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;zookeeper.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--dubbo-web模块需要的依赖--></span>    <span class="token comment">&lt;!--依赖service模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.wzy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dubbo-service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--tomcat插件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat.maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat7-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>8000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>path</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-编写配置文件"><a href="#2-编写配置文件" class="headerlink" title="2.编写配置文件"></a>2.编写配置文件</h4><p>log4j属于公共配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span><span class="token comment"># Global logging configuration</span><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">info, stdout,file</span><span class="token comment"># My logging configuration...</span><span class="token comment">#log4j.logger.com.tocersoft.school=DEBUG</span><span class="token comment">#log4j.logger.net.sf.hibernate.cache=debug</span><span class="token comment">## Console output...</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%5p %d %C: %m%n</span><span class="token attr-name">log4j.appender.file</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.FileAppender</span><span class="token attr-name">log4j.appender.file.File</span><span class="token punctuation">=</span><span class="token attr-value">../logs/iask.log</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d&#123;yyyy-MM-dd HH:mm:ss&#125;  %l  %m%n</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dubbo-service模块</p><p>spring/springmvc.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>dubbo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://dubbo.apache.org/schema/dubbo<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd         http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--开启注解--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dubbo-web模块</p><p>spring/springmvc.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>dubbo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://dubbo.apache.org/schema/dubbo<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd         http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--开启组件扫描--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wzy.controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-编写业务"><a href="#3-编写业务" class="headerlink" title="3.编写业务"></a>3.编写业务</h4><p>dubbo-service模块：业务模块用来提供各种业务，会被打成jar包的形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"hello dubbo"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dubbo-web模块:业务调用模块</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/sayHello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-启动项目"><a href="#4-启动项目" class="headerlink" title="4.启动项目"></a>4.启动项目</h4><p>dubbo-service模块：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211111211013061.png" alt="image-20211111211013061"></p><p>dubbo-web模块:启动使用tomcat插件进行启动</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211111211045941.png" alt="image-20211111211045941"></p><blockquote><p>Q:Failed to execute goal org.apache.tomcat.maven:tomcat7-maven-plugin:2.2:run (default-cli) on project</p><p>A:在pom文件的依赖中，一定要加上scope属性</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211111211251972.png" alt="image-20211111211251972"></p></blockquote><h4 id="5-改造"><a href="#5-改造" class="headerlink" title="5.改造"></a>5.改造</h4><p>当前项目的两个模块仍然是相互以来的，要改造成通过dubbo关联的项目，以下面这种形式。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211112100726397.png" alt="image-20211112100726397"></p><blockquote><p>dubbo-service</p></blockquote><p>引入tomcat插件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--tomcat插件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat.maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat7-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>9000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>path</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加Web配置，同dubbo-web的配置，去掉mvc的配置即可</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- spring --></span><span class="token comment">&lt;!--用来扫描配置文件，加载配置文件--></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath*:spring/applicationContext*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在配置文件中添加dubbo配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--dubbo的配置--></span><span class="token comment">&lt;!--1.配置项目的名称,唯一--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-service<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--2.配置注册中心的地址--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>registry</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zookeeper://127.0.0.1:2181<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--3.配置dubbo包扫描--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>annotation</span> <span class="token attr-name">package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将impl实现类的@Service注解换位dubbo的@Service注解</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import org.apache.dubbo.config.annotation.Service;&#x2F;&#x2F;dubbo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dubbo-web</p></blockquote><p>controller中的service不再是通过本地的方式调用，而是改为通过rpc的形式调用</p><p>使用@Reference注解</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;注入Service&#x2F;&#x2F;@Autowired&#x2F;&#x2F;本地注入&#x2F;*    1. 从zookeeper注册中心获取userService的访问url    2. 进行远程调用RPC    3. 将结果封装为一个代理对象。给变量赋值 *&#x2F;@Reference&#x2F;&#x2F;远程注入private UserService userService;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dubbo-interface</p></blockquote><p>将接口提取为公共的api，去掉dubbo-web和dubbo-service的中定义的接口，而是通过导入dubbo-interface模块的方式进行调用声明</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211112104624651.png" alt="image-20211112104624651"></p><h3 id="安装dubbo-admin工具"><a href="#安装dubbo-admin工具" class="headerlink" title="安装dubbo-admin工具"></a>安装dubbo-admin工具</h3><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><p>dubbo-admin管理平台，是图形化的服务管理页面</p><p>从注册中心中获取到所有的提供者/消费者进行配置管理</p><p>路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能</p><p>dubbo-admin是一个前后端分离的项目。前端使用vue，后端使用springboot</p><p>安装 dubbo-admin其实就是部署该项目</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>1、环境准备</p><p>dubbo-admin 是一个前后端分离的项目。前端使用vue，后端使用springboot，安装 dubbo-admin 其实就是部署该项目。我们将dubbo-admin安装到开发环境上。要保证开发环境有jdk，maven，nodejs</p><p>安装node(如果当前机器已经安装请忽略)</p><p>因为前端工程是用vue开发的，所以需要安装node.js，node.js中自带了npm，后面我们会通过npm启动</p><p>2、下载 Dubbo-Admin</p><p>进入github，搜索dubbo-admin</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1578297063167.png" alt="1578297063167"></p><p>3、把下载的zip包解压到指定文件夹(解压到那个文件夹随意)</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1578297477356.png" alt="1578297477356"></p><p>4、修改配置文件</p><p>解压后我们进入…\dubbo-admin-develop\dubbo-admin-server\src\main\resources目录，找到 application.properties 配置文件 进行配置修改</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/1578297603008.png" alt="1578297603008"></p><p>修改zookeeper地址</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/1578297758655.png" alt="1578297758655"></p><p>admin.registry.address注册中心<br>admin.config-center 配置中心<br>admin.metadata-report.address元数据中心</p><p>5、打包项目</p><p>在 dubbo-admin-develop 目录执行打包命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mvn  clean package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211113135059894.png" alt="image-20211113135059894"></p><p>6、启动后端</p><p>切换到目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">dubbo-Admin-develop\dubbo-admin-distribution\target&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行下面的命令启动 dubbo-admin，dubbo-admin后台由SpringBoot构建。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">java -jar .\dubbo-admin-0.1.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、前台后端</p><p>dubbo-admin-ui 目录下执行命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211113135623086.png" alt="image-20211113135623086"></p><p>8、访问</p><p>浏览器输入。用户名密码都是root</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8081&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211113135647602.png" alt="image-20211113135647602"></p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="先行：在不创建新的模块的情况下，模拟集群"><a href="#先行：在不创建新的模块的情况下，模拟集群" class="headerlink" title="先行：在不创建新的模块的情况下，模拟集群"></a>先行：在不创建新的模块的情况下，模拟集群</h4><p>修改下面两处的端口号即可</p><pre class="line-numbers language-none"><code class="language-none">&lt;dubbo:protocol port&#x3D;&quot;20882&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;dubbo:application name&#x3D;&quot;dubbo-service&quot;&gt;   &lt;dubbo:parameter key&#x3D;&quot;qos.port&quot; value&#x3D;&quot;11111&quot;&#x2F;&gt;&lt;&#x2F;dubbo:application&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p> 创建新的模块dubbo-pojo，模块内容是provider和consumer之间传输的对象，也是comsumer模块和provider模块需要共同依赖的部分。</p><p>必须实现Serializable接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@datapublic</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1.maven的依赖范围 scope<br>共 5 种依赖范围 , compile (编译) , test (测试) , runtime (运行时) , provided , system<br>不指定 , 则依赖范围默认为 compile</p><p>compile : (编译依赖范围) , 在编译 , 测试 , 运行/打包时都会使用这个依赖</p><p>test : (测试依赖范围) , 测试时会使用 , 编译 和 运行/打包 不使用 , 如 Junit</p><p>runtime : (运行时依赖范围) , 测试 和 运行/打包 时需要 , 编译不需要 , 如 JDBC 驱动包</p><p>provided : (已提供依赖范围) , 编译 和 测试时需要 , 运行/打包 时不需要 , 如 servlet-api</p><p>system : (系统依赖范围) , 本地依赖 , 不在 maven 中央仓库 , 从参与度来说也 provided 相同 , 不过被依赖项不会从 maven 仓库抓 , 而是从本地文件系统拿 , 一定需要配合 systemPath 属性使用</p><p>当 maven 依赖本地而非 repository 中的 jar 包 , sytemPath 指明本地 jar 包路径</p><p><strong>依赖传递(Transitive Dependencies)</strong></p><p>依赖传递(Transitive Dependencies)是Maven 2.0开始的提供的特性，依赖传递的好处是不言而喻的，可以让我们不需要去寻找和发现所必须依赖的库，而是将会自动将需要依赖的库帮我们加进来。</p><p>例如A依赖了B，B依赖了C和D，那么你就可以在A中，像主动依赖了C和D一样使用它们。并且传递的依赖是没有数量和层级的限制的，非常方便。</p><p>但依赖传递也不可避免的会带来一些问题，例如：<br>- 当依赖层级很深的时候，可能造成循环依赖(cyclic dependency)<br>- 当依赖的数量很多的时候，依赖树会非常大</p><p><a href="https://zhuanlan.zhihu.com/p/34427614">maven</a></p></blockquote><h4 id="地址缓存"><a href="#地址缓存" class="headerlink" title="地址缓存"></a>地址缓存</h4><p>Q:注册中心挂了，服务是否可以正常访问?</p><ul><li>可以，因为dubbo服务消费者在第一次调用时,会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。</li><li>当服务提供者地址发生变化时，注册中心会通知服务消费者。</li></ul><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211113215035749.png" alt="image-20211113215035749"></p><p>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。</p><p>在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩。</p><p>dubbo利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。使用timeout属性配</p><p>置超时时间，默认值1000，单位毫秒。</p><h5 id="程序模拟请求超时"><a href="#程序模拟请求超时" class="headerlink" title="程序模拟请求超时"></a>程序模拟请求超时</h5><p>dubbo-service(provider)</p><p>模拟请求时长为5秒，超时时长为3秒，重试0次。超时时长和重试次数在@Service注解上定义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">,</span>retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//超时时长三秒，重试0次public class UserServiceImpl implements UserService &#123;    @Override    public String sayHello() &#123;        return "hello dubbo hello!~";    &#125;    @Override    public User findUserById(int id) &#123;        //模拟超时        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        User user = new User(1, "zhangsan", "123456");        return user;    &#125;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dubbo-web(consumer)</p><p>服务消费方也可以定义超时时长和超时次数，且会覆盖服务提供方定义的超时时长和超时次数。但是推荐在服务提供方处定义，服务提供方是知道请求的大致时长的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Reference</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">(</span>consumer <span class="token operator">></span> provider<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/find"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//开启异步，看看何时会出现异常        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true) &#123;                    System.out.println(i++);                &#125;            &#125;        &#125;).start();        return userService.findUserById(id);    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h4><p>设置了超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</p><p>如果出现网络抖动，则这一次请求就会失败。</p><p>Dubbo提供重试机制来避免类似问题的发生。</p><p>通过retries属性来设置重试次数。默认为2次。</p><h4 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h4><p>老版本</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114133943645.png" alt="image-20211114133943645"></p><p>灰度发布:当出现新功能时，会让一部分用户先使用新功能</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211114134006514.png" alt="image-20211114134006514"></p><p>用户反馈没问题时，再将所有用户迁移到新功能。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114133747272.png" alt="image-20211114133747272"></p><p>dubbo中使用version属性来设置和调用同一个接口的不同版本</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>dubbo-service</p><p>服务提供方添加新的实现，并且定义版本号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"v2.0"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dubbo-web</p><p>服务消费方选择不同版本的实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Reference</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"v2.0"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="复制均衡"><a href="#复制均衡" class="headerlink" title="复制均衡"></a>复制均衡</h4><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 <code>random</code> 随机调用。</p><p>具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出</p><p>需要将请求提交到哪个 Provider 实例。</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/loadbalance/">官方文档</a></p><p>负载均衡策略(4种):</p><ul><li><p>Random:按权重随机，默认值。按权重设置随机概率</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114140324573.png" alt="image-20211114140324573"></p></li><li><p>RoundRobin:按权重轮询。</p><p><img src="D:\Typoramd\Dubbo&zookeeper\Dubbo&zookeeper.assets\image-20211114140324573.png" alt="image-20211114140324573"></p></li><li><p>LeastActive:最少活跃调用数，相同活跃数的随机。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114140249825.png" alt="image-20211114140249825"></p></li><li><p>ConsistentHash:一致性Hash，相同参数的请求<br>总是发到同一提供者。</p><p><img src="D:\Typoramd\Dubbo&zookeeper\Dubbo&zookeeper.assets\image-20211114140113741.png?lastModify=1637231698" alt="image-20211114140113741"></p></li></ul><h4 id="集群容错模式"><a href="#集群容错模式" class="headerlink" title="集群容错模式"></a>集群容错模式</h4><p>集群调用失败时，Dubbo 提供的容错方案</p><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/fault-tolerent-strategy/">官方文档</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114141233035.png" alt="image-20211114141233035"></p><p>集群容错模式</p><p>Failover Cluster</p><p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)。</p><p>Failfast Cluster</p><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><p>Failsafe Cluster</p><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><p>Failback Cluster</p><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><p>Forking Cluster</p><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p><p>Broadcast Cluster</p><p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><p>向注册中心写入动态配置覆盖规则：</p><ul><li><p><code>mock=force:return null</code> 表示消费方对该服务的方法调用都直接返回 null 值，不</p><p>发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</p></li><li><p>还可以改为 <code>mock=fail:return null</code> 表示消费方对该服务的方法调用在失败后，再</p><p>返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Reference</span><span class="token punctuation">(</span>mock <span class="token operator">=</span> <span class="token string">"force:return null"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><p>文档：<a href="https://zookeeper.readthedocs.io/zh/latest/intro.html">https://zookeeper.readthedocs.io/zh/latest/intro.html</a></p><p><a href="http://www.dba.cn/book/zookeeper/ZOOKEEPERZhongWenShouCe/ZOOKEEPERCLI.html">http://www.dba.cn/book/zookeeper/ZOOKEEPERZhongWenShouCe/ZOOKEEPERCLI.html</a></p><p>总结的很好的zookeeper文档：<a href="https://xiaoxiami.gitbook.io/zookeeper/">https://xiaoxiami.gitbook.io/zookeeper/</a></p><h3 id="ZK简介"><a href="#ZK简介" class="headerlink" title="ZK简介"></a>ZK简介</h3><p>Zookeeper是 Apache Hadoop项目下的一个子项目，是一个树形目录服务。</p><p>Zookeeper翻译过来就是动物园管理员，他是用来管Hadoop(大象)、Hive(蜜蜂)、Pig(小猪)的管理员。简称zk</p><p>Zookeeper是一个分布式的、开源的分布式应用程序的协调服务。</p><p>Zookeeper提供的主要功能包括:</p><pre><code>        配置管理        分布式锁        集群管理</code></pre><h3 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h3><h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>1、环境准备</p><p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p><p>2、上传</p><p>将下载的ZooKeeper放到/opt/ZooKeeper目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#打开 opt目录cd &#x2F;opt#创建zooKeeper目录mkdir  zooKeeper#上传zookeeper xftp上传到Linux服务器opt&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.6-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Q:xftp上传出现错误，没有权限向opt目录传文件</p><p>A:修改文件权限即可 chmod 777 zookeeper/</p></blockquote><p>3、解压</p><p>将tar包解压到/opt/zookeeper目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h5><p>1、配置zoo.cfg</p><p>进入到conf目录拷贝一个zoo_sample.cfg并完成配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#进入到conf目录cd &#x2F;opt&#x2F;zooKeeper&#x2F;apache-zooKeeper-3.5.6-bin&#x2F;conf&#x2F;#拷贝cp  zoo_sample.cfg  zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改zoo.cfg</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#打开目录cd &#x2F;opt&#x2F;zooKeeper&#x2F;#创建zooKeeper存储目录mkdir  zkdata#修改zoo.cfgvim &#x2F;opt&#x2F;zooKeeper&#x2F;apache-zooKeeper-3.5.6-bin&#x2F;conf&#x2F;zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1577548250377.png" alt="1577548250377"></p><p>修改存储目录：dataDir=/opt/zookeeper/zkdata</p><p>2、启动ZooKeeper</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;opt&#x2F;zooKeeper&#x2F;apache-zooKeeper-3.5.6-bin&#x2F;bin&#x2F;#启动 .&#x2F;zkServer.sh  start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/1577548052037.png" alt="1577548052037"></p><p>看到上图表示ZooKeeper成功启动</p><p>3、查看ZooKeeper状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.&#x2F;zkServer.sh status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>zookeeper启动成功。standalone代表zk没有搭建集群，现在是单节点</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1577548175232.png" alt="1577548175232"></p><p>zookeeper没有启动</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1577548112773.png" alt="1577548112773"></p><blockquote><p>Q:./zkServer.sh status</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;&#x2F;usr&#x2F;bin&#x2F;javaZooKeeper JMX enabled by defaultUsing config: &#x2F;opt&#x2F;zookeeper&#x2F;apache-zookeeper-3.7.0-bin&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfgClient port found: 2181. Client address: localhost. Client SSL: false.Error contacting service. It is probably not running.#zookeeper未正常启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;.&#x2F;zkServer.sh start-foreground  查看日志输出<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;Unable to start AdminServer, exiting abnormallyorg.apache.zookeeper.server.admin.AdminServer$AdminServerException: Problem starting AdminServer on address 0.0.0.0, port 8080 and command URL &#x2F;commandsat org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:179)at org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ZooKeeperServerMain.java:155)at org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun(ZooKeeperServerMain.java:113)at org.apache.zookeeper.server.ZooKeeperServerMain.main(ZooKeeperServerMain.java:68)at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(QuorumPeerMain.java:141)at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain.java:91)Caused by: java.io.IOException: Failed to bind to &#x2F;0.0.0.0:8080at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:349)at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:310)at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:234)at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:73)at org.eclipse.jetty.server.Server.doStart(Server.java:401)at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:73)at org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:170)... 5 moreCaused by: java.net.BindException: Address already in useat sun.nio.ch.Net.bind0(Native Method)at sun.nio.ch.Net.bind(Net.java:461)at sun.nio.ch.Net.bind(Net.java:453)at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:222)at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:85)at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:344)... 12 moreUnable to start AdminServer, exiting abnormally#8080端口被占用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是Zookeeper AdminServer，默认使用8080端口，它的配置属性如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12540413-d5924f70213774e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p><p>解决办法：修改端口即可</p><p>我们可以修改在zoo.cfg中修改AdminServer的端口：</p><p>保存后，再次启动，Zookeeper启动成功。</p></blockquote><h4 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h4><p>官网下载，解压，使用7-zip解压为tar，再解压一遍即可</p><p>将conf文件夹的配置文件改为zoo.cfg，并做如下配置</p><pre class="line-numbers language-none"><code class="language-none">tickTime&#x3D;2000               # 最小时间单位, 最小的会话超时为两倍 tickTime,建议设置长一些dataDir&#x3D;..&#x2F;data             # 数据目录, 需要存在且开始的时候为空clientPort&#x3D;2181             # 客户端连接的监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入解压后端zookeeper的bin目录，找到zkServer.cmd启动即可</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211112103019426.png" alt="image-20211112103019426"></p><p>使用zkCli.cmd链接zk服务端，出现下面表示链接成功</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114152013152.png" alt="image-20211114152013152"></p><h3 id="ZooKeeper数据模型"><a href="#ZooKeeper数据模型" class="headerlink" title="ZooKeeper数据模型"></a>ZooKeeper数据模型</h3><ul><li><p>ZooKeeper是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114150412939.png" alt="image-20211114150412939"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/zknamespace.jpg" alt="_images/zknamespace.jpg"></p><p>名字是一个用斜杆(/)分隔的路径元素序列, ZK 中每一个节点(znode)都用路径标识。</p></li><li><p>这里面的每一个节点都被称为:ZNode，和文件系统不同, ZK 中的节点可以拥有数据和子节点。ZK 被设计来存储协调数据: 状态信息、配置、位置信息等, 所以数据通常很小(byte 到 kilobyte 之间)。</p></li><li><p>节点可以分为四大类:</p><ul><li>持久节点（PERSISTENT）<br>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。</li><li>持久顺序节点（PERSISTENT_SEQUENTIAL）<br>这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。<br>在创建节点的时候只需要传入节点 “/test_”，这样之后，zookeeper自动会给”test_”后面补充数字。</li><li>临时节点（EPHEMERAL）<br>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。<br>这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消失了，也要过一段时间，大概是10秒以内，可以试一下，本机操作生成节点，在服务器端用命令来查看当前的节点数目，你会发现客户端已经stop，但是产生的节点还在。</li><li>临时顺序节点（EPHEMERAL_SEQUENTIAL）<br>此节点是属于临时节点，不过带有顺序，客户端会话结束节点就消失。下面是一个利用该特性的分布式锁的案例流程。<br>(1)客户端调用create()方法创建名为“locknode/<br>guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。<br>(2)客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点，注意，这里不注册任何Watcher。<br>(3)客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点序号最小，那么就认为这个客户端获得了锁。<br>(4)如果在步骤3中发现自己并非所有子节点中最小的，说明自己还没有获取到锁。此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时注册事件监听。<br>(5)之后当这个被关注的节点被移除了，客户端会收到相应的通知。这个时候客户端需要再次调用getChildren(“locknode”)方法来获取所有已经创建的子节点，确保自己确实是最小的节点了，然后进入步骤3。</li></ul></li></ul><p>节点更加详细的介绍：<a href="https://zookeeper.readthedocs.io/zh/latest/intro.html#ephemeral-nodes">https://zookeeper.readthedocs.io/zh/latest/intro.html#ephemeral-nodes</a></p><h3 id="Zookeeper命令"><a href="#Zookeeper命令" class="headerlink" title="Zookeeper命令"></a>Zookeeper命令</h3><p>以下是基本操作命令</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115092727992.png" alt="image-20211115092727992"></p><h4 id="Server端命令"><a href="#Server端命令" class="headerlink" title="Server端命令"></a>Server端命令</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 启动服务端$ bin&#x2F;zkServer.sh start# 查看状态$ bin&#x2F;zkServer.sh status# 停止$ bin&#x2F;zkServer.sh stop# 重启$ bin&#x2F;zkServer.sh restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Client端命令"><a href="#Client端命令" class="headerlink" title="Client端命令"></a>Client端命令</h4><p>连接ZooKeeper服务端</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.&#x2F;zkCli.sh -server ip:port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>断开连接</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置节点值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">set &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看命令帮助</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除单个节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">delete &#x2F; 节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示指定目录下节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除带有子节点的节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">deleteall &#x2F;节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取节点值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">get &#x2F;节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建临时节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create -e &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建顺序节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create -s &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询节点详细信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -s&#x2F;节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>ls可以查看到的节点的信息</p><p><img src="D:\Typoramd\Dubbo&zookeeper\Dubbo&zookeeper.assets\image-20211114191048713.png" alt="image-20211114191048713"></p></blockquote><p>详细命令</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114190236967.png" alt="image-20211114190236967"></p><h3 id="Zookeeper的ACL权限控制"><a href="#Zookeeper的ACL权限控制" class="headerlink" title="Zookeeper的ACL权限控制"></a>Zookeeper的ACL权限控制</h3><h4 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h4><p>zk做为分布式架构中的重要中间件，通常会在上面以节点的方式存储一些关键信息，默认情况下，所有应用都可以读写任何节点，在复杂的应用中，这不太安全，ZK通过ACL机制来解决访问权限问题，详见官网文档：</p><p><a href="http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html#sc_ZooKeeperAccessControl">http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html#sc_ZooKeeperAccessControl</a></p><p>类似linux针对文件的权限控制</p><p>ACL权限控制使用scheme(身份认证)：id（授权对象）：permission（授予的权限）</p><ol><li><p>身份的认证有4种方式：</p><p>world：world下只有一个id，即只有一个用户，也就是anyone，那么组合的写法就是<code>world:anyone:[permissions]</code></p><p>auth：代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)</p><p>digest：需要对密码加密才能访问，组合形式为<code>digest:username:BASE64(SHA1(password)):[permissions]</code></p><p>ip：当设置为ip指定的ip地址，此时限制ip进行访问，比如<code>ip:192.168.1.1:[permissions]</code></p><p>super：代表超级管理员，拥有所有的权限。</p></li><li><p>id（授权对象）</p></li><li><p>ZK的节点有5种操作权限</p><ul><li>create 简写c 可以创建子结点</li><li>delete 简写d 可以删除子结点（仅下一级）</li><li>read 简写r 可以读取结点数据以及显示子结点</li><li>write 简写w 可以设置结点数据</li><li>admin 简写a 可以设置节点访问控制列表权限</li></ul></li></ol><h4 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h4><p>getAcl：获取某个节点的acl权限信息，语法：<code>getAcl path</code></p><p>setAcl：设置某个节点的acl权限信息,语法：<code>setAcl path</code></p><p>addauth：输入认证权限信息，注册时输入明文密码（登录），但是在zk的系统里，密码是以加密的形式存在的。语法：<code>addauth scheme auth</code></p><h4 id="ACL权限控制四种模式"><a href="#ACL权限控制四种模式" class="headerlink" title="ACL权限控制四种模式"></a>ACL权限控制四种模式</h4><h5 id="world授权模式"><a href="#world授权模式" class="headerlink" title="world授权模式"></a>world授权模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setAcl path world:anyone:&lt;acl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如取消c创建权限，就不能再创建子结点</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118131807231.png" alt="image-20211118131807231"></p><h5 id="ip授权模式"><a href="#ip授权模式" class="headerlink" title="ip授权模式"></a>ip授权模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setAcl path ip:&lt;ip&gt;:&lt;acl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用两个虚拟机</p><h5 id="digest模式"><a href="#digest模式" class="headerlink" title="digest模式"></a>digest模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setAcl path digest:&lt;username&gt;:&lt;BASE64(SHA1(password))&gt;:&lt;acl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>getAcl path</code> 读取权限</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118124529642.png" alt="image-20211118124529642"></p><p>通过getAcl命令可以发现，刚创建的节点，默认是 world,anyone的认证方式，具有cdrwa所有权限</p></li><li><p><code>setAcl path digest:&lt;username&gt;:&lt;BASE64(SHA1(password))&gt;:&lt;acl&gt;</code> 设置权限</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118124939417.png" alt="image-20211118124939417"></p><p>permission是先给/app1增加了user1:+owfoSBn/am19roBPzR1/MfCblE的只读(r)权限控制</p><p>说明：setAcl /test digest:用户名:密码:权限 给节点设置ACL访问权限时，密码必须是加密后的内容，这里的+owfoSBn/am19roBPzR1/MfCblE=，对应的原文是12345 (至于这个密文怎么得来的，后面会讲到，这里先不管这个)，设置完Acl后，可以通过getAcl /节点路径 查看Acl设置然后get /app1时，提示认证无效，说明访问控制起作用了</p></li><li><p><code>addauth digest &lt;user&gt;:&lt;password&gt;</code> 添加认证用户</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118130023454.png" alt="image-20211118130023454"></p><p>addauth digest user1:12345 给”上下文”增加了一个认证用户，即对应刚才setAcl的设置</p><p>然后再 get /app1 就能取到数据了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118130303572.png" alt="image-20211118130303572"></p></li></ul><p>加密</p><p>这里的密码是经过SHA1及BASE64处理的密文</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@hecs-x-medium-2-linux-20211114163803 bin]#  echo -n user1:12345 | openssl dgst -binary -sha1 | openssl base64+owfoSBn&#x2F;am19roBPzR1&#x2F;MfCblE&#x3D;  #加密后端密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="auth模式"><a href="#auth模式" class="headerlink" title="auth模式"></a>auth模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">addauth digest &lt;user&gt;:&lt;password&gt; &#96;添加认证用户,password为加密后的密码&#96;setAcl &lt;path&gt; auth:&lt;user&gt;:&lt;acl&gt; &#96; 授权<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚才也提到了，setAcl /path digest这种方式，必须输入密码加密后的值，这在cli控制台上很不方便，所以下面这种方式更常用：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118131342498.png" alt="image-20211118131342498"></p><p>先用addauth digest user1:12345 增加一个认证用户，然后用 setAcl /app1 auth:user1:12345:r 设置权限，跟刚才的效果一样，但是密码这里输入的是明文，控制台模式下手动输入更方便。</p><h5 id="多权限模式"><a href="#多权限模式" class="headerlink" title="多权限模式"></a>多权限模式</h5><p>同一个结点可以使用多种授权模式，用逗号隔开就行，</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141013483.png" alt="image-20211118141013483"></p><h4 id="节点间ACL关系（待补充）"><a href="#节点间ACL关系（待补充）" class="headerlink" title="节点间ACL关系（待补充）"></a>节点间ACL关系（待补充）</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118134147402.png" alt="image-20211118134147402"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118134207349.png" alt="image-20211118134207349"></p><p>从这张图上可以发现，子节点/test/app1的控制权限范围可以超出父节点的范围（仅限：父节点具有read/admin权限）</p><h4 id="ACL权限小总结"><a href="#ACL权限小总结" class="headerlink" title="ACL权限小总结"></a>ACL权限小总结</h4><p>要修改某个节点的ACL属性，必须具有read、admin二种权限</p><p>要删除某个节点下的子节点，必须具有对父节点的read权限，以及父节点的delete权限</p><blockquote><h4 id="因为没设置权限导致的节点无法删除"><a href="#因为没设置权限导致的节点无法删除" class="headerlink" title="因为没设置权限导致的节点无法删除"></a>因为没设置权限导致的节点无法删除</h4><p>Q:遇到了节点设置了权限，但是没有设置可以删除的权限，导致节点无法删除</p><p>A:假设超级管理员的账号是super:admin，先要为其生成密文：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141306373.png" alt="image-20211118141306373"></p><p>得到密文<code>xQJmxLMiHGwaqBvst5y6rkB6HQs=</code></p><p>在zookeeper目录下/bin/zkServer.sh服务器脚本文件，找到这一行</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141403483.png" alt="image-20211118141403483"></p><p><code>&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</code>加入这一句，这里已经加好了。</p><p>重启zookeeper就可以了</p><p>使用客户端登陆，添加管理员<code>addauth digest super:admin</code>,这样就可以删除了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141611250.png" alt="image-20211118141611250"></p></blockquote><h3 id="Zookeeper-Java-API"><a href="#Zookeeper-Java-API" class="headerlink" title="Zookeeper Java API"></a>Zookeeper Java API</h3><h4 id="Apache-Curator简介"><a href="#Apache-Curator简介" class="headerlink" title="Apache Curator简介"></a>Apache Curator简介</h4><ul><li>Curator是ApacheZooKeeper的Java客户端库。</li><li>常见的ZooKeeper Java APl :<ul><li>原生JavaAPl</li><li>ZkClient</li><li>Curator</li></ul></li><li>Curator项目的目标是简化ZooKeeper客户端的使用，原生JavaAPI不好用。</li><li>Curator最初是Netfix研发的,后来捐献了Apache基金会,目前是Apache的顶级项目。</li><li>官网: <a href="http://curator.apache.orgl/">http://curator.apache.orgl</a></li></ul><h4 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h4><p>两种创建CuratorFramework方式</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115192919579.png" alt="image-20211115192919579"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">CuratorFramework</span> curatorFramework<span class="token punctuation">;</span>    <span class="token operator">/</span>      <span class="token operator">*</span> 建立zk链接     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token comment">//在所有Test方法前执行    @Before    public void test() &#123;        RetryNTimes retryNTimes = new RetryNTimes(3, 3000);        /*         *         * @param connectString       链接地址，链接字符串         * @param sessionTimeoutMs    会话超时时间         * @param connectionTimeoutMs 链接超时时间         * @param retryPolicy         重试策略，像超时时间或者重试次数         */        //第一种方式创建链接        curatorFramework = CuratorFrameworkFactory.newClient("124.70.145.43:2181", retryNTimes);        //第二种方式创建链接        /*CuratorFramework curatorFramework1 = CuratorFrameworkFactory.builder()                .connectString("124.70.145.43:2181")                .sessionTimeoutMs(5000)                .connectionTimeoutMs(5000)                .retryPolicy(retryNTimes)                //统一命名空间，当前会话都会在/wzy这个节点下创建                .namespace("wzy").build();*/        //开启链接        curatorFramework.start();    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>curatorFramework是已经创建好的Client</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 创建节点  create  持久，临时，顺序     <span class="token operator">*</span> <span class="token number">1.</span>基本创建     <span class="token operator">*</span> <span class="token number">2.</span>创建带数据的节点     <span class="token operator">*</span> <span class="token number">3.</span>设置节点的类型     <span class="token operator">*</span> <span class="token number">4.</span>创建多级节点     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">TestCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.基本创建，默认将客户端的ip地址作为默认数据        String path = curatorFramework.create().forPath("/app1");        //2.创建带数据的节点        String path1 = curatorFramework.create().forPath("/app2", "hello".getBytes());        //3.创建临时节点        //withMode(临时节点类型)        String path2 = curatorFramework.create().withMode(CreateMode.CONTAINER).forPath("/app3", "hello".getBytes());        //4.创建多级节点        //creatingParentsIfNeeded()用来创建父级节点        String path4 = curatorFramework.create().creatingParentsIfNeeded().forPath("/app4");    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 获取节点信息     <span class="token operator">*</span> <span class="token number">1.</span>查询节点数据     <span class="token operator">*</span> <span class="token number">2.</span>查询节点链表     <span class="token operator">*</span> <span class="token number">3.</span>查询节点状态     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取节点数据        byte[] bytes = curatorFramework.getData().forPath("/app2");        System.out.println(new String(bytes));    &#125;    @Test    public void get2() throws Exception &#123;        //获取节点的子节点        List&lt;String> list = curatorFramework.getChildren().forPath("/app4");    &#125;    @Test    public void get3() throws Exception &#123;        //节点状态信息        Stat status = new Stat();        System.out.println(status);        curatorFramework.getData().storingStatIn(status).forPath("/app2");        System.out.println(status);    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 修改数据     <span class="token operator">*</span> <span class="token number">1.</span>修改数据     <span class="token operator">*</span> <span class="token number">2.</span>根据版本号来修改     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        curatorFramework<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app2"</span><span class="token punctuation">,</span> <span class="token string">"hi"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//通过判断version来进行修改，毕竟可能不止一个客户端想要修改节点的数据，要保证查询的原子性    @Test    public void setByVersion() throws Exception &#123;        Stat status = new Stat();        //节点的版本是通过查询得到的        curatorFramework.getData().storingStatIn(status).forPath("/app2");        curatorFramework.setData().withVersion(status.getVersion()).forPath("/app2", "hihi".getBytes());    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 删除操作     <span class="token operator">*</span> <span class="token number">1.</span>删除节点     <span class="token operator">*</span> <span class="token number">2.</span>删除带有子节点的     <span class="token operator">*</span> <span class="token number">3.</span>必须删除成功的     <span class="token operator">*</span> <span class="token number">4.</span>带有回调函数的     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//常规删除        curatorFramework.delete().forPath("/app1");        //删除带有子节点的        curatorFramework.delete().deletingChildrenIfNeeded().forPath("/app4");        //必须删除成功的        curatorFramework.delete().guaranteed().forPath("/app1");        //带有回调函数的删除        curatorFramework.delete().inBackground(new BackgroundCallback() &#123;            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception &#123;                System.out.println("已删除");                System.out.println(event);            &#125;        &#125;).forPath("/app1");    &#125;/      * 释放连接资源     */    @After//所有Test单元模块执行完成之后再执行    public void close() &#123;        curatorFramework.close();    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Watcher事件监听"><a href="#Watcher事件监听" class="headerlink" title="Watcher事件监听"></a>Watcher事件监听</h4><p>ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户</p><p>端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p><p>ZooKeeper中引入了Watcher机制来实现了发布/订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会</p><p>通知所有订阅者。</p><p>ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便，需要开发人员自己反复注册Watcher，比较繁琐。</p><p>Curator引入了Cache来实现对ZooKeeper服务端事件的监听。</p><p>ZooKeeper提供了三种Watcher:</p><ul><li><del>NodeCache:只是监听某一个特定的节点</del></li><li><del>PathChildrenCache:监控一个ZNode的子节点.</del></li><li><del>TreeCache:可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</del></li></ul><p>目前这三个方法在5.0以上版的Gurator中均标识位废弃，新的Watcher类CuratorCache</p><p>通过静态方法获取CuratorCache对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">CuratorCache</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> client<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">Options</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> options<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">builder</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withOptions</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>curatorCache.listenable().addListener()传入的监听器接口，重写event函数即可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterfacepublic</span> <span class="token keyword">interface</span> <span class="token class-name">CuratorCacheListener</span><span class="token punctuation">&#123;</span>    <span class="token operator">/</span>      <span class="token operator">*</span> <span class="token class-name">An</span> enumerated type that describes a change     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token keyword">enum</span> <span class="token class-name">Type</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">/</span>          <span class="token operator">*</span> <span class="token class-name">A</span> <span class="token keyword">new</span> node was added <span class="token keyword">to</span> <span class="token namespace">the</span> cache         <span class="token operator">*</span><span class="token operator">/</span>        NODE_CREATED<span class="token punctuation">,</span>        <span class="token operator">/</span>          <span class="token operator">*</span> <span class="token class-name">A</span> node already in the cache has changed         <span class="token operator">*</span><span class="token operator">/</span>        NODE_CHANGED<span class="token punctuation">,</span>        <span class="token operator">/</span>          <span class="token operator">*</span> <span class="token class-name">A</span> node already in the cache was deleted         <span class="token operator">*</span><span class="token operator">/</span>        NODE_DELETED    <span class="token punctuation">&#125;</span>     <span class="token comment">// 第一个参数：事件类型（枚举）     // 第二个参数：节点更新前的状态、数据     // 第三个参数：节点更新后的状态、数据    void event(Type type, ChildData oldData, ChildData data);    /      * When the cache is started, the initial nodes are tracked and when they are finished loading     * into the cache this method is called.     */    default void initialized()    &#123;        // NOP    &#125;    /      * Returns a builder allowing type specific, and special purpose listeners.     *     * @return builder     */    static CuratorCacheListenerBuilder builder()    &#123;        return new CuratorCacheListenerBuilderImpl();    &#125;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体代码使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//创建Watcher        CuratorCache curatorCache = CuratorCache.build(curatorFramework, "/app1");        curatorCache.listenable().addListener(new CuratorCacheListener() &#123;            @Override            public void event(Type type, ChildData oldData, ChildData data) &#123;                if ("NODE_CREATED".equals(type.name())) &#123;                    System.out.println("创建了新的节点");                &#125; else if ("NODE_CHANGED".equals(type.name())) &#123;                    System.out.println(oldData);                    System.out.println("节点发生了修改");                    System.out.println(data);                &#125; else if ("NODE_DELETED".equals(type.name())) &#123;                    System.out.println("节点被删除了");                &#125;            &#125;        &#125;);        curatorCache.start();//让测试模块可以长时间运行        while (true) &#123;        &#125; &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分布式锁（重点）"><a href="#分布式锁（重点）" class="headerlink" title="分布式锁（重点）"></a>分布式锁（重点）</h4><h5 id="分布式锁和普通锁"><a href="#分布式锁和普通锁" class="headerlink" title="分布式锁和普通锁"></a>分布式锁和普通锁</h5><p>为什么分布式系统中不能用普通锁呢?普通锁和分布式锁有什么区别吗?</p><p>普通锁</p><ol><li>单一系统找那个, 同一个应用程序是有同一个进程, 然后多个线程并发会造成数据安全问题, 他们是共享同一块内存的, 所以在内存某个地方做标记即可满足需求.</li><li>例如synchronized和volatile+cas一样对具体的代码做标记, 对应的就是在同一个内存区域作了同步的标记.</li></ol><p>分布式锁</p><ol><li><p>分布式系统中, 最大的区别就是不同系统中的应用程序都在各自机器上不同的进程中处理的, 这里的线程不安全可以理解为多进程造成</p><p>的数据安全问题, 他们不会共享同一台机器的同一块内存区域, 因此需要将标记存储在所有进程都能看到的地方.</p></li><li><p>例如zookeeper作分布式锁，就是将锁标记存储在多个进程共同看到的地方，redis作分布式锁，是将其标记公共内存，而不是某个进</p><p>程分配的区域.</p></li></ol><h5 id="目前分布式锁的实现"><a href="#目前分布式锁的实现" class="headerlink" title="目前分布式锁的实现"></a>目前分布式锁的实现</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115153940936.png" alt="image-20211115153940936"></p><h5 id="Zookeeper实现分布式锁的原理"><a href="#Zookeeper实现分布式锁的原理" class="headerlink" title="Zookeeper实现分布式锁的原理"></a>Zookeeper实现分布式锁的原理</h5><p>核心思想:当客户端要获取锁，则创建节点，使用完锁，则删除该节点。</p><ol><li><p>客户端获取锁时，在lock（随便起的）节点下创建临时顺序节点。</p><blockquote><p>Q:为什么创建临时节点</p><p>A:保证锁可以正常释放。当获取锁的client发生宕机，持久化节点所持有的锁就无法释放，而临时节点在链接断开之后就会被删除，同时释放锁资源。</p></blockquote></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115155140706.png" alt="image-20211115155140706"></p><ol start="2"><li><p>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取</p><p>到了锁。使用完锁后，将该节点删除。</p></li><li><p>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时</p><p>对其注册事件监听器，监听删除事件。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115155454060.png" alt="image-20211115155454060"></p></li><li><p>如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号</p><p>最小的，如果是则获取到了锁,如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</p></li></ol><h3 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h3><h4 id="Zookeeper集群介绍"><a href="#Zookeeper集群介绍" class="headerlink" title="Zookeeper集群介绍"></a>Zookeeper集群介绍</h4><p>Leader选举:</p><ul><li>Serverid:服务器ID<br>比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。.</li><li>Zxid:数据ID<br>服务器中存放的最大数据ID.值越大说明数据越新，在选举算法中数据越新权重越大。<br>在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票,则此ZooKeeper就可以成为Leader了.</li></ul><h4 id="Zookeeper伪集群搭建"><a href="#Zookeeper伪集群搭建" class="headerlink" title="Zookeeper伪集群搭建"></a>Zookeeper伪集群搭建</h4><h5 id="zookeeper集群种类"><a href="#zookeeper集群种类" class="headerlink" title="zookeeper集群种类"></a>zookeeper集群种类</h5><p>1、单节点方式：部署在一台机器上</p><p>2、单IP多节点：部署在同一IP，但是有多个节点，各有自己的端口</p><p>3、多IP多节点：部署在不同IP，各有自己的端口</p><h5 id="伪集群的搭建"><a href="#伪集群的搭建" class="headerlink" title="伪集群的搭建"></a>伪集群的搭建</h5><ol><li><p>基本安装</p><p>在usr/local/zookeeper-cluster创建三个zookeeper文件夹</p><p>对应三个zookeeper</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir zookeeper-clustermkdir zookeeper-1mkdir zookeeper-2mkdir zookeeper-3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将zookeeper文件复制到三个文件夹下，可以是提前解压好的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cp -r apache-zookeeper-3.7.0-bin  &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1cp -r apache-zookeeper-3.7.0-bin  &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2cp -r apache-zookeeper-3.7.0-bin  &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为每个zookeeper创建对应的data目录，并将conf下的zoo_sample.cfg文件改名为zoo.cfg</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;zkdatamkdir &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;zkdatamkdir &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;zkdatamv &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;conf&#x2F;zoo.cfgmv &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;conf&#x2F;zoo.cfgmv &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;conf&#x2F;zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置zookeeper的dataDir和clientPort</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;conf&#x2F;zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cfg" data-language="cfg"><code class="language-cfg">#zoo.cfgdataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdataclientPort&#x3D;2181&#x2F;2182&#x2F;2183<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置完成后，三个zookeeper还是属于单机的状态，不知道其他zookeeper的存在</p></li><li><p>集群配置</p><p>在每个zookeeper的data目录下创建一个myid文件，内容分别是1、2、3。这个文件就是记录每个服务器的ID</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo 1 &gt;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdata&#x2F;myidecho 2 &gt;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdata&#x2F;myidecho 3 &gt;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdata&#x2F;myid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每一个zookeeper的zoo.cfg配置客户端访问端口(clientPort）和集群服务器IP列表。集群服务器P列表如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;conf&#x2F;zoo.cfgvi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;apache-zookeeper-3.7.0-bin&#x2F;conf&#x2F;zoo.cfgvi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;apache-zookeeper-3.7.0-bin&#x2F;conf&#x2F;zoo.cfgserver.1&#x3D;(服务器ip)124.70.145.43:2881:（）3881<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释: server.服务器ID=服务器IP地址:服务器之间通信端口:服务器之间投票选举端口</p></li><li><p>启动集群</p><p>启动server1</p><p>使用bin/zkServer.sh status查看server1的启动结果：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115215138963.png" alt="image-20211115215138963"></p><p>此时server2和server3都没有正常启动，因此此时出现失败是正常的，等到2和3启动后就会消失。</p></li></ol><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>同一IP上搭建多个节点的集群时，必须要注意端口问题，端口必须不一致才行；</p><p>创建多个节点集群时，在dataDir目录下必须创建myid文件，myid文件用于zookeeper验证server序号等，myid文件只有一行，并且为当前server的序号，例如server.1的myid就是1，server2的myid就是2等。</p></blockquote><h4 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h4><p>和伪集群配置差不多，只不过需要注意一些点</p><p>注意点参考文章：<a href="https://blog.csdn.net/beitiandijun/article/details/41802835">https://blog.csdn.net/beitiandijun/article/details/41802835</a></p><h4 id="Zookeeper集群角色"><a href="#Zookeeper集群角色" class="headerlink" title="Zookeeper集群角色"></a>Zookeeper集群角色</h4><p>在ZooKeeper集群服中务中有三个角色:</p><ul><li><code>leader</code> 是集群中最重要的角色。负责响应集群的所有对Zookeeper数据状态变更的请求（可以理解为事务请求）。它会将每个状态更新请求进行顺序管理，以便保证整个集群内部消息处理的 FIFO，遵循了顺序一致性（Sequential Consistency）。<ul><li><code>leader</code> 内部维护 session ，来自客户端的连接和断开连接，都会被统一<code>follower</code> 或 <code>observer</code> 转发给<code>leader</code>处理。</li><li><code>leader</code> 内部维护单调递增的 Zxid（<code>ZooKeeper Transaction Id</code>），针对客户端连接，断开连接，节点的写操作都会分配一个全局唯一的Zxid，同时这些操作是原子性的，并且是严格顺序性的，遵循<code>ZAB</code>原子广播一致性协议完成事务（transaction）操作。如果客户端的所有写操作，都会被 <code>follower</code> 统一转发给<code>leader</code>处理。</li></ul></li><li><code>follower</code> <ul><li>具有选举权，参与<code>Leader</code>选举投票。</li><li>负责给<code>leader</code>转发客户端的写服务（事务请求），需要响应<code>leader</code>的提议</li><li>处理客户端非事务请求（读）</li></ul></li><li><code>observer </code><ul><li>没有选举权。</li><li>主要提供给客户端读服务，不提供写服务，也不需要响应<code>leader</code>的提议。</li><li>不需要日志文件，因为没有写服务，没有持久化的需要。</li></ul></li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h2><h4 id="为什么分布式系统中不能用普通锁呢-普通锁和分布式锁有什么区别吗"><a href="#为什么分布式系统中不能用普通锁呢-普通锁和分布式锁有什么区别吗" class="headerlink" title="为什么分布式系统中不能用普通锁呢?普通锁和分布式锁有什么区别吗?"></a>为什么分布式系统中不能用普通锁呢?普通锁和分布式锁有什么区别吗?</h4><p>普通锁</p><ol><li><p>单一系统找那个, 同一个应用程序是有同一个进程, 然后多个线程并发会造成数据安全问题, 他们是共享同一块内存的, 所以在内存某个地方</p></li><li><p>做标记即可满足需求.例如synchronized和volatile+cas一样对具体的代码做标记, 对应的就是在同一个内存区域作了同步的标记.</p></li></ol><p>分布式锁</p><ol><li>分布式系统中, 最大的区别就是不同系统中的应用程序都在各自机器上不同的进程中处理的, 这里的线程不安全可以理解为多进程造成的数据安全问题, 他们不会共享同一台机器的同一块内存区域, 因此需要将标记存储在所有进程都能看到的地方.</li><li>例如zookeeper作分布式锁，就是将锁标记存储在多个进程共同看到的地方，redis作分布式锁，是将其标记公共内存，而不是某个进程分配的区域.</li></ol><h4 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h4><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li><li>高可用的获取锁与释放锁；</li><li>高性能的获取锁与释放锁；</li><li>具备可重入特性；</li><li>具备锁失效机制，防止死锁；</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ul><h4 id="分布式锁的三种实现方式"><a href="#分布式锁的三种实现方式" class="headerlink" title="分布式锁的三种实现方式"></a>分布式锁的三种实现方式</h4><ol><li><p>基于数据库实现分布式锁；</p></li><li><p>基于缓存（Redis等）实现分布式锁；</p></li><li><p>基于Zookeeper实现分布式锁；</p><p>尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！</p></li></ol><h4 id="数据库的分布式锁的实现"><a href="#数据库的分布式锁的实现" class="headerlink" title="数据库的分布式锁的实现"></a>数据库的分布式锁的实现</h4><p>参考博客：<a href="https://blog.csdn.net/weixin_42641909/article/details/106721358">https://blog.csdn.net/weixin_42641909/article/details/106721358</a></p><h5 id="基于表记录实现分布式锁"><a href="#基于表记录实现分布式锁" class="headerlink" title="基于表记录实现分布式锁"></a>基于表记录实现分布式锁</h5><p>基于数据库的实现方式的核心思想是:</p><p>在数据库中创建一个表, 表中包含方法名等字段, 并在方法名字段上创建唯一索引.</p><p>想要执行某个方法, 就使用这个方法名向表中插入数据, 成功插入则获取锁, 执行完成后删除对应的行数据释放锁.</p><ol><li><p>创建一个表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>method_lock<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>method_lock<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>method_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'锁定的方法名'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">desc</span><span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'备注信息'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uidx_method_name<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>method_name<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'锁定中的方法'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211115190429329.png" alt="image-20211115190429329"></p><ol start="2"><li><p>想要执行某个方法, 就使用这个方法名向表中插入数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> method_lock <span class="token punctuation">(</span>method_name<span class="token punctuation">,</span> <span class="token keyword">desc</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'methodName'</span><span class="token punctuation">,</span> <span class="token string">'测试的methodName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我们对method_name做了唯一性约束, 这里如果有多个请求同事提交到数据库的话, 数据库会保证只有一个操作可以成功, 那么我们就可以认为操作成功的那个现场恒获得了该方法的锁, 可以执行方法体内容.</p></li><li><p>成功插入则获取锁, 执行完成后删除对应的行数据释放锁</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delete</span> <span class="token keyword">from</span> method_lock <span class="token keyword">where</span> method_name <span class="token operator">=</span><span class="token string">'methodName'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>基于表记录实现分布式锁的特点</p><ul><li><p>这种锁没有失效时间, 一旦释放锁的操作失败就会导致锁记录一直在数据库中, 其他线程无法获得锁. 这个缺陷也很好解决, 比如可以做</p><p>一个定时任务去定时清理.</p></li><li><p>这种锁的可靠性依赖于数据库, 建议设置备库, 避免单点, 进一步提高可靠性.</p></li><li><p>这种锁是非阻塞的, 因为插入数据失败之后会直接报错, 想要获得锁就需要再次操作. 如果需要阻塞式的, 可以来个for循环或while循环, </p><p>直至INSERT成功再返回.</p></li><li><p>这种锁也是非可重入的, 因为同一个线程在没有释放锁之前无法再次获得锁, 因为数据库中已经存在同一份记录了. 想要实现可重入锁, </p><p>可以在数据库中添加一些字段, 比如获得锁的主机信息、线程信息等, 那么在再次获得锁的时候可以先查询数据, 如果当前的主机信息</p><p>和线程信息等能被查到的话, 可以直接把锁分配给它.</p></li></ul><h5 id="基于乐观锁实现分布式锁"><a href="#基于乐观锁实现分布式锁" class="headerlink" title="基于乐观锁实现分布式锁"></a>基于乐观锁实现分布式锁</h5><pre><code>    系统认为数据的更新在大多数情况下是不会产生冲突的，只在数据库更新操作提交的时候才对数据作冲突检测。如果检测的结果出现了与预期数据不一致的情况，则返回失败信息.    乐观锁大多数是基于数据版本(version)的记录机制实现的. 即为数据增加一个版本标识.</code></pre><ol><li>在基于数据库表的版本解决方案中, 一般是通过为数据库表添加一个 “version”字段来实现读取出数据时, 将此版本号一同读出, 之后更新时, 对此版本号加1.</li><li>在更新过程中, 会对版本号进行比较, 如果是一致的, 没有发生改变, 则会成功执行本次操作; 如果版本号不一致, 则会更新失败.</li></ol><ul><li><p>基于乐观锁的优点</p><p>在检测数据冲突时并不依赖数据库本身的锁机制, 不会影响请求的性能, 当产生并发且并发量较小的时候只有少部分请求会失败.</p></li><li><p>基于乐观锁的缺点</p><p>需要对表的设计增加额外的字段, 增加了数据库的冗余, 另外, 当应用并发量高的时候, version值在频繁变化, 则会导致大量请求失败, 影响系统的可用性.</p></li></ul><p>  综合数据库乐观锁的优缺点, 乐观锁比较适合并发量不高, 并且写操作不频繁的场景.</p><h5 id="基于悲观锁实现分布式锁"><a href="#基于悲观锁实现分布式锁" class="headerlink" title="基于悲观锁实现分布式锁"></a>基于悲观锁实现分布式锁</h5><pre><code>    除了通过增删操作数据库表中的记录来实现分布式锁, 我们还可以借助数据库中再带的锁来实现分布式锁.    在查询语句后面增加For Update, 数据库会在查询过程中给数据库表增加悲观锁(也成排他锁), 当某条记录被加上悲观锁后, 其他线程</code></pre><p>也就无法再该行上增加悲观锁了.</p><ol><li><p>悲观锁与乐观锁相反, 总是假设最坏的情况, 它认为数据的更新在大多数情况下是会产生冲突的.</p></li><li><p>在使用悲观锁的同时, 我们需要注意一下锁的级别. 搜索引擎的不同也会带了锁级别的不同.</p><p>如果存储引擎是InnoDB, 在加锁的时候只有明确地指定主键(或索引)的才会执行行锁(只锁住被选取的数据), 否则Mysql将会执行表锁(将整个数据表单给锁住).</p></li></ol><p>使用悲观锁实现分布式锁特点</p><ol><li>在悲观锁中, 每一次行数据的访问都是独占的, 只有当正在访问该行数据的请求事务提交以后, 其他请求才能依次访问该数据, 否则将阻塞等待锁的释放.</li><li>悲观锁可以严格保证数据访问的安全.</li><li>但是缺点也明显, 即每次请求都会额产生加锁的开销, 且未获取到锁的请求将会阻塞等待锁的释放, 在高并发环境下, 容易造成大量请求阻塞, 影响系统可用性,</li><li>悲观锁使用不当还可能产生死锁的情况</li></ol><h4 id="Redis的分布式锁"><a href="#Redis的分布式锁" class="headerlink" title="Redis的分布式锁"></a>Redis的分布式锁</h4><p>待补充！！！！！！！！！！！</p><h2 id="二、关于设置图床"><a href="#二、关于设置图床" class="headerlink" title="二、关于设置图床"></a>二、关于设置图床</h2><p><a href="https://www.codenong.com/cs106528795/">https://www.codenong.com/cs106528795/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> dubbo </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
