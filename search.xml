<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="/2021/11/29/rabbitmq/"/>
      <url>/2021/11/29/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717161939695.png" alt="image-20210717161939695"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717162004285.png" alt="image-20210717162004285"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210422095356088.png" alt="image-20210422095356088"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考资料：</p><p>我们在Centos7虚拟机中使用Docker来安装。</p><p>方式一：在线拉取</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker pull rabbitmq:3-management<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717162628635.png" alt="image-20210717162628635"></p><p>MQ的基本结构：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717162752376.png" alt="image-20210717162752376"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163332646.png" alt="image-20210717163332646"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163253264.png" alt="image-20210717163253264"></p><p>导入后可以看到结构如下：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163604330.png" alt="image-20210717163604330"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717163434647.png" alt="image-20210717163434647"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">Channel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">Connection</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">ConnectionFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublisherTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.建立连接</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"124.70.145.43"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2.建立连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建通道Channel</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.创建队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.发送消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, rabbitmq!"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息成功：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5.关闭通道和连接</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeoutException</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.建立连接</span>        <span class="token class-name">ConnectionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"124.70.145.43"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.2.建立连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.创建通道Channel</span>        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.创建队列</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.订阅消息</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span><span class="token class-name">String</span> consumerTag<span class="token punctuation">,</span> <span class="token class-name">Envelope</span> envelope<span class="token punctuation">,</span>                                       <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 5.处理消息</span>                <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到消息：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717164024967.png" alt="image-20210717164024967"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717164038678.png" alt="image-20210717164038678"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息 </li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--AMQP依赖，包含RabbitMQ--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 124.70.145.43 <span class="token comment"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> root <span class="token comment"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span> <span class="token comment"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>spring</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span><span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAmqpTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 队列名称</span>        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        <span class="token comment">// 消息</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>        <span class="token comment">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 124.70.145.43 <span class="token comment"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> root <span class="token comment"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span> <span class="token comment"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>listener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">RabbitListener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717164238910.png" alt="image-20210717164238910"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * workQueue     * 向队列中不停发送消息，模拟消息堆积。     */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列名称</span>    <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, message_"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">```<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165309625.png" alt="image-20210717165309625"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165438225.png" alt="image-20210717165438225"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165509466.png" alt="image-20210717165509466"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717165552676.png" alt="image-20210717165552676"></p><p>在consumer中创建一个类，声明队列和交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Binding</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">BindingBuilder</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">FanoutExchange</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Queue</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FanoutConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 声明交换机     * @return Fanout类型交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">"itcast.fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 第1个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue1</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue1<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 第2个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue2</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue2<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队列名称    </span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"itcast.fanout"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息    </span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, everyone!"</span><span class="token punctuation">;</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者1接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170041447.png" alt="image-20210717170041447"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170223317.png" alt="image-20210717170223317"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue1"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue2"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendDirectExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换机名称    </span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"direct"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息    </span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！"</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息    </span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170705380.png" alt="image-20210717170705380"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210717170829229.png" alt="image-20210717170829229"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * topicExchange */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendTopicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换机名称</span>    <span class="token class-name">String</span> exchangeName <span class="token operator">=</span> <span class="token string">"topic"</span><span class="token punctuation">;</span>    <span class="token comment">// 消息</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"喜报！孙悟空大战哥斯拉，胜!"</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"china.news"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*---------------topic-------------------*/</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue1"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"china.#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue2"</span><span class="token punctuation">)</span>        <span class="token punctuation">,</span> exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span>        <span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#.news"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20200525170410401.png" alt="image-20200525170410401"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 准备消息</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20210422232835363.png" alt="image-20210422232835363"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可，覆盖默认的bean：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">MessageConverter</span> <span class="token function">jsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2021/11/29/java-nio/"/>
      <url>/2021/11/29/java-nio/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://nyimac.gitee.io/2020/11/30/Java%20NIO/">转自</a></strong></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p><h2 id="二、IO与NIO的区别"><a href="#二、IO与NIO的区别" class="headerlink" title="二、IO与NIO的区别"></a>二、IO与NIO的区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(NonBlocking IO)</td></tr><tr><td></td><td>选择器(Selectors)</td></tr></tbody></table><h3 id="1、面向流和缓冲区"><a href="#1、面向流和缓冲区" class="headerlink" title="1、面向流和缓冲区"></a>1、面向流和缓冲区</h3><p><strong>IO</strong></p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109084453.png" alt="img"></a></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>这里通道就像是铁路，能够连通两个地点。缓冲区就像是火车，能够真正地进行数据的传输</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109085054.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109085054.png" alt="img"></a></p><h2 id="三、通道与缓冲区"><a href="#三、通道与缓冲区" class="headerlink" title="三、通道与缓冲区"></a>三、通道与缓冲区</h2><p>Java NIO系统的核心在于：**通道(Channel)和缓冲区(Buffer)**。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><h2 id="四、缓冲区-Buffer"><a href="#四、缓冲区-Buffer" class="headerlink" title="四、缓冲区(Buffer)"></a>四、缓冲区(Buffer)</h2><h3 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h3><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><pre class="line-numbers language-none"><code class="language-none">final byte[] hb;                  &#x2F;&#x2F; Non-null only for heap buffers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>IntBuffer</p><pre class="line-numbers language-none"><code class="language-none">final int[] hb;                  &#x2F;&#x2F; Non-null only for heap buffers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>他们的继承关系如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109091555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109091555.png" alt="img"></a></p><h3 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h3><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取一个容量大小为1024字节的字节缓冲区ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h3><p>缓冲区的父类Buffer中有几个核心属性，如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacityprivate int mark &#x3D; -1;private int position &#x3D; 0;private int limit;private int capacity;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" alt="img"></a></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h4><pre class="line-numbers language-none"><code class="language-none">public class Demo1 &#123;public static void main(String[] args) &#123;ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);System.out.println(&quot;放入前参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------put()------&quot;);System.out.println(&quot;放入3个数据&quot;);byte bt &#x3D; 1;byteBuffer.put(bt);byteBuffer.put(bt);byteBuffer.put(bt);System.out.println(&quot;放入后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------flip()-get()------&quot;);System.out.println(&quot;读取一个数据&quot;);&#x2F;&#x2F; 切换模式byteBuffer.flip();byteBuffer.get();System.out.println(&quot;读取后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------rewind()------&quot;);byteBuffer.rewind();System.out.println(&quot;恢复后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;------clear()------&quot;);&#x2F;&#x2F; 清空缓冲区，这里只是恢复了各个属性的值，但是缓冲区里的数据依然存在&#x2F;&#x2F; 但是下次写入的时候会覆盖缓冲区中之前的数据byteBuffer.clear();System.out.println(&quot;清空后参数&quot;);System.out.println(&quot;position &quot; + byteBuffer.position());System.out.println(&quot;limit &quot; + byteBuffer.limit());System.out.println(&quot;capacity &quot; + byteBuffer.capacity());System.out.println();System.out.println(&quot;清空后获得数据&quot;);System.out.println(byteBuffer.get());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果</p><pre class="line-numbers language-none"><code class="language-none">放入前参数position 0limit 1024capacity 1024------put()------放入3个数据放入后参数position 3limit 1024capacity 1024------flip()-get()------读取一个数据读取后参数position 1limit 3capacity 1024------rewind()------恢复后参数position 0limit 3capacity 1024------clear()------清空后参数position 0limit 1024capacity 1024清空后获得数据1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h3><h4 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h4><p>通过<strong>allocate()<strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM</strong>堆内存</strong>之中的。</p><pre class="line-numbers language-none"><code class="language-none">public static ByteBuffer allocate(int capacity) &#123;    if (capacity &lt; 0)    throw new IllegalArgumentException();    &#x2F;&#x2F; 在堆内存中开辟空间    return new HeapByteBuffer(capacity, capacity);&#125;HeapByteBuffer(int cap, int lim) &#123;        &#x2F;&#x2F; package-private    &#x2F;&#x2F; new byte[cap] 创建数组，在堆内存中开辟空间    super(-1, 0, lim, cap, new byte[cap], 0);    &#x2F;*    hb &#x3D; new byte[cap];    offset &#x3D; 0;    *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151057.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151057.png" alt="img"></a></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以费直接缓冲区的读取效率较低</p><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><pre class="line-numbers language-none"><code class="language-none">public static ByteBuffer allocateDirect(int capacity) &#123;    return new DirectByteBuffer(capacity);&#125;DirectByteBuffer(int cap) &#123;                   &#x2F;&#x2F; package-private...    &#x2F;&#x2F; 申请物理内存boolean pa &#x3D; VM.isDirectMemoryPageAligned();...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151520.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109151520.png" alt="img"></a></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h2 id="五、通道-Channel"><a href="#五、通道-Channel" class="headerlink" title="五、通道(Channel)"></a>五、通道(Channel)</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>Channel由java.nio.channels 包定义的。Channel 表示<strong>IO 源与目标打开的连接</strong>。Channel 类似于传统的“流”。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong></p><h3 id="2、图解"><a href="#2、图解" class="headerlink" title="2、图解"></a>2、图解</h3><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153039.png" alt="img"></a></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153439.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109153439.png" alt="img"></a></p><p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154113.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154113.png" alt="img"></a></p><h3 id="3、Java-Channel"><a href="#3、Java-Channel" class="headerlink" title="3、Java Channel"></a>3、Java Channel</h3><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154803.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109154803.png" alt="img"></a></p><ul><li>本地文件IO<ul><li>FileChannel</li></ul></li><li>网络IO<ul><li>SocketChanel、ServerSocketChannel：用于TCP传输</li><li>DatagramChannel：用于UDP传输</li></ul></li></ul><h4 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h4><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><pre class="line-numbers language-none"><code class="language-none">public class Demo2 &#123;   public static void main(String[] args) throws IOException &#123;      &#x2F;&#x2F; 本地通道      FileInputStream fileInputStream &#x3D; new FileInputStream(&quot;&quot;);      FileChannel channel1 &#x3D; fileInputStream.getChannel();      FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;&quot;);      FileChannel channel2 &#x3D; fileOutputStream.getChannel();         &#x2F;&#x2F; 网络通道      Socket socket &#x3D; new Socket();      SocketChannel channel3 &#x3D; socket.getChannel();            ServerSocket serverSocket &#x3D; new ServerSocket();      ServerSocketChannel channel4 &#x3D; serverSocket.getChannel();      DatagramSocket datagramSocket &#x3D; new DatagramSocket();      DatagramChannel channel5 &#x3D; datagramSocket.getChannel();             &#x2F;&#x2F; 最后要关闭通道          &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>也可以通过通道的静态方法open()来获取</strong></p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws IOException &#123;   FileChannel open &#x3D; FileChannel.open(Paths.get(&quot;&quot;));      SocketChannel open1 &#x3D; SocketChannel.open();      ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h4><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><pre class="line-numbers language-none"><code class="language-none">public class Demo4 &#123;   public static void main(String[] args) &#123;      FileInputStream is &#x3D; null;      FileOutputStream os &#x3D; null;      &#x2F;&#x2F; 获得通道      FileChannel inChannel &#x3D; null;      FileChannel outChannel &#x3D; null;             &#x2F;&#x2F; 利用 try-catch-finally 保证关闭      try &#123;         is &#x3D; new FileInputStream(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;);         os &#x3D; new FileOutputStream(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;);         &#x2F;&#x2F; 获得通道         inChannel &#x3D; is.getChannel();         outChannel &#x3D; os.getChannel();         &#x2F;&#x2F; 获得缓冲区，用于在通道中传输数据         ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);         &#x2F;&#x2F; 循环将字节数据放入到buffer中，然后写入磁盘中         while (inChannel.read(byteBuffer) !&#x3D; -1) &#123;            &#x2F;&#x2F; 切换模式            byteBuffer.flip();            outChannel.write(byteBuffer);            byteBuffer.clear();         &#125;      &#125; catch (IOException e) &#123;         e.printStackTrace();      &#125; finally &#123;         if (inChannel !&#x3D; null) &#123;            try &#123;               inChannel.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         if (outChannel !&#x3D; null) &#123;            try &#123;               outChannel.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         if (is !&#x3D; null) &#123;            try &#123;               is.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;         if (os !&#x3D; null) &#123;            try &#123;               os.close();            &#125; catch (IOException e) &#123;               e.printStackTrace();            &#125;         &#125;      &#125;   &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图片读取后，被写入到了指定位置</strong><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109211055.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109211055.png" alt="img"></a></p><h4 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h4><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><pre class="line-numbers language-none"><code class="language-none">public class Demo5 &#123;   public static void main(String[] args) throws IOException &#123;      &#x2F;&#x2F; 通过open()方法来获得通道      FileChannel inChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;), StandardOpenOption.READ);      &#x2F;&#x2F; outChannel需要为 READ WRITE CREATE模式      &#x2F;&#x2F; READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式      &#x2F;&#x2F; CREATE是因为要创建新的文件      FileChannel outChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);      &#x2F;&#x2F; 获得直接缓冲区      MappedByteBuffer inMapBuf &#x3D; inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());      MappedByteBuffer outMapBuf &#x3D; outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());      &#x2F;&#x2F; 字节数组      byte[] bytes &#x3D; new byte[inMapBuf.limit()];      &#x2F;&#x2F; 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输      inMapBuf.get(bytes);      outMapBuf.put(bytes);      &#x2F;&#x2F; 关闭缓冲区，这里没有用try-catch-finally      inChannel.close();      outChannel.close();   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果，图片被创建</strong><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109214801.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109214801.png" alt="img"></a></p><h4 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h4><pre class="line-numbers language-none"><code class="language-none">public static void channelToChannel() throws IOException &#123;   long start &#x3D; System.currentTimeMillis();   &#x2F;&#x2F; 通过open()方法来获得通道   FileChannel inChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;), StandardOpenOption.READ);   &#x2F;&#x2F; outChannel需要为 READ WRITE CREATE模式   &#x2F;&#x2F; READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式   &#x2F;&#x2F; CREATE是因为要创建新的文件   FileChannel outChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);   &#x2F;&#x2F; 通道间直接传输   inChannel.transferTo(0, inChannel.size(), outChannel);   &#x2F;&#x2F; 对应的还有transferFrom   &#x2F;&#x2F; outChannel.transferFrom(inChannel, 0, inChannel.size());   inChannel.close();   outChannel.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h4><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; getChannel() + 非直接缓冲区耗时708&#x2F;&#x2F; open() + 直接缓冲区耗时115&#x2F;&#x2F; channel transferTo channel耗时47<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h3 id="4、分散和聚集"><a href="#4、分散和聚集" class="headerlink" title="4、分散和聚集"></a>4、分散和聚集</h3><h4 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h4><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082427.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082427.png" alt="img"></a></p><h4 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h4><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png" alt="img"></a></p><p><strong>代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Demo2 &#123;   public static void main(String[] args) throws IOException &#123;      FileInputStream is &#x3D; new FileInputStream(&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;);      FileOutputStream os &#x3D; new FileOutputStream(&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;);      FileChannel inChannel &#x3D; is.getChannel();      FileChannel outChannel &#x3D; os.getChannel();      &#x2F;&#x2F; 获得多个缓冲区，并且放入到缓冲区数组中      ByteBuffer byteBuffer1 &#x3D; ByteBuffer.allocate(50);      ByteBuffer byteBuffer2 &#x3D; ByteBuffer.allocate(1024);      ByteBuffer[] byteBuffers &#x3D; &#123;byteBuffer1, byteBuffer2&#125;;      &#x2F;&#x2F; 分散读取      inChannel.read(byteBuffers);            byteBuffer1.flip();      byteBuffer2.flip();            &#x2F;&#x2F; 聚集写入      outChannel.write(byteBuffers);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083219.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083219.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083230.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111083230.png" alt="img"></a></p><h2 id="六、非阻塞式网络通信"><a href="#六、非阻塞式网络通信" class="headerlink" title="六、非阻塞式网络通信"></a>六、非阻塞式网络通信</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>双11买的快递到了，快递小哥给你打电话说马上到小区门口，麻烦在门口等一下，方便签收快递</p><ul><li>若为<strong>阻塞式</strong>的，你到了小区门口以后，快递小哥还没到的期间，你什么事儿也做不了</li><li>若为<strong>非阻塞式</strong>的，快递小哥将快递放到门卫处，门卫给你发消息说快递到了，麻烦去取一下。当快递还没到的时候你可以做你自己的事儿</li></ul><h4 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h4><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111090126.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111090126.png" alt="img"></a></p><h4 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h4><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112165417.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112165417.png" alt="img"></a></p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><h4 id="阻塞式网络通信演示"><a href="#阻塞式网络通信演示" class="headerlink" title="阻塞式网络通信演示"></a>阻塞式网络通信演示</h4><pre class="line-numbers language-none"><code class="language-none">public class Demo1 &#123;   public static void main(String[] args) throws IOException &#123;      Thread thread1 &#x3D; new Thread(()-&gt;&#123;         try &#123;            server();         &#125; catch (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      Thread thread2 &#x3D; new Thread(()-&gt;&#123;         try &#123;            client();         &#125; catch (IOException e) &#123;            e.printStackTrace();         &#125;      &#125;);      thread1.start();      thread2.start();   &#125;   public static void client() throws IOException &#123;      &#x2F;&#x2F; 创建客户端通道      SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 2022));      &#x2F;&#x2F; 读取信息      FileChannel fileChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\1.jpg&quot;), StandardOpenOption.READ);      &#x2F;&#x2F; 创建缓冲区      ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);      &#x2F;&#x2F; 写入数据      while (fileChannel.read(byteBuffer) !&#x3D; -1) &#123;         byteBuffer.flip();         socketChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      fileChannel.close();      socketChannel.close();   &#125;   public static void server() throws IOException &#123;      &#x2F;&#x2F; 创建服务端通道      ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();      FileChannel fileChannel &#x3D; FileChannel.open(Paths.get(&quot;F:\\JDKLearning\\src\\main\\nio\\day3\\2.jpg&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);      &#x2F;&#x2F; 绑定链接      serverSocketChannel.bind(new InetSocketAddress(2022));      &#x2F;&#x2F; 获取客户端的通道      SocketChannel socketChannel &#x3D; serverSocketChannel.accept();      &#x2F;&#x2F; 创建缓冲区      ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);      while (socketChannel.read(byteBuffer) !&#x3D; -1) &#123;         byteBuffer.flip();         fileChannel.write(byteBuffer);         byteBuffer.clear();      &#125;      socketChannel.close();      fileChannel.close();      serverSocketChannel.close();   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="非阻塞式网络通信演示"><a href="#非阻塞式网络通信演示" class="headerlink" title="非阻塞式网络通信演示"></a>非阻塞式网络通信演示</h4><pre class="line-numbers language-none"><code class="language-none">public class DemoNIO &#123;public static void main(String[] args) &#123;Thread thread1 &#x3D; new Thread(()-&gt;&#123;try &#123;server();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;);Thread thread2 &#x3D; new Thread(()-&gt;&#123;try &#123;client();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;);thread1.start();thread2.start();&#125;public static void client() throws IOException &#123;SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 2020));&#x2F;&#x2F; 设置为非阻塞模式socketChannel.configureBlocking(false);ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);Scanner scanner &#x3D; new Scanner(System.in);while (scanner.hasNext()) &#123;String str &#x3D; scanner.next();byteBuffer.put(str.getBytes());byteBuffer.flip();socketChannel.write(byteBuffer);byteBuffer.clear();&#125;byteBuffer.clear();socketChannel.close();&#125;public static void server() throws IOException &#123;ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();serverSocketChannel.configureBlocking(false);serverSocketChannel.bind(new InetSocketAddress(2020));&#x2F;&#x2F; 获得选择器Selector selector &#x3D; Selector.open();&#x2F;&#x2F; 将通道注册到选择器中，设定为接收操作serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#x2F;&#x2F; 轮训接受while (selector.select() &gt; 0) &#123;Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();&#x2F;&#x2F; 获得事件的keywhile (iterator.hasNext()) &#123;SelectionKey key &#x3D; iterator.next();if (key.isAcceptable()) &#123;SocketChannel socketChannel &#x3D; serverSocketChannel.accept();socketChannel.configureBlocking(false);socketChannel.register(selector, SelectionKey.OP_READ);&#125; else if (key.isReadable()) &#123;&#x2F;&#x2F; 从选择器中获取通道SocketChannel socketChannel &#x3D; (SocketChannel) key.channel();ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(10);while (socketChannel.read(byteBuffer) !&#x3D; -1) &#123;int len &#x3D; byteBuffer.limit();byteBuffer.flip();System.out.println(new String(byteBuffer.array(), 0, len));byteBuffer.clear();&#125;socketChannel.close();&#125;iterator.remove();&#125;&#125;serverSocketChannel.close();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112163633.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112163633.png" alt="img"></a></p><p><strong>选择器的创建</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建一个选择器Selector selector &#x3D; Selector.open();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112164022.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201112164022.png" alt="img"></a></p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 让选择器监听一种状态myChannel.register(selector, SelectionKey.OP_READ);&#x2F;&#x2F; 让选择器监听多种状态myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习之NIO基础</title>
      <link href="/2021/11/29/netty-xue-xi-zhi-nio-ji-chu/"/>
      <url>/2021/11/29/netty-xue-xi-zhi-nio-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty学习之NIO基础"><a href="#Netty学习之NIO基础" class="headerlink" title="Netty学习之NIO基础"></a>Netty学习之NIO基础</h1><p>本博客是根据<a href="https://www.bilibili.com/video/BV1py4y1E7oA?p=2"><strong>黑马程序员Netty实战</strong></a>学习时所做的笔记</p><p>博客转载自：<a href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/"><strong>Netty学习之NIO基础</strong></a></p><h1 id="一、三大组件简介"><a href="#一、三大组件简介" class="headerlink" title="一、三大组件简介"></a>一、三大组件简介</h1><p><strong>Channel与Buffer &amp;Selector</strong></p><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)<strong>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于</strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Buffer有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png" alt="img"></a></p><h2 id="1、Selector"><a href="#1、Selector" class="headerlink" title="1、Selector"></a>1、Selector</h2><p>在使用Selector之前，处理socket连接还有以下两种方法</p><p><strong>使用多线程技术</strong></p><p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><p><strong>使用线程池技术</strong></p><p>使用线程池，让线程池中的线程去处理连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li><p>阻塞模式下，线程仅能处理一个连接</p><ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li></ul></li><li><p>仅适合</p><p>短连接</p><p>场景</p><ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><p><strong>使用选择器</strong></p><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png" alt="img"></a></p><p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="2、Buffer"><a href="#2、Buffer" class="headerlink" title="2、Buffer"></a>2、Buffer</h2><h3 id="ByteBuffer使用案例"><a href="#ByteBuffer使用案例" class="headerlink" title="ByteBuffer使用案例"></a>ByteBuffer使用案例</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p></li><li><p>调用 flip() 切换至</p><p>读模式</p><ul><li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li></ul></li><li><p>从 buffer 读取数据，例如调用 buffer.get()</p></li><li><p>调用 clear() 或者compact()切换至</p><p>写模式</p><ul><li>调用clear()方法时<strong>position=0，limit变为capacity</strong></li><li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li></ul></li><li><p>重复以上步骤</p></li></ul><p><strong>使用ByteBuffer读取文件中的内容</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestByteBuffer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 获得FileChannel        try (FileChannel channel &#x3D; new FileInputStream(&quot;stu.txt&quot;).getChannel()) &#123;            &#x2F;&#x2F; 获得缓冲区            ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);            int hasNext &#x3D; 0;            StringBuilder builder &#x3D; new StringBuilder();            while((hasNext &#x3D; channel.read(buffer)) &gt; 0) &#123;                &#x2F;&#x2F; 切换模式 limit&#x3D;position, position&#x3D;0                buffer.flip();                &#x2F;&#x2F; 当buffer中还有数据时，获取其中的数据                while(buffer.hasRemaining()) &#123;                    builder.append((char)buffer.get());                &#125;                &#x2F;&#x2F; 切换模式 position&#x3D;0, limit&#x3D;capacity                buffer.clear();            &#125;            System.out.println(builder.toString());        &#125; catch (IOException e) &#123;        &#125;    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果</p><pre class="line-numbers language-none"><code class="language-none">0123456789abcdefCopy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p><strong>向buffer写入数据有两种办法</strong></p><ul><li>调用channel 的read方法</li><li>调用buffer自己的put方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> readBytes <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">buf<span class="token punctuation">.</span>put <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>从buffer读取数据同样有两种办法</strong></p><ul><li>调用channel的 write方法</li><li>调用buffer自己的get方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> writeBytes <span class="token operator">=</span> channel<span class="token punctuation">.</span> <span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> b <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>get方法会让position读指针向后走，如果想重复读取数据</p><ul><li>可以调用rewind方法将position重新置为0</li><li>或者调用get(int i)方法获取索引i的内容，它不会移动读指针</li></ul><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacityprivate int mark &#x3D; -1;private int position &#x3D; 0;private int limit;private int capacity;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li><li><strong>注意：get(i)方法不会改变position的值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" alt="img"></a></p><h4 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值（索引）</li></ul><p>通常将mark()和reset()方法一起使用，mark方法用来标记重要的文件内容的索引，reset可以回到mark方法标记的地方</p><h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p><ul><li>compact会把未读完的数据向前压缩，然后切换到写模式</li><li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png" alt="img"></a></p><h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a>clear() VS compact()</h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p><p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p><h3 id="方法调用及演示"><a href="#方法调用及演示" class="headerlink" title="方法调用及演示"></a>方法调用及演示</h3><h4 id="ByteBuffer调试工具类"><a href="#ByteBuffer调试工具类" class="headerlink" title="ByteBuffer调试工具类"></a>ByteBuffer调试工具类</h4><p>可以使用debugAll方法来研究ByteBuffer的核心参数的变化情况。</p><p>需要先导入netty依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;  &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;  &lt;version&gt;4.1.51.Final&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;Copyimport java.nio.ByteBuffer;import io.netty.util.internal.MathUtil;import io.netty.util.internal.StringUtil;import io.netty.util.internal.MathUtil.*;public class ByteBufferUtil &#123;    private static final char[] BYTE2CHAR &#x3D; new char[256];    private static final char[] HEXDUMP_TABLE &#x3D; new char[256 * 4];    private static final String[] HEXPADDING &#x3D; new String[16];    private static final String[] HEXDUMP_ROWPREFIXES &#x3D; new String[65536 &gt;&gt;&gt; 4];    private static final String[] BYTE2HEX &#x3D; new String[256];    private static final String[] BYTEPADDING &#x3D; new String[16];    static &#123;        final char[] DIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();        for (int i &#x3D; 0; i &lt; 256; i++) &#123;            HEXDUMP_TABLE[i &lt;&lt; 1] &#x3D; DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] &#x3D; DIGITS[i &amp; 0x0F];        &#125;        int i;        &#x2F;&#x2F; Generate the lookup table for hex dump paddings        for (i &#x3D; 0; i &lt; HEXPADDING.length; i++) &#123;            int padding &#x3D; HEXPADDING.length - i;            StringBuilder buf &#x3D; new StringBuilder(padding * 3);            for (int j &#x3D; 0; j &lt; padding; j++) &#123;                buf.append(&quot;   &quot;);            &#125;            HEXPADDING[i] &#x3D; buf.toString();        &#125;        &#x2F;&#x2F; Generate the lookup table for the start-offset header in each row (up to 64KiB).        for (i &#x3D; 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;            StringBuilder buf &#x3D; new StringBuilder(12);            buf.append(StringUtil.NEWLINE);            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));            buf.setCharAt(buf.length() - 9, &#39;|&#39;);            buf.append(&#39;|&#39;);            HEXDUMP_ROWPREFIXES[i] &#x3D; buf.toString();        &#125;        &#x2F;&#x2F; Generate the lookup table for byte-to-hex-dump conversion        for (i &#x3D; 0; i &lt; BYTE2HEX.length; i++) &#123;            BYTE2HEX[i] &#x3D; &#39; &#39; + StringUtil.byteToHexStringPadded(i);        &#125;        &#x2F;&#x2F; Generate the lookup table for byte dump paddings        for (i &#x3D; 0; i &lt; BYTEPADDING.length; i++) &#123;            int padding &#x3D; BYTEPADDING.length - i;            StringBuilder buf &#x3D; new StringBuilder(padding);            for (int j &#x3D; 0; j &lt; padding; j++) &#123;                buf.append(&#39; &#39;);            &#125;            BYTEPADDING[i] &#x3D; buf.toString();        &#125;        &#x2F;&#x2F; Generate the lookup table for byte-to-char conversion        for (i &#x3D; 0; i &lt; BYTE2CHAR.length; i++) &#123;            if (i &lt;&#x3D; 0x1f || i &gt;&#x3D; 0x7f) &#123;                BYTE2CHAR[i] &#x3D; &#39;.&#39;;            &#125; else &#123;                BYTE2CHAR[i] &#x3D; (char) i;            &#125;        &#125;    &#125;    &#x2F;**     * 打印所有内容     * @param buffer     *&#x2F;    public static void debugAll(ByteBuffer buffer) &#123;        int oldlimit &#x3D; buffer.limit();        buffer.limit(buffer.capacity());        StringBuilder origin &#x3D; new StringBuilder(256);        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), oldlimit);        System.out.println(origin);        buffer.limit(oldlimit);    &#125;    &#x2F;**     * 打印可读取内容     * @param buffer     *&#x2F;    public static void debugRead(ByteBuffer buffer) &#123;        StringBuilder builder &#x3D; new StringBuilder(256);        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), buffer.limit());        System.out.println(builder);    &#125;    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;        if (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;            throw new IndexOutOfBoundsException(                    &quot;expected: &quot; + &quot;0 &lt;&#x3D; offset(&quot; + offset + &quot;) &lt;&#x3D; offset + length(&quot; + length                            + &quot;) &lt;&#x3D; &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#39;)&#39;);        &#125;        if (length &#x3D;&#x3D; 0) &#123;            return;        &#125;        dump.append(                &quot;         +-------------------------------------------------+&quot; +                        StringUtil.NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +                        StringUtil.NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);        final int startIndex &#x3D; offset;        final int fullRows &#x3D; length &gt;&gt;&gt; 4;        final int remainder &#x3D; length &amp; 0xF;        &#x2F;&#x2F; Dump the rows which have 16 bytes.        for (int row &#x3D; 0; row &lt; fullRows; row++) &#123;            int rowStartIndex &#x3D; (row &lt;&lt; 4) + startIndex;            &#x2F;&#x2F; Per-row prefix.            appendHexDumpRowPrefix(dump, row, rowStartIndex);            &#x2F;&#x2F; Hex dump            int rowEndIndex &#x3D; rowStartIndex + 16;            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(&quot; |&quot;);            &#x2F;&#x2F; ASCII dump            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(&#39;|&#39;);        &#125;        &#x2F;&#x2F; Dump the last row which has less than 16 bytes.        if (remainder !&#x3D; 0) &#123;            int rowStartIndex &#x3D; (fullRows &lt;&lt; 4) + startIndex;            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);            &#x2F;&#x2F; Hex dump            int rowEndIndex &#x3D; rowStartIndex + remainder;            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(HEXPADDING[remainder]);            dump.append(&quot; |&quot;);            &#x2F;&#x2F; Ascii dump            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(BYTEPADDING[remainder]);            dump.append(&#39;|&#39;);        &#125;        dump.append(StringUtil.NEWLINE +                &quot;+--------+-------------------------------------------------+----------------+&quot;);    &#125;    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;            dump.append(HEXDUMP_ROWPREFIXES[row]);        &#125; else &#123;            dump.append(StringUtil.NEWLINE);            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));            dump.setCharAt(dump.length() - 9, &#39;|&#39;);            dump.append(&#39;|&#39;);        &#125;    &#125;    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;        return (short) (buffer.get(index) &amp; 0xFF);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用ByteBuffer的方法"><a href="#调用ByteBuffer的方法" class="headerlink" title="调用ByteBuffer的方法"></a>调用ByteBuffer的方法</h4><pre class="line-numbers language-none"><code class="language-none">public class TestByteBuffer &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);        &#x2F;&#x2F; 向buffer中写入1个字节的数据        buffer.put((byte)97);        &#x2F;&#x2F; 使用工具类，查看buffer状态        ByteBufferUtil.debugAll(buffer);        &#x2F;&#x2F; 向buffer中写入4个字节的数据        buffer.put(new byte[]&#123;98, 99, 100, 101&#125;);        ByteBufferUtil.debugAll(buffer);&#x2F;&#x2F;未改变模式前，试一下能不能拿到值        &#x2F;&#x2F;System.out.println(buffer.get());        &#x2F;&#x2F;会发现读到的是零，及读不到值                &#x2F;&#x2F; 获取数据        buffer.flip();        ByteBufferUtil.debugAll(buffer);        System.out.println(buffer.get());        System.out.println(buffer.get());        ByteBufferUtil.debugAll(buffer);        &#x2F;&#x2F; 使用compact切换模式        buffer.compact();        ByteBufferUtil.debugAll(buffer);        &#x2F;&#x2F; 再次写入        buffer.put((byte)102);        buffer.put((byte)103);        ByteBufferUtil.debugAll(buffer);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 向缓冲区写入了一个字节的数据，此时postition为1+--------+-------------------- all ------------------------+----------------+position: [1], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 00 00 00 00 00 00 00 00 00                   |a.........      |+--------+-------------------------------------------------+----------------+&#x2F;&#x2F; 向缓冲区写入四个字节的数据，此时position为5+--------+-------------------- all ------------------------+----------------+position: [5], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |+--------+-------------------------------------------------+----------------+&#x2F;&#x2F; 调用flip切换模式，此时position为0，表示从第0个数据开始读取+--------+-------------------- all ------------------------+----------------+position: [0], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |+--------+-------------------------------------------------+----------------+&#x2F;&#x2F; 读取两个字节的数据             9798            &#x2F;&#x2F; position变为2             +--------+-------------------- all ------------------------+----------------+position: [2], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |+--------+-------------------------------------------------+----------------+             &#x2F;&#x2F; 调用compact切换模式，此时position及其后面的数据被压缩到ByteBuffer前面去了&#x2F;&#x2F; 此时position为3，会覆盖之前的数据             +--------+-------------------- all ------------------------+----------------+position: [3], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 64 65 64 65 00 00 00 00 00                   |cdede.....      |+--------+-------------------------------------------------+----------------+             &#x2F;&#x2F; 再次写入两个字节的数据，之前的 0x64 0x65 被覆盖         +--------+-------------------- all ------------------------+----------------+position: [5], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 64 65 66 67 00 00 00 00 00                   |cdefg.....      |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p><p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Translate &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 准备两个字符串        String str1 &#x3D; &quot;hello&quot;;        String str2 &#x3D; &quot;&quot;;        ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 通过字符串的getByte方法获得字节数组，放入缓冲区中        buffer1.put(str1.getBytes());        ByteBufferUtil.debugAll(buffer1);        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串        &#x2F;&#x2F; 切换模式        buffer1.flip();                &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [5], limit: [16]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [5], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><pre class="line-numbers language-none"><code class="language-none">public class Translate &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 准备两个字符串        String str1 &#x3D; &quot;hello&quot;;        String str2 &#x3D; &quot;&quot;;        &#x2F;&#x2F; 通过StandardCharsets的encode方法获得ByteBuffer        &#x2F;&#x2F; 此时获得的ByteBuffer为读模式，无需通过flip切换模式        ByteBuffer buffer1 &#x3D; StandardCharsets.UTF_8.encode(str1);        ByteBufferUtil.debugAll(buffer1);        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [0], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [5], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><strong>方法三</strong></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><pre class="line-numbers language-none"><code class="language-none">public class Translate &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 准备两个字符串        String str1 &#x3D; &quot;hello&quot;;        String str2 &#x3D; &quot;&quot;;        &#x2F;&#x2F; 通过StandardCharsets的encode方法获得ByteBuffer        &#x2F;&#x2F; 此时获得的ByteBuffer为读模式，无需通过flip切换模式        ByteBuffer buffer1 &#x3D; ByteBuffer.wrap(str1.getBytes());        ByteBufferUtil.debugAll(buffer1);        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();        System.out.println(str2);        ByteBufferUtil.debugAll(buffer1);    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [0], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+hello+--------+-------------------- all ------------------------+----------------+position: [5], limit: [5]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p>出现上面这些情况的原因是，发送方为了效率，将三条数据一起发了过来，但是接收方的Buffer是固定的，三条数据可能需要两个Buffer才能办到，就出现了上面这种情况</p><p><strong>粘包</strong></p><p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p><strong>半包</strong></p><p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p><p>注意</p><p>：get(index)不会改变position的值</p><ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p></li></ul><pre class="line-numbers language-none"><code class="language-none">public class ByteBufferDemo &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(32);        &#x2F;&#x2F; 模拟粘包+半包        buffer.put(&quot;Hello,world\nI&#39;m Nyima\nHo&quot;.getBytes());        &#x2F;&#x2F; 调用split函数处理        split(buffer);        buffer.put(&quot;w are you?\n&quot;.getBytes());        split(buffer);    &#125;    private static void split(ByteBuffer buffer) &#123;        &#x2F;&#x2F; 切换为读模式        buffer.flip();        for(int i &#x3D; 0; i &lt; buffer.limit(); i++) &#123;            &#x2F;&#x2F; 遍历寻找分隔符            &#x2F;&#x2F; get(i)不会移动position            &#x2F;&#x2F;&#39;\n&#39;占一个字节            if (buffer.get(i) &#x3D;&#x3D; &#39;\n&#39;) &#123;                &#x2F;&#x2F; 缓冲区长度                int length &#x3D; i+1-buffer.position();                ByteBuffer target &#x3D; ByteBuffer.allocate(length);                &#x2F;&#x2F; 将前面的内容写入target缓冲区                for(int j &#x3D; 0; j &lt; length; j++) &#123;                    &#x2F;&#x2F; 将buffer中的数据写入target中                    target.put(buffer.get());                &#125;                &#x2F;&#x2F; 打印查看结果                ByteBufferUtil.debugAll(target);            &#125;        &#125;        &#x2F;&#x2F; 切换为写模式，但是缓冲区可能未读完，这里需要使用compact        buffer.compact();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+position: [12], limit: [12]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |+--------+-------------------------------------------------+----------------++--------+-------------------- all ------------------------+----------------+position: [10], limit: [10]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#39;m Nyima.      |+--------+-------------------------------------------------+----------------++--------+-------------------- all ------------------------+----------------+position: [13], limit: [13]         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、文件编程"><a href="#二、文件编程" class="headerlink" title="二、文件编程"></a>二、文件编程</h1><h2 id="1、FileChannel"><a href="#1、FileChannel" class="headerlink" title="1、FileChannel"></a>1、FileChannel</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p><p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p><pre class="line-numbers language-none"><code class="language-none">int readBytes &#x3D; channel.read(buffer);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>可根据返回值判断是否读取完毕</strong></p><pre class="line-numbers language-none"><code class="language-none">while(channel.read(buffer) &gt; 0) &#123;    &#x2F;&#x2F; 进行对应操作    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中while(buffer.hasRemaining()) &#123;channel.write(buffer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestChannel &#123;    public static void main(String[] args) throws IOException &#123;        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);             FileChannel inputChannel &#x3D; fis.getChannel();             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;                        &#x2F;&#x2F; 执行对应操作            ...                        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><strong>position</strong></p><p>channel也拥有一个保存读取数据位置的属性，即position</p><pre class="line-numbers language-none"><code class="language-none">long pos &#x3D; channel.position();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过position(int pos)设置channel中position的值</p><pre class="line-numbers language-none"><code class="language-none">long newPos &#x3D; ...;channel.position(newPos);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="2、两个Channel传输数据"><a href="#2、两个Channel传输数据" class="headerlink" title="2、两个Channel传输数据"></a>2、两个Channel传输数据</h2><h3 id="transferTo方法"><a href="#transferTo方法" class="headerlink" title="transferTo方法"></a>transferTo方法</h3><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><p>transferTo底层使用了零拷贝技术</p><pre class="line-numbers language-none"><code class="language-none">public class TestChannel &#123;    public static void main(String[] args)&#123;        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);             FileChannel inputChannel &#x3D; fis.getChannel();             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;            &#x2F;&#x2F; 参数：inputChannel的起始位置，传输数据的大小，目的channel            &#x2F;&#x2F; 返回值为传输的数据的字节数            &#x2F;&#x2F; transferTo一次只能传输2G的数据            inputChannel.transferTo(0, inputChannel.size(), outputChannel);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><pre class="line-numbers language-none"><code class="language-none">public class TestChannel &#123;    public static void main(String[] args)&#123;        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);             FileChannel inputChannel &#x3D; fis.getChannel();             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;            long size &#x3D; inputChannel.size();            long capacity &#x3D; inputChannel.size();            &#x2F;&#x2F; 分多次传输            while (capacity &gt; 0) &#123;                &#x2F;&#x2F; transferTo返回值为传输了的字节数                capacity -&#x3D; inputChannel.transferTo(size-capacity, capacity, outputChannel);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Path与Paths"><a href="#3、Path与Paths" class="headerlink" title="3、Path与Paths"></a>3、Path与Paths</h2><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><pre class="line-numbers language-none"><code class="language-none">Path source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txtPath source &#x3D; Paths.get(&quot;d:\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\1.txt 反斜杠需要转义Path source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\1.txtPath projects &#x3D; Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\data\projectsCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><pre class="line-numbers language-none"><code class="language-none">d:|- data|- projects|- a|- bCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码</p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;d:\\data\\projects\\a\\..\\b&quot;);System.out.println(path);System.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径 会去除 . 以及 ..Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><pre class="line-numbers language-none"><code class="language-none">d:\data\projects\a\..\bd:\data\projects\bCopy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、Files"><a href="#4、Files" class="headerlink" title="4、Files"></a>4、Files</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>检查文件或者文件夹是否存在</p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);System.out.println(Files.exists(path));Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建<strong>一级目录</strong>，不能创建多级目录 </p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);Files.createDirectory(path);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建<strong>多级目录用</strong></p><pre class="line-numbers language-none"><code class="language-none">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);Files.createDirectories(path);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="拷贝及移动"><a href="#拷贝及移动" class="headerlink" title="拷贝及移动"></a>拷贝及移动</h3><p><strong>拷贝文件</strong></p><pre class="line-numbers language-none"><code class="language-none">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);Files.copy(source, target);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 StandardCopyOption 来控制</p><pre class="line-numbers language-none"><code class="language-none">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>移动文件</p><pre class="line-numbers language-none"><code class="language-none">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);Path target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除文件</p><pre class="line-numbers language-none"><code class="language-none">Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);Files.delete(target);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><pre class="line-numbers language-none"><code class="language-none">Path target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);Files.delete(target);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果<strong>目录还有内容</strong>，会抛异常 DirectoryNotEmptyException</li></ul><p>删除文件及文件夹，看看就好，这样删除时不走回收站的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//Files.delete(Paths.get("D:\\Snipaste-1.16.2-x64 –副本"));</span>    <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">walkFileTree</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"D: \\Snipaste-1.16.2-x64 -副本"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFileVisitor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Path</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">FileVisitResult</span> <span class="token function">visitFile</span><span class="token punctuation">(</span><span class="token class-name">Path</span> file<span class="token punctuation">,</span> <span class="token class-name">BasicFileAttributes</span> attrs<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visitFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">FileVisitResult</span> <span class="token function">postVisitDirectory</span><span class="token punctuation">(</span><span class="token class-name">Path</span> dir<span class="token punctuation">,</span> <span class="token class-name">IOException</span> exc<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">postVisitDirectory</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p><ul><li><p>Path：文件起始路径</p></li><li><p>FileVisitor：文件访问器，</p><p>使用访问者模式</p><ul><li><p>接口的实现类</p><p>SimpleFileVisitor</p><p>有四个方法</p><ul><li>preVisitDirectory：访问目录前的操作</li><li>visitFile：访问文件的操作</li><li>visitFileFailed：访问文件失败时的操作</li><li>postVisitDirectory：访问目录后的操作</li></ul></li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">public class TestWalkFileTree &#123;    public static void main(String[] args) throws IOException &#123;        Path path &#x3D; Paths.get(&quot;D:\Programs\Netty-demo&quot;);        &#x2F;&#x2F; 文件目录数目        AtomicInteger dirCount &#x3D; new AtomicInteger();        &#x2F;&#x2F; 文件数目        AtomicInteger fileCount &#x3D; new AtomicInteger();        Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;            @Override            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&gt;&quot;+dir);                &#x2F;&#x2F; 增加文件目录数                dirCount.incrementAndGet();                return super.preVisitDirectory(dir, attrs);            &#125;            @Override            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;                System.out.println(file);                &#x2F;&#x2F; 增加文件数                fileCount.incrementAndGet();                return super.visitFile(file, attrs);            &#125;        &#125;);        &#x2F;&#x2F; 打印数目        System.out.println(&quot;文件目录数:&quot;+dirCount.get());        System.out.println(&quot;文件数:&quot;+fileCount.get());    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><pre class="line-numbers language-none"><code class="language-none">...D:\Programs\Netty-demo\target\test-classes\netty\TestByteBufferAllocate.classD:\Programs\Netty-demo\target\test-classes\netty\TestByteBufferReadWrite.classD:\Programs\Netty-demo\target\test-classes\netty\TestByteBufferString.classD:\Programs\Netty-demo\target\test-classes\netty\TestFileChannerTransferTo.classD:\Programs\Netty-demo\target\test-classes\netty\TestFilesWalkFileTree$1.classD:\Programs\Netty-demo\target\test-classes\netty\TestFilesWalkFileTree.class文件目录数:64文件数:88Process finished with exit code 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的设计模式是<strong>访问者模式</strong></p><h1 id="三、网络编程"><a href="#三、网络编程" class="headerlink" title="三、网络编程"></a>三、网络编程</h1><h2 id="1、阻塞"><a href="#1、阻塞" class="headerlink" title="1、阻塞"></a>1、阻塞</h2><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li><p>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上</p><p>下文切换导致性能降低</p></li><li><p>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池</p><p>中所有线程，因此不适合长连接，只适合短连接</p></li></ul></li></ul><p><strong>服务端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Server &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建缓冲区        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            &#x2F;&#x2F; 为服务器通道绑定端口            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 用户存放连接的集合            ArrayList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 循环接收连接            while (true) &#123;                System.out.println(&quot;before connecting...&quot;);                &#x2F;&#x2F; 没有连接时，会阻塞线程                SocketChannel socketChannel &#x3D; server.accept();                System.out.println(&quot;after connecting...&quot;);                channels.add(socketChannel);                &#x2F;&#x2F; 循环遍历集合中的连接                for(SocketChannel channel : channels) &#123;                    System.out.println(&quot;before reading&quot;);                    &#x2F;&#x2F; 处理通道中的数据                    &#x2F;&#x2F; 当通道中没有数据可读时，会阻塞线程                    channel.read(buffer);                    buffer.flip();                    ByteBufferUtil.debugRead(buffer);                    buffer.clear();                    System.out.println(&quot;after reading&quot;);                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码，debug模式启动，端点打在简历连接之后</p><pre class="line-numbers language-none"><code class="language-none">public class Client &#123;    public static void main(String[] args) &#123;        try (SocketChannel socketChannel &#x3D; SocketChannel.open()) &#123;            &#x2F;&#x2F; 建立连接            socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));            System.out.println(&quot;waiting...&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><ul><li>客户端-服务器建立连接前：服务器端因accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png" alt="img"></a></p><ul><li>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png" alt="img"></a></p><ul><li>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png" alt="img"></a></p><ul><li>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png" alt="img"></a></p><p>使用Idea的<img src="D:\Programs\InterviewNotes\image-20210928111407802.png" alt="image-20210928111407802">完成调试<img src="D:\Programs\InterviewNotes\image-20210928112019578.png" alt="image-20210928112019578"></p><p><strong>模拟多个客户端</strong></p><p>首先需要让客户端支持开启多个</p><p><img src="D:\Programs\InterviewNotes\image-20210928113624674.png" alt="image-20210928113624674"></p><p>支持并行开启</p><p><img src="D:\Programs\InterviewNotes\image-20210928113200237.png" alt="image-20210928113200237"></p><p>设置完成之后多次启动客户端即可</p><h2 id="2、非阻塞"><a href="#2、非阻塞" class="headerlink" title="2、非阻塞"></a>2、非阻塞</h2><p>不会使线程停止</p><ul><li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li><li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li></ul><p>服务器代码如下</p><pre class="line-numbers language-none"><code class="language-none">public class Server &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建缓冲区        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            &#x2F;&#x2F; 为服务器通道绑定端口            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 用户存放连接的集合            ArrayList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 循环接收连接            while (true) &#123;                &#x2F;&#x2F; 设置为非阻塞模式，没有连接时返回null，不会阻塞线程                server.configureBlocking(false);                SocketChannel socketChannel &#x3D; server.accept();                &#x2F;&#x2F; 通道不为空时才将连接放入到集合中                if (socketChannel !&#x3D; null) &#123;                    System.out.println(&quot;after connecting...&quot;);                    channels.add(socketChannel);                &#125;                &#x2F;&#x2F; 循环遍历集合中的连接                for(SocketChannel channel : channels) &#123;                    &#x2F;&#x2F; 处理通道中的数据                    &#x2F;&#x2F; 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程                    channel.configureBlocking(false);                    int read &#x3D; channel.read(buffer);                    if(read &gt; 0) &#123;                        buffer.flip();                        ByteBufferUtil.debugRead(buffer);                        buffer.clear();                        System.out.println(&quot;after reading&quot;);                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p><h2 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><p><strong>水平触发</strong></p><p>待补充。。。。。 </p><h3 id="绑定Channel事件"><a href="#绑定Channel事件" class="headerlink" title="绑定Channel事件"></a>绑定Channel事件</h3><p>也称之为注册事件，绑定的事件selector才会关心</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">channe1<span class="token punctuation">.</span><span class="token function">configureB1ocking</span><span class="token punctuation">(</span>fa1se<span class="token punctuation">)</span><span class="token punctuation">;</span>selectionKey key <span class="token operator">=</span> channe7<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector，绑定事件<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>channel必须工作在非阻塞模式</li><li>FileChannel没有非阻塞模式，因此不能配合selector一起使用·</li><li>绑定的事件类型可以有<ul><li>connect-客户端连接成功时触发</li><li>accept-服务器端成功接受连接时触发</li><li>read -数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write -数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h3 id="监听Channel事件"><a href="#监听Channel事件" class="headerlink" title="监听Channel事件"></a>监听Channel事件</h3><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少channel发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> selector <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法2，阻塞直到绑定事件发生，或是超时(时间单位为ms)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> selector <span class="token punctuation">.</span>select <span class="token punctuation">(</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> selector <span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="select何时不阻塞"><a href="#select何时不阻塞" class="headerlink" title="select何时不阻塞"></a>select何时不阻塞</h3><blockquote><ul><li><p>事件发生时</p><ul><li>客户端发起连接请求，会触发accept事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发read事件，另外如果发送的数据大于buffer缓冲区，会触发多次读取事件</li><li>channel可写，会触发write 事件。</li><li>在linux 下nio bug 发生时</li></ul></li><li><p>调用selector.wakeup()</p></li><li><p>调用selector.close()</p></li><li><p>selector所在线程interrupt</p></li></ul></blockquote><h2 id="4、处理Accpet事件"><a href="#4、处理Accpet事件" class="headerlink" title="4、处理Accpet事件"></a>4、处理Accpet事件</h2><p>要使用Selector实现多路复用，服务端代码如下改进</p><pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 创建选择器            Selector selector &#x3D; Selector.open();                        &#x2F;&#x2F; 通道必须设置为非阻塞模式            server.configureBlocking(false);            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的事件            server.register(selector, SelectionKey.OP_ACCEPT);            while (true) &#123;                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转                &#x2F;&#x2F; 返回值为就绪的事件个数                int ready &#x3D; selector.select();                System.out.println(&quot;selector ready counts : &quot; + ready);                                &#x2F;&#x2F; 获取所有事件                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                                &#x2F;&#x2F; 使用迭代器遍历事件                &#x2F;&#x2F;如果想在遍历过程中删除元素，就使用迭代器                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                                        &#x2F;&#x2F; 判断key的类型                    if(key.isAcceptable()) &#123;                        &#x2F;&#x2F; 获得key对应的channel                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();                        System.out.println(&quot;before accepting...&quot;);                                &#x2F;&#x2F; 获取连接并处理，而且是必须处理，否则需要取消                        SocketChannel socketChannel &#x3D; channel.accept();                        System.out.println(&quot;after accepting...&quot;);                                                &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤解析</strong></p><ul><li>获得选择器Selector</li></ul><pre class="line-numbers language-none"><code class="language-none">Selector selector &#x3D; Selector.open();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>将通道设置为非阻塞模式，并注册到选择器中，并设置感兴趣的事件</p><ul><li><p>channel 必须工作在非阻塞模式</p></li><li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p></li><li><p>绑定的事件类型可以有</p><ul><li>connect - 客户端连接成功时触发</li></ul></li></ul></li><li><p>accept - 服务器端成功接受连接时触发</p><ul><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li></ul></li><li><p>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通道必须设置为非阻塞模式server.configureBlocking(false);&#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的实践server.register(selector, SelectionKey.OP_ACCEPT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p><ul><li><p>阻塞直到绑定事件发生</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.select();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.select(long timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.selectNow();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取所有事件Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                &#x2F;&#x2F; 使用迭代器遍历事件Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();while (iterator.hasNext()) &#123;SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 判断key的类型，此处为Accept类型if(key.isAcceptable()) &#123;        &#x2F;&#x2F; 获得key对应的channel        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();        &#x2F;&#x2F; 获取连接并处理，而且是必须处理，否则需要取消，不然程序会空转        SocketChannel socketChannel &#x3D; channel.accept();        &#x2F;&#x2F; 处理完毕后移除        iterator.remove();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事件发生后能否不处理</strong></p><p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p><h2 id="5、处理Read事件"><a href="#5、处理Read事件" class="headerlink" title="5、处理Read事件"></a>5、处理Read事件</h2><ul><li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li><li>添加Read事件，触发后进行读取操作</li></ul><p>这里代码可以去掉iterator.remove();再跑，看一看会出现什么错误，并试着分析一下为什么会出现这个情况</p><pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;    public static void main(String[] args) &#123;        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 创建选择器            Selector selector &#x3D; Selector.open();            &#x2F;&#x2F; 通道必须设置为非阻塞模式            server.configureBlocking(false);            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的实践            server.register(selector, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 为serverKey设置感兴趣的事件            while (true) &#123;                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转                &#x2F;&#x2F; 返回值为就绪的事件个数                int ready &#x3D; selector.select();                System.out.println(&quot;selector ready counts : &quot; + ready);                &#x2F;&#x2F; 获取所有事件                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                &#x2F;&#x2F; 使用迭代器遍历事件                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 判断key的类型                    if(key.isAcceptable()) &#123;                        &#x2F;&#x2F; 获得key对应的channel                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();                        System.out.println(&quot;before accepting...&quot;);                        &#x2F;&#x2F; 获取连接                        SocketChannel socketChannel &#x3D; channel.accept();                        System.out.println(&quot;after accepting...&quot;);                        &#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中                        socketChannel.configureBlocking(false);                        socketChannel.register(selector, SelectionKey.OP_READ);                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125; else if (key.isReadable()) &#123;                        SocketChannel channel &#x3D; (SocketChannel) key.channel();                        System.out.println(&quot;before reading...&quot;);                        channel.read(buffer);                        System.out.println(&quot;after reading...&quot;);                        buffer.flip();                        ByteBufferUtil.debugRead(buffer);                        buffer.clear();                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除事件</strong></p><p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p><p>以我们上面的 <strong>Read事件</strong> 的代码为例</p><ul><li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道Channel</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; WindowsSelectorImpl 中的 SelectionKeyImpl数组private SelectionKeyImpl[] channelArray &#x3D; new SelectionKeyImpl[8];Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class SelectionKeyImpl extends AbstractSelectionKey &#123;    &#x2F;&#x2F; Key对应的通道    final SelChImpl channel;    ...&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png" alt="img"></a></p></li><li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png" alt="img"></a></p></li></ul><h3 id="断开处理"><a href="#断开处理" class="headerlink" title="断开处理"></a>断开处理</h3><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>（及程序会进入到下面的事件判断），对异常断开和正常断开需要加</p><p>以不同的方式进行处理</p><ul><li><p><strong>正常断开</strong></p><ul><li><p>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，此时表示客户端那边断开了（正常断开或者非正常断开），<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong>。</p><pre class="line-numbers language-none"><code class="language-none">int read &#x3D; channel.read(buffer);&#x2F;&#x2F; 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1if(read &#x3D;&#x3D; -1) &#123;    &#x2F;&#x2F; 取消该事件的处理key.cancel();    channel.close();&#125; else &#123;    ...&#125;&#x2F;&#x2F; 取消或者处理，都需要移除keyiterator.remove();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>异常断开</p><ul><li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li></ul></li></ul><h3 id="消息边界-重点"><a href="#消息边界-重点" class="headerlink" title="消息边界(重点)"></a>消息边界(重点)</h3><p><strong>不处理消息边界存在的问题</strong></p><p>将缓冲区的大小设置为4个字节，发送2个汉字（你好），通过decode解码并打印时，会出现乱码</p><pre class="line-numbers language-none"><code class="language-none">ByteBuffer buffer &#x3D; ByteBuffer.allocate(4);&#x2F;&#x2F; 解码并打印System.out.println(StandardCharsets.UTF_8.decode(buffer));你���<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为UTF-8字符集下，1个汉字占用3个字节，此时缓冲区大小为4个字节，<strong>一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件</strong>。这就导致 <code>你好</code> 的 <code>好</code> 字被拆分为了前半部分和后半部分发送，解码时就会出现问题</p><p><strong>处理消息边界</strong></p><p>传输的文本可能有以下三种情况</p><ul><li>文本大于缓冲区大小<ul><li>此时需要将缓冲区进行扩容</li></ul></li><li>发生半包现象</li><li>发生粘包现象</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png" alt="img"></a></p><p>解决思路大致有以下三种</p><ul><li><p><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p></li><li><p>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</p></li><li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据（也就是在消息开头用一些空间存放后面数据的长度），如HTTP请求头中的</p><p>Content-Type与Content-Length。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提</p><p>前分配，如果内容过大，则影响 server 吞吐量</p><ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png" alt="img"></a></li></ul></li></ul><p>下文的消息边界处理方式为<strong>第二种：按分隔符拆分</strong></p><p><strong>附件与扩容</strong></p><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p><pre class="line-numbers language-none"><code class="language-none">public final SelectionKey register(Selector sel, int ops, Object att)Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p><pre class="line-numbers language-none"><code class="language-none">ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件socketChannel.configureBlocking(false);ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);&#x2F;&#x2F; 添加通道对应的Buffer附件socketChannel.register(selector, SelectionKey.OP_READ, buffer);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 如果缓冲区太小，就进行扩容if (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;    ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity()*2);    &#x2F;&#x2F; 将旧buffer中的内容放入新的buffer中    ewBuffer.put(buffer);    &#x2F;&#x2F; 将新buffer作为附件放到key中    key.attach(newBuffer);&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>改造后的服务器代码如下</strong></p><pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 获得服务器通道        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 创建选择器            Selector selector &#x3D; Selector.open();            &#x2F;&#x2F; 通道必须设置为非阻塞模式            server.configureBlocking(false);            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的事件            server.register(selector, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 为serverKey设置感兴趣的事件            while (true) &#123;                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转                &#x2F;&#x2F; 返回值为就绪的事件个数                int ready &#x3D; selector.select();                System.out.println(&quot;selector ready counts : &quot; + ready);                &#x2F;&#x2F; 获取所有事件                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                &#x2F;&#x2F; 使用迭代器遍历事件                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 判断key的类型                    if(key.isAcceptable()) &#123;                        &#x2F;&#x2F; 获得key对应的channel                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();                        System.out.println(&quot;before accepting...&quot;);                        &#x2F;&#x2F; 获取连接                        SocketChannel socketChannel &#x3D; channel.accept();                        System.out.println(&quot;after accepting...&quot;);                        &#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件                        socketChannel.configureBlocking(false);                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);                        socketChannel.register(selector, SelectionKey.OP_READ, buffer);                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125; else if (key.isReadable()) &#123;                        SocketChannel channel &#x3D; (SocketChannel) key.channel();                        System.out.println(&quot;before reading...&quot;);                        &#x2F;&#x2F; 通过key获得附件（buffer）                        ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();                        int read &#x3D; channel.read(buffer);                        if(read &#x3D;&#x3D; -1) &#123;                            key.cancel();                            channel.close();                        &#125; else &#123;                            &#x2F;&#x2F; 通过分隔符来分隔buffer中的数据                            split(buffer);                            &#x2F;&#x2F; 如果缓冲区太小，就进行扩容，表示缓冲区中没有读到换行符，compact方法的position &#x3D;&#x3D; limit                            if (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;                                ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity()*2);                                &#x2F;&#x2F; 将旧buffer中的内容放入新的buffer中                                buffer.flip();                                newBuffer.put(buffer);                                &#x2F;&#x2F; 将新buffer放到key中作为附件                                key.attach(newBuffer);                            &#125;                        &#125;                        System.out.println(&quot;after reading...&quot;);                        &#x2F;&#x2F; 处理完毕后移除                        iterator.remove();                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    private static void split(ByteBuffer buffer) &#123;        buffer.flip();        for(int i &#x3D; 0; i &lt; buffer.limit(); i++) &#123;            &#x2F;&#x2F; 遍历寻找分隔符            &#x2F;&#x2F; get(i)不会移动position            if (buffer.get(i) &#x3D;&#x3D; &#39;\n&#39;) &#123;                &#x2F;&#x2F; 缓冲区长度                int length &#x3D; i+1-buffer.position();                ByteBuffer target &#x3D; ByteBuffer.allocate(length);                &#x2F;&#x2F; 将前面的内容写入target缓冲区                for(int j &#x3D; 0; j &lt; length; j++) &#123;                    &#x2F;&#x2F; 将buffer中的数据写入target中                    target.put(buffer.get());                &#125;                &#x2F;&#x2F; 打印结果                ByteBufferUtil.debugAll(target);            &#125;        &#125;        &#x2F;&#x2F; 切换为写模式，但是缓冲区可能未读完，这里需要使用compact        buffer.compact();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ByteBuffer的大小分配"><a href="#ByteBuffer的大小分配" class="headerlink" title="ByteBuffer的大小分配"></a>ByteBuffer的大小分配</h3><ul><li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li><li>分配思路可以参考<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul><li>参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li></ul></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h2 id="6、处理Write事件"><a href="#6、处理Write事件" class="headerlink" title="6、处理Write事件"></a>6、处理Write事件</h2><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到</strong></p><p><strong>Channel中，这时便需要分多次写入</strong>，具体步骤如下</p><ul><li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p></li><li><p>若Buffer中还有数据，则<strong>需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></p><pre class="line-numbers language-none"><code class="language-none"> int write &#x3D; socket.write(buffer);&#x2F;&#x2F; 通道中可能无法放入缓冲区中的所有数据if (buffer.hasRemaining()) &#123;    &#x2F;&#x2F; 注册到Selector中，关注可写事件，并将buffer添加到key的附件中    socket.configureBlocking(false);    socket.register(selector, SelectionKey.OP_WRITE, buffer);&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作</p><ul><li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">SocketChannel socket &#x3D; (SocketChannel) key.channel();&#x2F;&#x2F; 获得bufferByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();&#x2F;&#x2F; 执行写操作int write &#x3D; socket.write(buffer);System.out.println(write);&#x2F;&#x2F; 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣if (!buffer.hasRemaining()) &#123;    key.attach(null);    key.interestOps(0);&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>整体代码如下</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">ServerSocketChannel</span> server <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            server<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 处理后就移除事件</span>                    iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 获得客户端的通道</span>                        <span class="token class-name">SocketChannel</span> socket <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 写入数据</span>                        <span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 先执行一次Buffer->Channel的写入，如果未写完，就添加一个可写事件</span>                        <span class="token keyword">int</span> write <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>write<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 通道中可能无法放入缓冲区中的所有数据</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span>                            socket<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            socket<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">SocketChannel</span> socket <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 获得buffer</span>                        <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 执行写操作</span>                        <span class="token keyword">int</span> write <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>write<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            key<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteClient</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> <span class="token class-name">SocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketChannel<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">+=</span>socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、优化"><a href="#7、优化" class="headerlink" title="7、优化"></a>7、优化</h2><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>充分利用多核CPU，分两组选择器</p><ul><li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li><li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p></li><li><p><strong>Boss线程</strong>执行的操作</p><ul><li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建固定数量的WorkerWorker[] workers &#x3D; new Worker[4];&#x2F;&#x2F; 用于负载均衡的原子整数AtomicInteger robin &#x3D; new AtomicInteger(0);&#x2F;&#x2F; 负载均衡，轮询分配Workerworkers[robin.getAndIncrement()% workers.length].register(socket);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p><pre class="line-numbers language-none"><code class="language-none">public void register(final SocketChannel socket) throws IOException &#123;    &#x2F;&#x2F; 只启动一次    if (!started) &#123;       &#x2F;&#x2F; 初始化操作    &#125;    &#x2F;&#x2F; 向同步队列中添加SocketChannel的注册事件    &#x2F;&#x2F; 在Worker线程中执行注册事件    queue.add(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                socket.register(selector, SelectionKey.OP_READ);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;);    &#x2F;&#x2F; 唤醒被阻塞的Selector    &#x2F;&#x2F; select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark    selector.wakeup();&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>Worker线程执行</strong>的操作</p><ul><li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li></ul></li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre class="line-numbers language-none"><code class="language-none">public class ThreadsServer &#123;    public static void main(String[] args) &#123;        try (ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;            &#x2F;&#x2F; 当前线程为Boss线程            Thread.currentThread().setName(&quot;Boss&quot;);            server.bind(new InetSocketAddress(8080));            &#x2F;&#x2F; 负责轮询Accept事件的Selector            Selector boss &#x3D; Selector.open();            server.configureBlocking(false);            server.register(boss, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 创建固定数量的Worker            Worker[] workers &#x3D; new Worker[4];            &#x2F;&#x2F; 用于负载均衡的原子整数            AtomicInteger robin &#x3D; new AtomicInteger(0);            for(int i &#x3D; 0; i &lt; workers.length; i++) &#123;                workers[i] &#x3D; new Worker(&quot;worker-&quot;+i);            &#125;            while (true) &#123;                boss.select();                Set&lt;SelectionKey&gt; selectionKeys &#x3D; boss.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    iterator.remove();                    &#x2F;&#x2F; BossSelector负责Accept事件                    if (key.isAcceptable()) &#123;                        &#x2F;&#x2F; 建立连接                        SocketChannel socket &#x3D; server.accept();                        System.out.println(&quot;connected...&quot;);                        socket.configureBlocking(false);                        &#x2F;&#x2F; socket注册到Worker的Selector中                        System.out.println(&quot;before read...&quot;);                        &#x2F;&#x2F; 负载均衡，轮询分配Worker                        workers[robin.getAndIncrement()% workers.length].register(socket);                        System.out.println(&quot;after read...&quot;);                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    static class Worker implements Runnable &#123;        private Thread thread;        private volatile Selector selector;        private String name;        private volatile boolean started &#x3D; false;        &#x2F;**         * 同步队列，用于Boss线程与Worker线程之间的通信         *&#x2F;        private ConcurrentLinkedQueue&lt;Runnable&gt; queue;        public Worker(String name) &#123;            this.name &#x3D; name;        &#125;        public void register(final SocketChannel socket) throws IOException &#123;            &#x2F;&#x2F; 只启动一次            if (!started) &#123;                thread &#x3D; new Thread(this, name);                selector &#x3D; Selector.open();                queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();                thread.start();                started &#x3D; true;            &#125;                        &#x2F;&#x2F; 向同步队列中添加SocketChannel的注册事件            &#x2F;&#x2F; 在Worker线程中执行注册事件            queue.add(new Runnable() &#123;                @Override                public void run() &#123;                    try &#123;                        socket.register(selector, SelectionKey.OP_READ);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);            &#x2F;&#x2F; 唤醒被阻塞的Selector            &#x2F;&#x2F; select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark            selector.wakeup();        &#125;        @Override        public void run() &#123;            while (true) &#123;                try &#123;                    selector.select();                    &#x2F;&#x2F; 通过同步队列获得任务并运行                    Runnable task &#x3D; queue.poll();                    if (task !&#x3D; null) &#123;                        &#x2F;&#x2F; 获得任务，执行注册操作                        task.run();                    &#125;                    Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();                    Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();                    while(iterator.hasNext()) &#123;                        SelectionKey key &#x3D; iterator.next();                        iterator.remove();                        &#x2F;&#x2F; Worker只负责Read事件                        if (key.isReadable()) &#123;                            &#x2F;&#x2F; 简化处理，省略细节                            SocketChannel socket &#x3D; (SocketChannel) key.channel();                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);                            socket.read(buffer);                            buffer.flip();                            ByteBufferUtil.debugAll(buffer);                        &#125;                    &#125;                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、NIO与BIO"><a href="#四、NIO与BIO" class="headerlink" title="四、NIO与BIO"></a>四、NIO与BIO</h1><h2 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a>1、Stream与Channel</h2><ul><li><p>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</p></li><li><p>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></p></li><li><p>二者</p><p>均为全双工</p><p>，即读写可以同时进行</p><ul><li>虽然Stream是单向流动的，但是它也是全双工的</li></ul></li></ul><h2 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h2><ul><li><p>同步</p><p>：线程自己去获取结果（一个线程）</p><ul><li>例如：线程调用一个方法后，需要等待方法返回结果</li></ul></li><li><p>异步</p><p>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p><ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别</p><p>为：</p><ul><li><p>等待数据阶段</p></li><li><p>复制数据阶段</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png" alt="img"></a></p></li></ul><p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png" alt="img"></a></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png" alt="img"></a></p><ul><li><p>用户线程</p><p>在一个循环中一直调用read方法</p><p>，若内核空间中还没有数据可读，立即返回</p><ul><li><strong>只是在等待阶段非阻塞</strong></li></ul></li><li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p></li></ul><h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png" alt="img"></a></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件是，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li><li>及阻塞IO是代码驱动，多路复用是事件驱动</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png" alt="img"></a></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h2 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h3><p>传统的 IO 将一个文件通过 socket 写出</p><pre class="line-numbers language-none"><code class="language-none">File f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);RandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);byte[] buf &#x3D; new byte[(int)f.length()];file.read(buf);Socket socket &#x3D; ...;socket.getOutputStream().write(buf);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内部工作流如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png" alt="img"></a></p><ul><li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p></li><li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h3><p>通过 <strong>DirectByteBuf</strong></p><ul><li><p>ByteBuffer.allocate(10)</p><ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li><p>ByteBuffer.</p><p>allocateDirect</p><p>(10)</p><ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png" alt="img"></a></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a>进一步优化1</h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo/transferFrom</strong> 方法拷贝数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><h2 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a>4、AIO</h2><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/2021/11/29/netty/"/>
      <url>/2021/11/29/netty/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>本文转载自：<a href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#Netty">Netty</a></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><pre class="line-numbers language-none"><code class="language-none">Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如</p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><pre class="line-numbers language-none"><code class="language-none">public class HelloServer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器        new ServerBootstrap()                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector                .group(new NioEventLoopGroup())                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现                .channel(NioServerSocketChannel.class)                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作            &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）            &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                    @Override                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String                        nioSocketChannel.pipeline().addLast(new StringDecoder());                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;                            @Override                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;                                System.out.println(s);                            &#125;                        &#125;);                    &#125;                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口                &#125;).bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><pre class="line-numbers language-none"><code class="language-none">public class HelloClient &#123;    public static void main(String[] args) throws InterruptedException &#123;        new Bootstrap()                .group(new NioEventLoopGroup())                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现                .channel(NioSocketChannel.class)                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;                    @Override                    protected void initChannel(Channel channel) throws Exception &#123;                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出                        channel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                &#x2F;&#x2F; 指定要连接的服务器和端口                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕                .sync()                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作                .channel()                &#x2F;&#x2F; 写入消息并清空缓冲区                .writeAndFlush(&quot;hello world&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png" alt="img"></a></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li><p>channel 可以理解为数据的通道</p></li><li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p></li><li><p>handler 可以理解为数据的处理工序</p><ul><li><p>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p><ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li><p>handler 分 Inbound 和 Outbound 两类</p><ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li><p>eventLoop 可以理解为处理数据的工人</p><ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><pre class="line-numbers language-none"><code class="language-none">public class TestEventLoop &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop        System.out.println(group.next());        System.out.println(group.next());        &#x2F;&#x2F; 通过EventLoop执行普通任务        group.next().execute(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);        &#125;);        &#x2F;&#x2F; 通过EventLoop执行定时任务        group.next().scheduleAtFixedRate(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);        &#125;, 0, 1, TimeUnit.SECONDS);                &#x2F;&#x2F; 优雅地关闭        group.shutdownGracefully();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下</p><pre class="line-numbers language-none"><code class="language-none">io.netty.channel.nio.NioEventLoop@7bb11784io.netty.channel.nio.NioEventLoop@33a10788nioEventLoopGroup-2-1 hellonioEventLoopGroup-2-2 hello2nioEventLoopGroup-2-2 hello2nioEventLoopGroup-2-2 hello2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopServer &#123;    public static void main(String[] args) &#123;        new ServerBootstrap()                .group(new NioEventLoopGroup())                .channel(NioServerSocketChannel.class)                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                ByteBuf buf &#x3D; (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopClient &#123;    public static void main(String[] args) throws IOException, InterruptedException &#123;        Channel channel &#x3D; new Bootstrap()                .group(new NioEventLoopGroup())                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))                .sync()                .channel();        System.out.println(channel);        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);        System.in.read();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;    public static void main(String[] args) &#123;        new ServerBootstrap()            &#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))            ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个客户端分别发送 <code>hello</code> 结果</p><pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-3-1 hello1nioEventLoopGroup-3-2 hello2nioEventLoopGroup-3-1 hello3nioEventLoopGroup-3-2 hello4nioEventLoopGroup-3-2 hello4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件，并且根据轮询的形式保证每个EventLoop都有对应的Channel</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png" alt="img"></a></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();                new ServerBootstrap()                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))                .channel(NioServerSocketChannel.class)                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                ByteBuf buf &#x3D; (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));                                &#x2F;&#x2F; 调用下一个handler                                ctx.fireChannelRead(msg);                            &#125;                        &#125;)                        &#x2F;&#x2F; 该handler绑定自定义的Group                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                ByteBuf buf &#x3D; (ByteBuf) msg;                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动四个客户端发送数据</p><pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-4-1 hello1defaultEventLoopGroup-2-1 hello1nioEventLoopGroup-4-2 hello2defaultEventLoopGroup-2-2 hello2nioEventLoopGroup-4-1 hello3defaultEventLoopGroup-2-3 hello3nioEventLoopGroup-4-2 hello4defaultEventLoopGroup-2-4 hello4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png" alt="img"></a></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><pre class="line-numbers language-none"><code class="language-none">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup    EventExecutor executor &#x3D; next.executor();        &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中    if (executor.inEventLoop()) &#123;        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务        next.invokeChannelRead(m);    &#125; else &#123;        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行        executor.execute(new Runnable() &#123;            public void run() &#123;                next.invokeChannelRead(m);            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class MyClient &#123;    public static void main(String[] args) throws IOException, InterruptedException &#123;        ChannelFuture channelFuture &#x3D; new Bootstrap()                .group(new NioEventLoopGroup())                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程            &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));                &#x2F;&#x2F; 阻塞住，该方法用于等待连接真正建立        &#x2F;&#x2F;不使用该方法会使当前线程继续向下执行，但是因为链接还未建立，导致下面的channel还没有链接，channel对象存在          channelFuture.sync();                &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象        Channel channel &#x3D; channelFuture.channel();        channel.writeAndFlush(&quot;hello world&quot;);        System.in.read();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><pre class="line-numbers language-none"><code class="language-none">public class MyClient &#123;    public static void main(String[] args) throws IOException, InterruptedException &#123;        ChannelFuture channelFuture &#x3D; new Bootstrap()                .group(new NioEventLoopGroup())                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        &#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法        channelFuture.addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;                Channel channel &#x3D; channelFuture.channel();                channel.writeAndFlush(&quot;hello world&quot;);            &#125;        &#125;);        System.in.read();    &#125;&#125;Cop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class ReadClient &#123;    public static void main(String[] args) throws InterruptedException &#123;        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();                ChannelFuture channelFuture &#x3D; new Bootstrap()                .group(group)                .channel(NioSocketChannel.class)                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        socketChannel.pipeline().addLast(new StringEncoder());                    &#125;                &#125;)                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        channelFuture.sync();        Channel channel &#x3D; channelFuture.channel();        Scanner scanner &#x3D; new Scanner(System.in);        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送        new Thread(()-&gt;&#123;            while (true) &#123;                String msg &#x3D; scanner.next();                if (&quot;q&quot;.equals(msg)) &#123;                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行                    channel.close();                    break;                &#125;                channel.writeAndFlush(msg);            &#125;        &#125;, &quot;inputThread&quot;).start();        &#x2F;&#x2F; 获得closeFuture对象        ChannelFuture closeFuture &#x3D; channel.closeFuture();        System.out.println(&quot;waiting close...&quot;);                &#x2F;&#x2F; 同步等待NIO线程执行完close操作        &#x2F;&#x2F;sync()阻塞方法        closeFuture.sync();                &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);                &#x2F;&#x2F; 关闭EventLoopGroup        group.shutdownGracefully();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得closeFuture对象ChannelFuture closeFuture &#x3D; channel.closeFuture();&#x2F;&#x2F; 同步等待NIO线程执行完close操作closeFuture.sync();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><pre class="line-numbers language-none"><code class="language-none">closeFuture.addListener(new ChannelFutureListener() &#123;    @Override    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;        &#x2F;&#x2F; 等待channel关闭后才执行的操作        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);        &#x2F;&#x2F; 关闭EventLoopGroup        group.shutdownGracefully();    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>由此可以发现，netty中很多方法都是异步的，针对某些后续操作，不能想当然的在异步方法之后加一些内容，为了保证代码的正确执行，必须保证同步处理或者异步处理。</p><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><pre class="line-numbers language-none"><code class="language-none">public class JdkFuture &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        ThreadFactory factory &#x3D; new ThreadFactory() &#123;            @Override            public Thread newThread(Runnable r) &#123;                return new Thread(r, &quot;JdkFuture&quot;);            &#125;        &#125;;        &#x2F;&#x2F; 创建线程池        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);        &#x2F;&#x2F; 获得Future对象        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;            @Override            public Integer call() throws Exception &#123;                TimeUnit.SECONDS.sleep(1);                return 50;            &#125;        &#125;);        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果        System.out.println(future.get());    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><pre class="line-numbers language-none"><code class="language-none">public class NettyFuture &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        &#x2F;&#x2F; 获得 EventLoop 对象        EventLoop eventLoop &#x3D; group.next();        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;            @Override            public Integer call() throws Exception &#123;                return 50;            &#125;        &#125;);        &#x2F;&#x2F; 主线程中获取结果        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);        System.out.println(&quot;getNow &quot; + future.getNow());        System.out.println(&quot;get &quot; + future.get());        &#x2F;&#x2F; NIO线程中异步获取结果        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;            @Override            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);                System.out.println(&quot;getNow &quot; + future.getNow());            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">main 获取结果getNow nullget 50nioEventLoopGroup-2-1 获取结果getNow 50  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><pre class="line-numbers language-none"><code class="language-none">public class NettyPromise &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        &#x2F;&#x2F; 创建EventLoop        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        EventLoop eventLoop &#x3D; group.next();        &#x2F;&#x2F; 创建Promise对象，用于存放结果        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);        new Thread(()-&gt;&#123;            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            &#x2F;&#x2F; 自定义线程向Promise中存放结果            promise.setSuccess(50);        &#125;).start();        &#x2F;&#x2F; 主线程从Promise中获取结果        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><pre class="line-numbers language-none"><code class="language-none">public class PipeLineServer &#123;    public static void main(String[] args) &#123;        new ServerBootstrap()                .group(new NioEventLoopGroup())                .channel(NioServerSocketChannel.class)                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为     &#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法                        &#x2F;&#x2F; 入站时，handler是从head向后调用的                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead                                &#x2F;&#x2F; 将数据传递给下一个handler                                super.channelRead(ctx, msg);                            &#125;                        &#125;);                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;                            @Override                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));                                super.channelRead(ctx, msg);                            &#125;                        &#125;);                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;                            @Override                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);                                super.write(ctx, msg, promise);                            &#125;                        &#125;);                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;                            @Override                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);                                super.write(ctx, msg, promise);                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(8080);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果如下</strong></p><pre class="line-numbers language-none"><code class="language-none">nioEventLoopGroup-2-2 Inbound handler 1nioEventLoopGroup-2-2 Inbound handler 2nioEventLoopGroup-2-2 Outbound handler 2nioEventLoopGroup-2-2 Outbound handler 1  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png" alt="img"></a></p><p><strong>调用顺序如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png" alt="img"></a></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" alt="img"></a></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" alt="img"></a></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><pre class="line-numbers language-none"><code class="language-none">public class TestEmbeddedChannel &#123;    public static void main(String[] args) &#123;        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;            @Override            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                System.out.println(&quot;1&quot;);                super.channelRead(ctx, msg);            &#125;        &#125;;        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;            @Override            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                System.out.println(&quot;2&quot;);                super.channelRead(ctx, msg);            &#125;        &#125;;        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;            @Override            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                System.out.println(&quot;3&quot;);                super.write(ctx, msg, promise);            &#125;        &#125;;        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;            @Override            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;                System.out.println(&quot;4&quot;);                super.write(ctx, msg, promise);            &#125;        &#125;;        &#x2F;&#x2F; 用于测试Handler的Channel        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);                &#x2F;&#x2F; 执行Inbound操作         channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));        &#x2F;&#x2F; 执行Outbound操作        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void log(ByteBuf buffer) &#123;    int length &#x3D; buffer.readableBytes();    int rows &#x3D; length &#x2F; 16 + (length % 15 &#x3D;&#x3D; 0 ? 0 : 1) + 4;    StringBuilder buf &#x3D; new StringBuilder(rows * 80 * 2)        .append(&quot;read index:&quot;).append(buffer.readerIndex())        .append(&quot; write index:&quot;).append(buffer.writerIndex())        .append(&quot; capacity:&quot;).append(buffer.capacity())        .append(NEWLINE);    appendPrettyHexDump(buf, buffer);    System.out.println(buf.toString());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 向buffer中写入数据        StringBuilder sb &#x3D; new StringBuilder();        for(int i &#x3D; 0; i &lt; 20; i++) &#123;            sb.append(&quot;a&quot;);        &#125;        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));        &#x2F;&#x2F; 查看写入结果        ByteBufUtil.log(buffer);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">read index:0 write index:0 capacity:16read index:0 write index:20 capacity:64         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa||00000010| 61 61 61 61                                     |aaaa            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><pre class="line-numbers language-none"><code class="language-none">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);        System.out.println(buffer.getClass());        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);        System.out.println(buffer.getClass());        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);        System.out.println(buffer.getClass());    &#125;&#125;&#x2F;&#x2F; 使用池化的直接内存class io.netty.buffer.PooledUnsafeDirectByteBuf    &#x2F;&#x2F; 使用池化的堆内存    class io.netty.buffer.PooledUnsafeHeapByteBuf    &#x2F;&#x2F; 使用池化的直接内存    class io.netty.buffer.PooledUnsafeDirectByteBuf  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可<strong>以通过下面的系统环境变量来设置，也可以作为虚拟机参数传入</strong>。</p><pre class="line-numbers language-none"><code class="language-none">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png" alt="img"></a></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类（如Stringbuilder）的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 向buffer中写入数据        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);        ByteBufUtil.log(buffer);        buffer.writeInt(5);        ByteBufUtil.log(buffer);        buffer.writeIntLE(6);        ByteBufUtil.log(buffer);        buffer.writeLong(7);        ByteBufUtil.log(buffer);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">read index:0 write index:0 capacity:16read index:0 write index:4 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04                                     |....            |+--------+-------------------------------------------------+----------------+read index:0 write index:8 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05                         |........        |+--------+-------------------------------------------------+----------------+read index:0 write index:12 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |+--------+-------------------------------------------------+----------------+read index:0 write index:20 capacity:20         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................||00000010| 00 00 00 07                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><pre class="line-numbers language-none"><code class="language-none">buffer.writeLong(7);ByteBufUtil.log(buffer);  &#x2F;&#x2F; 扩容前read index:0 write index:12 capacity:16...&#x2F;&#x2F; 扩容后read index:0 write index:20 capacity:20         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................||00000010| 00 00 00 07                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p><ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p><p>n</p><ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li></ul></li><li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p></li></ul><pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><pre class="line-numbers language-none"><code class="language-none">public class ByteBufStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);        &#x2F;&#x2F; 向buffer中写入数据        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);        buffer.writeInt(5);        &#x2F;&#x2F; 读取4个字节        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        System.out.println(buffer.readByte());        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 通过mark与reset实现重复读取        buffer.markReaderIndex();        System.out.println(buffer.readInt());        ByteBufUtil.log(buffer);        &#x2F;&#x2F; 恢复到mark标记处        buffer.resetReaderIndex();        ByteBufUtil.log(buffer);    &#125;&#125;1234read index:4 write index:8 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 00 00 05                                     |....            |+--------+-------------------------------------------------+----------------+5read index:8 write index:8 capacity:16read index:4 write index:8 capacity:16         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 00 00 05                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收，放在其他人误调用release 把计数值减为0</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><pre class="line-numbers language-none"><code class="language-none">while (!buffer.release()) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><pre class="line-numbers language-none"><code class="language-none">protected void onUnhandledInboundMessage(Object msg) &#123;    try &#123;        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);    &#125; finally &#123;        &#x2F;&#x2F; 具体的释放方法        ReferenceCountUtil.release(msg);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><pre class="line-numbers language-none"><code class="language-none">public static boolean release(Object msg) &#123;return msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>HeadContext</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HeadContext</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractChannelHandlerContext</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelOutboundHandler</span><span class="token punctuation">,</span> <span class="token class-name">ChannelInboundHandler</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看见出HeadContext实现了ChannelOutboundHandler, ChannelInboundHandler接口，表示可以作为出站和入站。及从Head进Tail出，或者从Head进Head出</p><p><img src="D:\Programs\InterviewNotes\image-20211007194810701.png" alt="image-20211007194810701"></p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png" alt="img"></a></p><pre class="line-numbers language-none"><code class="language-none">public class TestSlice &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建ByteBuf        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);        &#x2F;&#x2F; 向buffer中写入数据        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);        &#x2F;&#x2F; 将buffer分成两部分        ByteBuf slice1 &#x3D; buffer.slice(0, 5);        ByteBuf slice2 &#x3D; buffer.slice(5, 5);        &#x2F;&#x2F; 需要让分片的buffer引用计数加一        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用        slice1.retain();        slice2.retain();                ByteBufUtil.log(slice1);        ByteBufUtil.log(slice2);        &#x2F;&#x2F; 更改原始buffer中的值        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        buffer.setByte(0,5);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        ByteBufUtil.log(slice1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">read index:0 write index:5 capacity:5         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 01 02 03 04 05                                  |.....           |+--------+-------------------------------------------------+----------------+read index:0 write index:5 capacity:5         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 06 07 08 09 0a                                  |.....           |+--------+-------------------------------------------------+----------------+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;read index:0 write index:5 capacity:5         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 05 02 03 04 05                                  |.....           |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><pre class="line-numbers language-none"><code class="language-none">public class StudyServer &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);    void start() &#123;        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        try &#123;            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.group(boss, worker);            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) &#123;                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                        @Override                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;                            &#x2F;&#x2F; 连接建立时会执行该方法，触发active事件                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());                            super.channelActive(ctx);                        &#125;                        @Override                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;                            &#x2F;&#x2F; 连接断开时会执行该方法                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());                            super.channelInactive(ctx);                        &#125;                    &#125;);                &#125;            &#125;);            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());            channelFuture.sync();            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());            &#x2F;&#x2F; 关闭channel            channelFuture.channel().closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            log.error(&quot;server error&quot;, e);        &#125; finally &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();            log.debug(&quot;stopped&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        new StudyServer().start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class StudyClient &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(StudyClient.class);    public static void main(String[] args) &#123;        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        try &#123;            Bootstrap bootstrap &#x3D; new Bootstrap();            bootstrap.channel(NioSocketChannel.class);            bootstrap.group(worker);            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    log.debug(&quot;connected...&quot;);                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                        @Override                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;                            log.debug(&quot;sending...&quot;);                            &#x2F;&#x2F; 每次发送16个字节的数据，共发送10次                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                                ByteBuf buffer &#x3D; ctx.alloc().buffer();                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);                                ctx.writeAndFlush(buffer);                            &#125;                        &#125;                    &#125;);                &#125;            &#125;);            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();            channelFuture.channel().closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            log.error(&quot;client error&quot;, e);        &#125; finally &#123;            worker.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器接收结果</strong></p><pre class="line-numbers language-none"><code class="language-none">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:53797] READ: 160B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调整channel的容量serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><pre class="line-numbers language-none"><code class="language-none">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 36B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................||00000020| 00 01 02 03                                     |....            |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000020| 04 05 06 07 08 09 0a 0b                         |........        |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................||00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................||00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................||00000020| 04 05 06 07 08 09 0a 0b                         |........        |+--------+-------------------------------------------------+----------------+5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 4B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 0c 0d 0e 0f                                     |....            |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><pre class="line-numbers language-none"><code class="language-none">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;    log.debug(&quot;sending...&quot;);    ByteBuf buffer &#x3D; ctx.alloc().buffer(16);    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);    ctx.writeAndFlush(buffer);    &#x2F;&#x2F; 使用短链接，每次发送完毕后就断开连接    ctx.channel().close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    &#x2F;&#x2F; 发送10次    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        send();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] ACTIVE6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|+--------+-------------------------------------------------+----------------+6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65024] INACTIVE6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] ACTIVE6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|+--------+-------------------------------------------------+----------------+6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65057] INACTIVE...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><pre class="line-numbers language-none"><code class="language-none">ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 约定最大长度为16final int maxLength &#x3D; 16;&#x2F;&#x2F; 被发送的数据char c &#x3D; &#39;a&#39;;&#x2F;&#x2F; 向服务器发送10个报文for (int i &#x3D; 0; i &lt; 10; i++) &#123;    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);    &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充    byte[] bytes &#x3D; new byte[maxLength];    &#x2F;&#x2F; 生成长度为0~15的数据    for (int j &#x3D; 0; j &lt; (int)(Math.random()*(maxLength-1)); j++) &#123;        bytes[j] &#x3D; (byte) c;    &#125;    buffer.writeBytes(bytes);    c++;    &#x2F;&#x2F; 将数据发送给服务器    ctx.writeAndFlush(buffer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过定长解码器对粘包数据进行拆分ch.pipeline().addLast(new FixedLengthFrameDecoder(16));ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|+--------+-------------------------------------------------+----------------+8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|+--------+-------------------------------------------------+----------------+8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|+--------+-------------------------------------------------+----------------+...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 约定最大长度为 64final int maxLength &#x3D; 64;&#x2F;&#x2F; 被发送的数据char c &#x3D; &#39;a&#39;;for (int i &#x3D; 0; i &lt; 10; i++) &#123;    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);    &#x2F;&#x2F; 生成长度为0~62的数据    Random random &#x3D; new Random();    StringBuilder sb &#x3D; new StringBuilder();    for (int j &#x3D; 0; j &lt; (int)(random.nextInt(maxLength-2)); j++) &#123;        sb.append(c);    &#125;    &#x2F;&#x2F; 数据以 \n 结尾    sb.append(&quot;\n&quot;);    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));    c++;    &#x2F;&#x2F; 将数据发送给服务器    ctx.writeAndFlush(buffer);&#125;或者    public static StringBuilder makeString(char c, int len) &#123;        StringBuilder sb &#x3D; new StringBuilder(len + 2);        for (int i &#x3D; 0; i &lt; len; i++) &#123;            sb.append(c);        &#125;        sb.append(&quot;\n&quot;);        return sb;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \n 为分隔符&#x2F;&#x2F; 需要指定最大长度ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 10B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |+--------+-------------------------------------------------+----------------+4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 11B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |+--------+-------------------------------------------------+----------------+4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 2B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 63 63                                           |cc              |+--------+-------------------------------------------------+----------------+...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><pre class="line-numbers language-none"><code class="language-none">...    &#x2F;&#x2F; 数据以 \c 结尾sb.append(&quot;\\c&quot;);buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将分隔符放入ByteBuf中ByteBuf bufSet &#x3D; ch.alloc().buffer().writeBytes(&quot;\\c&quot;.getBytes(StandardCharsets.UTF_8));&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \c 为分隔符ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 14B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |+--------+-------------------------------------------------+----------------+8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 3B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 62 62 62                                        |bbb             |+--------+-------------------------------------------------+----------------+...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><pre class="line-numbers language-none"><code class="language-none">public LengthFieldBasedFrameDecoder(    int maxFrameLength,    int lengthFieldOffset, int lengthFieldLength,    int lengthAdjustment, int initialBytesToStrip)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png" alt="img"></a></p><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0lengthFieldLength   &#x3D; 2lengthAdjustment    &#x3D; 0initialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)  BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)+--------+----------------+      +--------+----------------+| Length | Actual Content |-----&gt;| Length | Actual Content || 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |+--------+----------------+      +--------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0lengthFieldLength   &#x3D; 2lengthAdjustment    &#x3D; 0initialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)  BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)+--------+----------------+      +----------------+| Length | Actual Content |-----&gt;| Actual Content || 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |+--------+----------------+      +----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)lengthFieldLength   &#x3D; 3lengthAdjustment    &#x3D; 0initialBytesToStrip &#x3D; 0  BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)+----------+----------+----------------+      +----------+----------+----------------+| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content ||  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |+----------+----------+----------------+      +----------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0lengthFieldLength   &#x3D; 3lengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)initialBytesToStrip &#x3D; 0  BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)+----------+----------+----------------+      +----------+----------+----------------+|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content || 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |+----------+----------+----------------+      +----------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p><hr><pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)lengthFieldLength   &#x3D; 2lengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)initialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)  BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)+------+--------+------+----------------+      +------+----------------+| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content || 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |+------+--------+------+----------------+      +------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><pre class="line-numbers language-none"><code class="language-none">public class EncoderStudy &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 模拟服务器        &#x2F;&#x2F; 使用EmbeddedChannel测试handler        EmbeddedChannel channel &#x3D; new EmbeddedChannel(                &#x2F;&#x2F; 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 0),                new LoggingHandler(LogLevel.DEBUG)        );        &#x2F;&#x2F; 模拟客户端，写入数据        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();        send(buffer, &quot;Hello&quot;);        channel.writeInbound(buffer);        send(buffer, &quot;World&quot;);        channel.writeInbound(buffer);    &#125;    private static void send(ByteBuf buf, String msg) &#123;        &#x2F;&#x2F; 得到数据的长度        int length &#x3D; msg.length();        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);        &#x2F;&#x2F; 将数据信息写入buf        &#x2F;&#x2F; 写入长度标识前的其他信息        buf.writeByte(0xCA);        &#x2F;&#x2F; 写入数据长度标识        buf.writeInt(length);        &#x2F;&#x2F; 写入长度标识后的其他信息        buf.writeByte(0xFE);        &#x2F;&#x2F; 写入具体的数据        buf.writeBytes(bytes);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-none"><code class="language-none">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |+--------+-------------------------------------------------+----------------+146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><p>Netty提供了很多协议的支持。</p><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 该指令一共有3部分，每条指令之后都要添加回车与换行符*3\r\n&#x2F;&#x2F; 第一个指令的长度是3$3\r\n&#x2F;&#x2F; 第一个指令是set指令set\r\n&#x2F;&#x2F; 下面的指令以此类推$4\r\nname\r\n$5\r\nNyima\r\n  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>客户端代码如下</strong></p><pre class="line-numbers language-none"><code class="language-none">@Slf4jpublic class RedisClient &#123;       public static void main(String[] args) &#123;        NioEventLoopGroup group &#x3D;  new NioEventLoopGroup();        try &#123;            ChannelFuture channelFuture &#x3D; new Bootstrap()                    .group(group)                    .channel(NioSocketChannel.class)                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) &#123;                            &#x2F;&#x2F; 打印日志                            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;                                @Override                                public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;                                    &#x2F;&#x2F; 回车与换行符                                    final byte[] LINE &#x3D; &#123;&#39;\r&#39;,&#39;\n&#39;&#125;;                                    &#x2F;&#x2F; 获得ByteBuf                                    ByteBuf buffer &#x3D; ctx.alloc().buffer();                                    &#x2F;&#x2F; 连接建立后，向Redis中发送一条指令，注意添加回车与换行                                    &#x2F;&#x2F; set name Nyima                                    buffer.writeBytes(&quot;*3&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;$3&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;set&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;$4&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;name&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;$5&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    buffer.writeBytes(&quot;Nyima&quot;.getBytes());                                    buffer.writeBytes(LINE);                                    ctx.writeAndFlush(buffer);                                &#125;                            &#125;);                        &#125;                    &#125;)                    .connect(new InetSocketAddress(&quot;localhost&quot;, 6379));            channelFuture.sync();            &#x2F;&#x2F; 关闭channel            channelFuture.channel().close().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 关闭group            group.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制台打印结果</strong></p><pre class="line-numbers language-none"><code class="language-none">[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0] REGISTERED[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0] CONNECT: &#x2F;127.0.0.1:6379[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] ACTIVE[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] WRITE: 32B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.||00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 77 7a 79 0d 0a |.name..$5..wzy..|+--------+-------------------------------------------------+----------------+[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] FLUSH[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 - R:&#x2F;127.0.0.1:6379] CLOSE[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 ! R:&#x2F;127.0.0.1:6379] INACTIVE[nioEventLoopGroup-2-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0xde2043a0, L:&#x2F;127.0.0.1:5640 ! R:&#x2F;127.0.0.1:6379] UNREGISTERED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Redis中查询执行结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder&#x2F;&#x2F; Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器public final class HttpServerCodec extends CombinedChannelDuplexHandler&lt;HttpRequestDecoder, HttpResponseEncoder&gt;        implements HttpServerUpgradeHandler.SourceCodec  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NioEventLoopGroup</span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>DEBUG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span>                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServerCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 服务器只处理HTTPRequest</span>                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleChannelInboundHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpRequest</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token annotation punctuation">@Override</span>                            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">HttpRequest</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 获得请求uri</span>                                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 获得完整响应，设置版本号与状态码</span>                                <span class="token class-name">DefaultFullHttpResponse</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFullHttpResponse</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">protocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">HttpResponseStatus</span><span class="token punctuation">.</span>OK<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 设置响应内容</span>                                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token string">"&lt;h1>Hello, World!&lt;/h1>"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 设置响应体长度，避免浏览器一直接收响应内容</span>                                response<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span>CONTENT_LENGTH<span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 设置响应体</span>                                response<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeBytes</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 写回响应</span>                                ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 服务器只处理HTTPRequestch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得完整响应，设置版本号与状态码DefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);&#x2F;&#x2F; 设置响应内容byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);&#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容response.headers().setInt(CONTENT_LENGTH, bytes.length);&#x2F;&#x2F; 设置响应体response.content().writeBytes(bytes);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>浏览器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png" alt="img"></a></p><p>控制台</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 请求内容1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] READ: 688B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET &#x2F;favicon.ico||00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP&#x2F;1.1..Host:||00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.||00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee||00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|....&#x2F;&#x2F; 响应内容1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] WRITE: 61B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP&#x2F;1.1 200 OK.||00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:||00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello||00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;&#x2F;h1&gt;   |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;    @Override    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;        &#x2F;&#x2F; 设置魔数 4个字节        out.writeBytes(new byte[]&#123;&#39;N&#39;,&#39;Y&#39;,&#39;I&#39;,&#39;M&#39;&#125;);        &#x2F;&#x2F; 设置版本号 1个字节        out.writeByte(1);        &#x2F;&#x2F; 设置序列化方式 1个字节        out.writeByte(1);        &#x2F;&#x2F; 设置指令类型 1个字节        out.writeByte(msg.getMessageType());        &#x2F;&#x2F; 设置请求序号 4个字节        out.writeInt(msg.getSequenceId());        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据        out.writeByte(0xff);        &#x2F;&#x2F; 获得序列化后的msg        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);        oos.writeObject(msg);        byte[] bytes &#x3D; bos.toByteArray();        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识        out.writeInt(bytes.length);        &#x2F;&#x2F; 设置消息正文        out.writeBytes(bytes);    &#125;    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;        &#x2F;&#x2F; 获取魔数        int magic &#x3D; in.readInt();        &#x2F;&#x2F; 获取版本号        byte version &#x3D; in.readByte();        &#x2F;&#x2F; 获得序列化方式        byte seqType &#x3D; in.readByte();        &#x2F;&#x2F; 获得指令类型        byte messageType &#x3D; in.readByte();        &#x2F;&#x2F; 获得请求序号        int sequenceId &#x3D; in.readInt();        &#x2F;&#x2F; 移除补齐字节        in.readByte();        &#x2F;&#x2F; 获得正文长度        int length &#x3D; in.readInt();        &#x2F;&#x2F; 获得正文        byte[] bytes &#x3D; new byte[length];        in.readBytes(bytes, 0, length);        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));        Message message &#x3D; (Message) ois.readObject();&#x2F;&#x2F; 将信息放入List中，传递给下一个handler        out.add(message);                &#x2F;&#x2F; 打印获得的信息正文        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(magic);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(version);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(seqType);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(messageType);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(sequenceId);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(length);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(message);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestCodec &#123;    static final org.slf4j.Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);    public static void main(String[] args) throws Exception &#123;        EmbeddedChannel channel &#x3D; new EmbeddedChannel();        &#x2F;&#x2F; 添加解码器，避免粘包半包问题        channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0));        channel.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));        channel.pipeline().addLast(new MessageCodec());        LoginRequestMessage user &#x3D; new LoginRequestMessage(&quot;Nyima&quot;, &quot;123&quot;);        &#x2F;&#x2F; 测试编码与解码        ByteBuf byteBuf &#x3D; ByteBufAllocator.DEFAULT.buffer();        new MessageCodec().encode(null, user, byteBuf);        channel.writeInbound(byteBuf);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png" alt="img"></a></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><pre class="line-numbers language-none"><code class="language-none">LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);&#x2F;&#x2F; 不同的channel中使用同一个handler对象，提高复用率channel1.pipeline().addLast(loggingHandler);channel2.pipeline().addLast(loggingHandler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><p><img src="D:\Programs\InterviewNotes\image-20211009114836214.png" alt="image-20211009114836214"></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png" alt="img"></a></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class MessageSharableCodec extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;    @Override    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out) throws Exception &#123;        ...    &#125;    @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123;...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface UserService &#123;    &#x2F;**     * 登录     * @param username 用户名     * @param password 密码     * @return 登录成功返回 true, 否则返回 false     *&#x2F;    boolean login(String username, String password);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface Session &#123;    &#x2F;**     * 绑定会话     * @param channel 哪个 channel 要绑定会话     * @param username 会话绑定用户     *&#x2F;    void bind(Channel channel, String username);    &#x2F;**     * 解绑会话     * @param channel 哪个 channel 要解绑会话     *&#x2F;    void unbind(Channel channel);    &#x2F;**     * 获取属性     * @param channel 哪个 channel     * @param name 属性名     * @return 属性值     *&#x2F;    Object getAttribute(Channel channel, String name);    &#x2F;**     * 设置属性     * @param channel 哪个 channel     * @param name 属性名     * @param value 属性值     *&#x2F;    void setAttribute(Channel channel, String name, Object value);    &#x2F;**     * 根据用户名获取 channel     * @param username 用户名     * @return channel     *&#x2F;    Channel getChannel(String username);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface GroupSession &#123;    &#x2F;**     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null     * @param name 组名     * @param members 成员     * @return 成功时返回组对象, 失败返回 null     *&#x2F;    Group createGroup(String name, Set&lt;String&gt; members);    &#x2F;**     * 加入聊天组     * @param name 组名     * @param member 成员名     * @return 如果组不存在返回 null, 否则返回组对象     *&#x2F;    Group joinMember(String name, String member);    &#x2F;**     * 移除组成员     * @param name 组名     * @param member 成员名     * @return 如果组不存在返回 null, 否则返回组对象     *&#x2F;    Group removeMember(String name, String member);    &#x2F;**     * 移除聊天组     * @param name 组名     * @return 如果组不存在返回 null, 否则返回组对象     *&#x2F;    Group removeGroup(String name);    &#x2F;**     * 获取组成员     * @param name 组名     * @return 成员集合, 如果群不存在或没有成员会返回 empty set     *&#x2F;    Set&lt;String&gt; getMembers(String name);    &#x2F;**     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回     * @param name 组名     * @return 成员 channel 集合     *&#x2F;    List&lt;Channel&gt; getMembersChannel(String name);        &#x2F;**     * 判断群聊是否一被创建     * @param name 群聊名称     * @return 是否存在     *&#x2F;    boolean isCreated(String name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png" alt="img"></a></p><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><pre class="line-numbers language-none"><code class="language-none">public class ChatClient &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatClient.class);    public static void main(String[] args) &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        try &#123;            Bootstrap bootstrap &#x3D; new Bootstrap();            bootstrap.group(group);            bootstrap.channel(NioSocketChannel.class);            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                &#125;            &#125;);            Channel channel &#x3D; bootstrap.connect().sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;           group.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><pre class="line-numbers language-none"><code class="language-none">public class ChatServer &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);    public static void main(String[] args) &#123;        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        try &#123;            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();            bootstrap.group(boss, worker);            bootstrap.channel(NioServerSocketChannel.class);            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                &#125;            &#125;);            Channel channel &#x3D; bootstrap.bind(8080).sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><pre class="line-numbers language-none"><code class="language-none">ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;    &#x2F;**     * 创建连接时执行的处理器，用于执行登陆操作     *&#x2F;    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        &#x2F;&#x2F; 开辟额外线程，用于用户登陆及后续操作        new Thread(()-&gt;&#123;            Scanner scanner &#x3D; new Scanner(System.in);            System.out.println(&quot;请输入用户名&quot;);            String username &#x3D; scanner.next();            System.out.println(&quot;请输入密码&quot;);            String password &#x3D; scanner.next();            &#x2F;&#x2F; 创建包含登录信息的请求体            LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);            &#x2F;&#x2F; 发送到channel中            ctx.writeAndFlush(message);            System.out.println(&quot;等待后续操作...&quot;);            &#x2F;&#x2F; 阻塞，直到登陆成功后CountDownLatch被设置为0            try &#123;                waitLogin.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            &#x2F;&#x2F; 执行后续操作            if (!loginStatus.get()) &#123;                &#x2F;&#x2F; 登陆失败，关闭channel并返回                ctx.channel().close();                return;            &#125;            &#x2F;&#x2F; 登录成功后，执行其他操作            while (true) &#123;                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);                System.out.println(&quot;send [username] [content]&quot;);                System.out.println(&quot;gsend [group name] [content]&quot;);                System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);                System.out.println(&quot;gmembers [group name]&quot;);                System.out.println(&quot;gjoin [group name]&quot;);                System.out.println(&quot;gquit [group name]&quot;);                System.out.println(&quot;quit&quot;);                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);                String command &#x3D; scanner.nextLine();                &#x2F;&#x2F; 获得指令及其参数，并发送对应类型消息                String[] commands &#x3D; command.split(&quot; &quot;);                switch (commands[0])&#123;                    case &quot;send&quot;:                        ctx.writeAndFlush(new ChatRequestMessage(username, commands[1], commands[2]));                        break;                    case &quot;gsend&quot;:                        ctx.writeAndFlush(new GroupChatRequestMessage(username,commands[1], commands[2]));                        break;                    case &quot;gcreate&quot;:                        &#x2F;&#x2F; 分割，获得群员名                        String[] members &#x3D; commands[2].split(&quot;,&quot;);                        Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(members));                        &#x2F;&#x2F; 把自己加入到群聊中                        set.add(username);                        ctx.writeAndFlush(new GroupCreateRequestMessage(commands[1],set));                        break;                    case &quot;gmembers&quot;:                        ctx.writeAndFlush(new GroupMembersRequestMessage(commands[1]));                        break;                    case &quot;gjoin&quot;:                        ctx.writeAndFlush(new GroupJoinRequestMessage(username, commands[1]));                        break;                    case &quot;gquit&quot;:                        ctx.writeAndFlush(new GroupQuitRequestMessage(username, commands[1]));                        break;                    case &quot;quit&quot;:                        ctx.channel().close();                        return;                    default:                        System.out.println(&quot;指令有误，请重新输入&quot;);                        continue;                &#125;            &#125;        &#125;, &quot;login channel&quot;).start();    &#125;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        log.debug(&quot;&#123;&#125;&quot;, msg);        if (msg instanceof LoginResponseMessage) &#123;            &#x2F;&#x2F; 如果是登录响应信息            LoginResponseMessage message &#x3D; (LoginResponseMessage) msg;            boolean isSuccess &#x3D; message.isSuccess();            &#x2F;&#x2F; 登录成功，设置登陆标记            if (isSuccess) &#123;                loginStatus.set(true);            &#125;            &#x2F;&#x2F; 登陆后，唤醒登陆线程            waitLogin.countDown();        &#125;    &#125;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable &#x2F;&#x2F; 必须添加该注解public class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;        &#x2F;&#x2F; 获得登录信息        String username &#x3D; msg.getUsername();        String password &#x3D; msg.getPassword();        &#x2F;&#x2F; 校验登录信息        boolean login &#x3D; UserServiceFactory.getUserService().login(username, password);        LoginResponseMessage message;        if (login) &#123;            message &#x3D; new LoginResponseMessage(true, &quot;登陆成功&quot;);            &#x2F;&#x2F; 绑定channel与user            SessionFactory.getSession().bind(ctx.channel(), username);        &#125; else &#123;            message &#x3D; new LoginResponseMessage(false, &quot;登陆失败&quot;);        &#125;        ctx.writeAndFlush(message);    &#125;&#125;&#x2F;&#x2F; 该handler处理登录请求LoginRequestMessageHandler loginRequestMessageHandler &#x3D; new LoginRequestMessageHandler();ch.pipeline().addLast(new LoginRequestMessageHandler());  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><pre class="line-numbers language-none"><code class="language-none">5665 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 1, 0, 2795667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;登陆成功&#39;&#125;5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;登陆成功&#39;&#125;success  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 21711919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username&#x3D;&#39;Nyima&#39;, password&#x3D;&#39;123&#39;&#125;7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:60572] WRITE: 295B         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 4e 59 49 4d 01 01 01 00 00 00 00 ff 00 00 01 17 |NYIM............||00000010| ac ed 00 05 73 72 00 31 63 6e 2e 6e 79 69 6d 61 |....sr.1cn.nyima||00000020| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes||00000030| 73 61 67 65 2e 4c 6f 67 69 6e 52 65 73 70 6f 6e |sage.LoginRespon||00000040| 73 65 4d 65 73 73 61 67 65 e2 34 49 24 72 52 f3 |seMessage.4I$rR.||00000050| 07 02 00 00 78 72 00 34 63 6e 2e 6e 79 69 6d 61 |....xr.4cn.nyima||00000060| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes||00000070| 73 61 67 65 2e 41 62 73 74 72 61 63 74 52 65 73 |sage.AbstractRes||00000080| 70 6f 6e 73 65 4d 65 73 73 61 67 65 b3 7e 19 32 |ponseMessage.~.2||00000090| 9b 88 4d 7b 02 00 02 5a 00 07 73 75 63 63 65 73 |..M&#123;...Z..succes||000000a0| 73 4c 00 06 72 65 61 73 6f 6e 74 00 12 4c 6a 61 |sL..reasont..Lja||000000b0| 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 78 |va&#x2F;lang&#x2F;String;x||000000c0| 72 00 24 63 6e 2e 6e 79 69 6d 61 63 2e 73 74 75 |r.$cn.nyimac.stu||000000d0| 64 79 2e 64 61 79 38 2e 6d 65 73 73 61 67 65 2e |dy.day8.message.||000000e0| 4d 65 73 73 61 67 65 dd e9 84 b7 21 db 18 52 02 |Message....!..R.||000000f0| 00 02 49 00 0b 6d 65 73 73 61 67 65 54 79 70 65 |..I..messageType||00000100| 49 00 0a 73 65 71 75 65 6e 63 65 49 64 78 70 00 |I..sequenceIdxp.||00000110| 00 00 00 00 00 00 00 01 74 00 0c e7 99 bb e9 99 |........t.......||00000120| 86 e6 88 90 e5 8a 9f                            |.......         |+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharable &#x2F;&#x2F; 必须添加该注解public class ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception &#123;        &#x2F;&#x2F; 获得user所在的channel        Channel channel &#x3D; SessionFactory.getSession().getChannel(msg.getTo());        &#x2F;&#x2F; 如果双方都在线        if (channel !&#x3D; null) &#123;            &#x2F;&#x2F; 通过接收方与服务器之间的channel发送信息            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));        &#125; else &#123;            &#x2F;&#x2F; 通过发送方与服务器之间的channel发送消息            ctx.writeAndFlush(new ChatResponseMessage(false, &quot;对方用户不存在或离线，发送失败&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理单聊请求ChatRequestMessageHandler chatRequestMessageHandler &#x3D; new ChatRequestMessageHandler();ch.pipeline().addLast(chatRequestMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><pre class="line-numbers language-none"><code class="language-none">send Nyima hello  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接收方（Nyima）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 收到zhangsan发来的消息20230 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;hello&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupCreateMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception &#123;        &#x2F;&#x2F; 获得要创建的群聊名        String groupName &#x3D; msg.getGroupName();        &#x2F;&#x2F; 获得要创建的群聊的成员组        Set&lt;String&gt; members &#x3D; msg.getMembers();        &#x2F;&#x2F; 判断该群聊是否创建过，未创建返回null并创建群聊        Group group &#x3D; GroupSessionFactory.getGroupSession().createGroup(groupName, members);        if (group &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 发送创建成功消息            GroupCreateResponseMessage groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(true, groupName + &quot;创建成功&quot;);            ctx.writeAndFlush(groupCreateResponseMessage);            &#x2F;&#x2F; 获得在线群员的channel，给群员发送入群聊消息            List&lt;Channel&gt; membersChannel &#x3D; GroupSessionFactory.getGroupSession().getMembersChannel(groupName);            groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(true, &quot;您已被拉入&quot;+groupName);            &#x2F;&#x2F; 给每个在线群员发送消息            for(Channel channel : membersChannel) &#123;                channel.writeAndFlush(groupCreateResponseMessage);            &#125;        &#125; else &#123;            &#x2F;&#x2F; 发送失败消息            GroupCreateResponseMessage groupCreateResponseMessage &#x3D; new GroupCreateResponseMessage(false, groupName + &quot;已存在&quot;);            ctx.writeAndFlush(groupCreateResponseMessage);        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理创建群聊请求GroupCreateMessageHandler groupCreateMessageHandler &#x3D; new GroupCreateMessageHandler();ch.pipeline().addLast(groupCreateMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>创建者客户端</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 首次创建gcreate Netty学习 zhangsan,lisi31649 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;Netty学习创建成功&#39;&#125;15244 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;您已被拉入Netty学习&#39;&#125;&#x2F;&#x2F; 再次创建gcreate Netty学习 zhangsan,lisi40771 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;Netty学习已存在&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>群员客户端</p><pre class="line-numbers language-none"><code class="language-none">28788 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;您已被拉入Netty学习&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupChatMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception &#123;        String groupName &#x3D; msg.getGroupName();        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();        &#x2F;&#x2F; 判断群聊是否存在        boolean isCreated &#x3D; groupSession.isCreated(groupName);        if (isCreated) &#123;            &#x2F;&#x2F; 给群员发送信息            List&lt;Channel&gt; membersChannel &#x3D; groupSession.getMembersChannel(groupName);            for(Channel channel : membersChannel) &#123;                channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));            &#125;        &#125; else &#123;            ctx.writeAndFlush(new GroupChatResponseMessage(false, &quot;群聊不存在&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理群聊聊天GroupChatMessageHandler groupChatMessageHandler &#x3D; new GroupChatMessageHandler();ch.pipeline().addLast(groupChatMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><pre class="line-numbers language-none"><code class="language-none">gsend Netty学习 你们好45408 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;你们好&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接收方</p><pre class="line-numbers language-none"><code class="language-none">48082 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from&#x3D;&#39;zhangsan&#39;, content&#x3D;&#39;你们好&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发送方（群聊不存在）</p><pre class="line-numbers language-none"><code class="language-none">gsend Spring学习 你们好25140 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;群聊不存在&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupJoinMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception &#123;        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();        &#x2F;&#x2F; 判断该用户是否在群聊中        Set&lt;String&gt; members &#x3D; groupSession.getMembers(msg.getGroupName());        boolean joinFlag &#x3D; false;        &#x2F;&#x2F; 群聊存在且用户未加入，才能加入        if (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;            joinFlag &#x3D; true;        &#125;        if (joinFlag) &#123;            &#x2F;&#x2F; 加入群聊            groupSession.joinMember(msg.getGroupName(), msg.getUsername());            ctx.writeAndFlush(new GroupJoinResponseMessage(true,&quot;加入&quot;+msg.getGroupName()+&quot;成功&quot;));        &#125; else &#123;            ctx.writeAndFlush(new GroupJoinResponseMessage(false, &quot;加入失败，群聊未存在或您已加入该群聊&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理加入群聊GroupJoinMessageHandler groupJoinMessageHandler &#x3D; new GroupJoinMessageHandler();ch.pipeline().addLast(groupJoinMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>正常加入群聊</p><pre class="line-numbers language-none"><code class="language-none">94921 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;加入Netty学习成功&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加入不能存在或已加入的群聊</p><pre class="line-numbers language-none"><code class="language-none">44025 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;加入失败，群聊未存在或您已加入该群聊&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupQuitMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception &#123;        GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();        String groupName &#x3D; msg.getGroupName();        Set&lt;String&gt; members &#x3D; groupSession.getMembers(groupName);        String username &#x3D; msg.getUsername();        &#x2F;&#x2F; 判断用户是否在群聊中以及群聊是否存在        boolean joinFlag &#x3D; false;        if (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;            &#x2F;&#x2F; 可以退出            joinFlag &#x3D; true;        &#125;        if (joinFlag) &#123;            &#x2F;&#x2F; 退出成功            groupSession.removeMember(groupName, username);            ctx.writeAndFlush(new GroupQuitResponseMessage(true, &quot;退出&quot;+groupName+&quot;成功&quot;));        &#125; else &#123;            &#x2F;&#x2F; 退出失败            ctx.writeAndFlush(new GroupQuitResponseMessage(false, &quot;群聊不存在或您未加入该群，退出&quot;+groupName+&quot;失败&quot;));        &#125;    &#125;&#125;&#x2F;&#x2F; 该handler处理退出群聊GroupQuitMessageHandler groupQuitMessageHandler &#x3D; new GroupQuitMessageHandler();ch.pipeline().addLast(groupQuitMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>正常退出</p><pre class="line-numbers language-none"><code class="language-none">32282 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;true, reason&#x3D;&#39;退出Netty学习成功&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出不存在或未加入的群聊</p><pre class="line-numbers language-none"><code class="language-none">67404 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success&#x3D;false, reason&#x3D;&#39;群聊不存在或您未加入该群，退出Netty失败&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class GroupMembersMessageHandler extends SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception &#123;        ctx.writeAndFlush(new GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));    &#125;&#125;&#x2F;&#x2F; 该handler处理查看成员GroupMembersMessageHandler groupMembersMessageHandler &#x3D; new GroupMembersMessageHandler();ch.pipeline().addLast(groupMembersMessageHandler);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><pre class="line-numbers language-none"><code class="language-none">46557 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members&#x3D;[zhangsan, Nyima]&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class QuitHandler extends ChannelInboundHandlerAdapter &#123;    &#x2F;**     * 断开连接时触发 Inactive事件     *&#x2F;    @Override    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;        &#x2F;&#x2F; 解绑        SessionFactory.getSession().unbind(ctx.channel());    &#125;    &#x2F;**     * 异常退出，需要解绑     *&#x2F;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        &#x2F;&#x2F; 解绑        SessionFactory.getSession().unbind(ctx.channel());    &#125;&#125; &#x2F;&#x2F; 该handler处理退出聊天室ch.pipeline().addLast(quitHandler);GroupMembersMessageHandler groupMembersMessageHandler &#x3D; new GroupMembersMessageHandler();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出时，客户端会关闭channel并返回</strong></p><pre class="line-numbers language-none"><code class="language-none">case &quot;quit&quot;:&#x2F;&#x2F; 关闭channel并返回    ctx.channel().close();    return;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" alt="img"></a></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));&#x2F;&#x2F; 添加双向处理器，负责处理READER_IDLE事件ch.pipeline().addLast(new ChannelDuplexHandler() &#123;    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;        &#x2F;&#x2F; 获得事件        IdleStateEvent event &#x3D; (IdleStateEvent) evt;        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE) &#123;            &#x2F;&#x2F; 断开连接            ctx.channel().close();        &#125;    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>使用<code>IdleStateHandler</code>进行空闲检测</p></li><li><p>使用双向处理器</p><pre class="line-numbers language-none"><code class="language-none">ChannelDuplexHandler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对入站与出站事件进行处理</p><ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 发送心跳包，让服务器知道客户端在线&#x2F;&#x2F; 3s未发生WRITER_IDLE，就像服务器发送心跳包&#x2F;&#x2F; 该值为服务器端设置的READER_IDLE触发时间的一半左右ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));ch.pipeline().addLast(new ChannelDuplexHandler() &#123;    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;        IdleStateEvent event &#x3D; (IdleStateEvent) evt;        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;            &#x2F;&#x2F; 发送心跳包            ctx.writeAndFlush(new PingMessage());        &#125;    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><pre class="line-numbers language-none"><code class="language-none">public interface Serializer &#123;    &#x2F;**     * 序列化     * @param object 被序列化的对象     * @param &lt;T&gt; 被序列化对象类型     * @return 序列化后的字节数组     *&#x2F;    &lt;T&gt; byte[] serialize(T object);    &#x2F;**     * 反序列化     * @param clazz 反序列化的目标类的Class对象     * @param bytes 被反序列化的字节数组     * @param &lt;T&gt; 反序列化目标类     * @return 反序列化后的对象     *&#x2F;    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><pre class="line-numbers language-none"><code class="language-none">public enum SerializerAlgorithm implements Serializer &#123;    &#x2F;&#x2F; Java的序列化和反序列化    Java &#123;        @Override        public &lt;T&gt; byte[] serialize(T object) &#123;            &#x2F;&#x2F; 序列化后的字节数组            byte[] bytes &#x3D; null;            try (ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();                 ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos)) &#123;                oos.writeObject(object);                bytes &#x3D; bos.toByteArray();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            return bytes;        &#125;        @Override        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;            T target &#x3D; null;            System.out.println(Arrays.toString(bytes));            try (ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);                 ObjectInputStream ois &#x3D; new ObjectInputStream(bis)) &#123;                target &#x3D; (T) ois.readObject();            &#125; catch (IOException | ClassNotFoundException e) &#123;                e.printStackTrace();            &#125;            &#x2F;&#x2F; 返回反序列化后的对象            return target;        &#125;    &#125;         &#x2F;&#x2F; Json的序列化和反序列化    Json &#123;        @Override        public &lt;T&gt; byte[] serialize(T object) &#123;            String s &#x3D; new Gson().toJson(object);            System.out.println(s);            &#x2F;&#x2F; 指定字符集，获得字节数组            return s.getBytes(StandardCharsets.UTF_8);        &#125;        @Override        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;            String s &#x3D; new String(bytes, StandardCharsets.UTF_8);            System.out.println(s);            &#x2F;&#x2F; 此处的clazz为具体类型的Class对象，而不是父类Message的            return new Gson().fromJson(s, clazz);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得序列化后的msg&#x2F;&#x2F; 使用指定的序列化方式SerializerAlgorithm[] values &#x3D; SerializerAlgorithm.values();&#x2F;&#x2F; 获得序列化后的对象byte[] bytes &#x3D; values[out.getByte(5)-1].serialize(msg);Cop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解码</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得反序列化方式SerializerAlgorithm[] values &#x3D; SerializerAlgorithm.values();&#x2F;&#x2F; 通过指定方式进行反序列化&#x2F;&#x2F; 需要通过Message的方法获得具体的消息类型Message message &#x3D; values[seqType-1].deserialize(Message.getMessageClass(messageType), bytes);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><pre class="line-numbers language-none"><code class="language-none">public class TestParam &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常        new Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);                &#x2F;&#x2F; ServerSocketChannel 5s内未建立连接就抛出异常        new ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常        new ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p></li><li><p>服务器通过</p><pre class="line-numbers language-none"><code class="language-none">ServerBootstrap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来配置参数，但是对于不同的 Channel 需要选择不同的方法</p><ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><pre class="line-numbers language-none"><code class="language-none">public final void connect(                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;        ...            &#x2F;&#x2F; Schedule connect timeout.    &#x2F;&#x2F; 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();    &#x2F;&#x2F; 如果超时时间大于0    if (connectTimeoutMillis &gt; 0) &#123;        &#x2F;&#x2F; 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行        &#x2F;&#x2F; schedule(Runnable command, long delay, TimeUnit unit)        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 判断是否建立连接，Promise进行NIO线程与主线程之间的通信                &#x2F;&#x2F; 如果超时，则通过tryFailure方法将异常放入Promise中                &#x2F;&#x2F; 在主线程中抛出                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;                ConnectTimeoutException cause &#x3D; new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;                    close(voidPromise());                &#125;            &#125;        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);    &#125;       ...        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png" alt="img"></a></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png" alt="img"></a></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png" alt="img"></a></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 设置全连接队列，大小为2new ServerBootstrap().option(ChannelOption.SO_BACKLOG, 2);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doBind(SocketAddress localAddress) throws Exception &#123;    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; else &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><pre class="line-numbers language-none"><code class="language-none">private volatile int backlog &#x3D; NetUtil.SOMAXCONN;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的赋值操作如下</p><pre class="line-numbers language-none"><code class="language-none">SOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;    @Override    public Integer run() &#123;        &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.        &#x2F;&#x2F; The known defaults:        &#x2F;&#x2F; - Windows NT Server 4.0+: 200        &#x2F;&#x2F; - Linux and Mac OS X: 128        int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);        BufferedReader in &#x3D; null;        try &#123;            &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the            &#x2F;&#x2F; try &#x2F; catch block.            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936            if (file.exists()) &#123;                in &#x3D; new BufferedReader(new FileReader(file));                &#x2F;&#x2F; 将somaxconn设置为Linux配置文件中设置的值                somaxconn &#x3D; Integer.parseInt(in.readLine());                if (logger.isDebugEnabled()) &#123;                    logger.debug(&quot;&#123;&#125;: &#123;&#125;&quot;, file, somaxconn);                &#125;            &#125; else &#123;                ...            &#125;            ...        &#125;          &#x2F;&#x2F; 返回backlog的值        return somaxconn;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux/Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型&#x2F;&#x2F; 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型new ServerBootstrap().childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator());  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; true表示使用直接内存new PooledByteBufAllocator(true);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>池化并使用堆内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; false表示使用堆内存new PooledByteBufAllocator(false);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>非池化并使用直接内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; ture表示使用直接内存new UnpooledByteBufAllocator(true);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>非池化并使用堆内存</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; false表示使用堆内存new UnpooledByteBufAllocator(false);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><pre class="line-numbers language-none"><code class="language-none">public abstract class Message implements Serializable &#123;    ...    &#x2F;&#x2F; 添加RPC消息类型    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;    static &#123;        &#x2F;&#x2F; 将消息类型放入消息类对象Map中        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RPC请求消息</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RpcRequestMessage extends Message &#123;    &#x2F;**     * 调用的接口全限定名，服务端根据它找到实现     *&#x2F;    private String interfaceName;        &#x2F;**     * 调用接口中的方法名     *&#x2F;    private String methodName;        &#x2F;**     * 方法返回类型     *&#x2F;    private Class&lt;?&gt; returnType;        &#x2F;**     * 方法参数类型数组     *&#x2F;    private Class[] parameterTypes;        &#x2F;**     * 方法参数值数组     *&#x2F;    private Object[] parameterValue;    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;        super.setSequenceId(sequenceId);        this.interfaceName &#x3D; interfaceName;        this.methodName &#x3D; methodName;        this.returnType &#x3D; returnType;        this.parameterTypes &#x3D; parameterTypes;        this.parameterValue &#x3D; parameterValue;    &#125;    @Override    public int getMessageType() &#123;        return RPC_MESSAGE_TYPE_REQUEST;    &#125;         public String getInterfaceName() &#123;        return interfaceName;    &#125;    public String getMethodName() &#123;        return methodName;    &#125;    public Class&lt;?&gt; getReturnType() &#123;        return returnType;    &#125;    public Class[] getParameterTypes() &#123;        return parameterTypes;    &#125;    public Object[] getParameterValue() &#123;        return parameterValue;    &#125;        @Override    public String toString() &#123;        return &quot;RpcRequestMessage&#123;&quot; +                &quot;interfaceName&#x3D;&#39;&quot; + interfaceName + &#39;\&#39;&#39; +                &quot;, methodName&#x3D;&#39;&quot; + methodName + &#39;\&#39;&#39; +                &quot;, returnType&#x3D;&quot; + returnType +                &quot;, parameterTypes&#x3D;&quot; + Arrays.toString(parameterTypes) +                &quot;, parameterValue&#x3D;&quot; + Arrays.toString(parameterValue) +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RpcResponseMessage extends Message &#123;    &#x2F;**     * 返回值     *&#x2F;    private Object returnValue;    &#x2F;**     * 异常值     *&#x2F;    private Exception exceptionValue;    @Override    public int getMessageType() &#123;        return RPC_MESSAGE_TYPE_RESPONSE;    &#125;            public void setReturnValue(Object returnValue) &#123;        this.returnValue &#x3D; returnValue;    &#125;    public void setExceptionValue(Exception exceptionValue) &#123;        this.exceptionValue &#x3D; exceptionValue;    &#125;         public Object getReturnValue() &#123;        return returnValue;    &#125;    public Exception getExceptionValue() &#123;        return exceptionValue;    &#125;        @Override    public String toString() &#123;        return &quot;RpcResponseMessage&#123;&quot; +                &quot;returnValue&#x3D;&quot; + returnValue +                &quot;, exceptionValue&#x3D;&quot; + exceptionValue +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RPCServer &#123;    public static void main(String[] args) &#123;        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        &#x2F;&#x2F; PRC 请求消息处理器        RpcRequestMessageHandler rpcRequestMessageHandler &#x3D; new RpcRequestMessageHandler();        try &#123;            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.group(boss, worker);            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                    ch.pipeline().addLast(rpcRequestMessageHandler);                &#125;            &#125;);            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            boss.shutdownGracefully();            worker.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><pre class="line-numbers language-none"><code class="language-none">public class RPCClient &#123;    public static void main(String[] args) &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        &#x2F;&#x2F; PRC 请求消息处理器        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();        try &#123;            Bootstrap bootstrap &#x3D; new Bootstrap();            bootstrap.channel(NioSocketChannel.class);            bootstrap.group(group);            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ch.pipeline().addLast(new ProtocolFrameDecoder());                    ch.pipeline().addLast(loggingHandler);                    ch.pipeline().addLast(messageSharableCodec);                    ch.pipeline().addLast(rpcResponseMessageHandler);                &#125;            &#125;);            Channel channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();            channel.closeFuture().sync();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过接口Class获取实例对象的<strong>Factory</strong></p><pre class="line-numbers language-none"><code class="language-none">public class ServicesFactory &#123;    static HashMap&lt;Class&lt;?&gt;, Object&gt; map &#x3D; new HashMap&lt;&gt;(16);    public static Object getInstance(Class&lt;?&gt; interfaceClass) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;        &#x2F;&#x2F; 根据Class创建实例        try &#123;            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloService&quot;);            Object instance &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;).newInstance();                       &#x2F;&#x2F; 放入 InterfaceClass -&gt; InstanceObject 的映射            map.put(clazz, instance);        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;            e.printStackTrace();        &#125;          return map.get(interfaceClass);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage) &#123;        RpcResponseMessage rpcResponseMessage &#x3D; new RpcResponseMessage();        try &#123;            &#x2F;&#x2F; 设置返回值的属性            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());            &#x2F;&#x2F; 返回一个实例            HelloService service &#x3D; (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));                        &#x2F;&#x2F; 通过反射调用方法，并获取返回值            Method method &#x3D; service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());            &#x2F;&#x2F; 获得返回值            Object invoke &#x3D; method.invoke(service, rpcMessage.getParameterValue());            &#x2F;&#x2F; 设置返回值            rpcResponseMessage.setReturnValue(invoke);        &#125; catch (Exception e) &#123;            e.printStackTrace();            &#x2F;&#x2F; 设置异常            rpcResponseMessage.setExceptionValue(e);        &#125;    &#125;    &#x2F;&#x2F; 向channel中写入Message    ctx.writeAndFlush(rpcResponseMessage);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;        log.debug(&quot;&#123;&#125;&quot;, msg);        System.out.println((String)msg.getReturnValue());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><pre class="line-numbers language-none"><code class="language-none">public class RPCClient &#123;    public static void main(String[] args) &#123;...                   &#x2F;&#x2F; 创建请求并发送RpcRequestMessage message &#x3D; new RpcRequestMessage(1,               &quot;cn.nyimac.study.day8.server.service.HelloService&quot;,               &quot;sayHello&quot;,               String.class,               new Class[]&#123;String.class&#125;,               new Object[]&#123;&quot;Nyima&quot;&#125;);        channel.writeAndFlush(message);                       ...        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p>客户端</p><pre class="line-numbers language-none"><code class="language-none">1606 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue&#x3D;你好，Nyima, exceptionValue&#x3D;null&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><pre class="line-numbers language-none"><code class="language-none">public class RPCClientManager &#123;    &#x2F;**     * 产生SequenceId     *&#x2F;    private static AtomicInteger sequenceId &#x3D; new AtomicInteger(0);    private static volatile Channel channel &#x3D; null;    private static final Object lock &#x3D; new Object();    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建代理对象        HelloService service &#x3D; (HelloService) getProxy(HelloService.class);        &#x2F;&#x2F; 通过代理对象执行方法        System.out.println(service.sayHello(&quot;Nyima&quot;));        System.out.println(service.sayHello(&quot;Hulu&quot;));    &#125;    &#x2F;**     * 单例模式创建Channel     *&#x2F;    public static Channel getChannel() &#123;        if (channel &#x3D;&#x3D; null) &#123;            synchronized (lock) &#123;                if (channel &#x3D;&#x3D; null) &#123;                    init();                &#125;            &#125;        &#125;        return channel;    &#125;    &#x2F;**     * 使用代理模式，帮助我们创建请求消息并发送     *&#x2F;    public static Object getProxy(Class&lt;?&gt; serviceClass) &#123;        Class&lt;?&gt;[] classes &#x3D; new Class&lt;?&gt;[]&#123;serviceClass&#125;;        &#x2F;&#x2F; 使用JDK代理，创建代理对象        Object o &#x3D; Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                &#x2F;&#x2F; 创建请求消息                int id &#x3D; sequenceId.getAndIncrement();                RpcRequestMessage message &#x3D; new RpcRequestMessage(id, serviceClass.getName(),                        method.getName(), method.getReturnType(),                        method.getParameterTypes(),                        args);                &#x2F;&#x2F; 发送消息                getChannel().writeAndFlush(message);                &#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的                DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());                &#x2F;&#x2F; 将Promise放入Map中                RpcResponseMessageHandler.promiseMap.put(id, promise);                &#x2F;&#x2F; 等待被放入Promise中结果                promise.await();                if (promise.isSuccess()) &#123;                    &#x2F;&#x2F; 调用方法成功，返回方法执行结果                    return promise.getNow();                &#125; else &#123;                    &#x2F;&#x2F; 调用方法失败，抛出异常                    throw new RuntimeException(promise.cause());                &#125;            &#125;        &#125;);        return o;    &#125;    private static void init() &#123;        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();        &#x2F;&#x2F; PRC 请求消息处理器        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();        Bootstrap bootstrap &#x3D; new Bootstrap();        bootstrap.channel(NioSocketChannel.class);        bootstrap.group(group);        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;            @Override            protected void initChannel(SocketChannel ch) throws Exception &#123;                ch.pipeline().addLast(new ProtocolFrameDecoder());                ch.pipeline().addLast(loggingHandler);                ch.pipeline().addLast(messageSharableCodec);                ch.pipeline().addLast(rpcResponseMessageHandler);            &#125;        &#125;);        try &#123;            channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();            &#x2F;&#x2F; 异步关闭 group，避免Channel被阻塞            channel.closeFuture().addListener(future -&gt; &#123;                group.shutdownGracefully();            &#125;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获得Channel</strong></p><ul><li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li><li>通过<strong>单例模式</strong>创建与获取Channel</li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());&#x2F;&#x2F; 将Promise放入Map中RpcResponseMessageHandler.promiseMap.put(id, promise);&#x2F;&#x2F; 等待被放入Promise中结果promise.await();if (promise.isSuccess()) &#123;    &#x2F;&#x2F; 调用方法成功，返回方法执行结果    return promise.getNow();&#125; else &#123;    &#x2F;&#x2F; 调用方法失败，抛出异常    throw new RuntimeException(promise.cause());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的PromisePromise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());Object returnValue &#x3D; msg.getReturnValue();Exception exception &#x3D; msg.getExceptionValue();if (promise !&#x3D; null) &#123;    if (exception !&#x3D; null) &#123;        &#x2F;&#x2F; 返回结果中有异常信息        promise.setFailure(exception);    &#125; else &#123;        &#x2F;&#x2F; 方法正常执行，没有异常        promise.setSuccess(returnValue);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><pre class="line-numbers language-none"><code class="language-none">@ChannelHandler.Sharablepublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);    &#x2F;**     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值     *&#x2F;    public static Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap &#x3D; new ConcurrentHashMap&lt;&gt;(16);    @Override    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;        &#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的Promise        Promise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());        Object returnValue &#x3D; msg.getReturnValue();        Exception exception &#x3D; msg.getExceptionValue();        if (promise !&#x3D; null) &#123;            if (exception !&#x3D; null) &#123;                &#x2F;&#x2F; 返回结果中有异常信息                promise.setFailure(exception);            &#125; else &#123;                &#x2F;&#x2F; 方法正常执行，没有异常                promise.setSuccess(returnValue);            &#125;        &#125;        &#x2F;&#x2F; 拿到返回结果并打印        log.debug(&quot;&#123;&#125;&quot;, msg);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selectorSelector selector &#x3D; Selector.open(); &#x2F;&#x2F; 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 configNioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();&#x2F;&#x2F; 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannelServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false);&#x2F;&#x2F; 启动 nio boss 线程执行接下来的操作&#x2F;&#x2F;注册（仅关联 selector 和 NioServerSocketChannel），未关注事件SelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);&#x2F;&#x2F; head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor&#x2F;&#x2F; 绑定端口serverSocketChannel.bind(new InetSocketAddress(8080));&#x2F;&#x2F; 触发 channel active 事件，在 head 中关注 op_accept 事件selectionKey.interestOps(SelectionKey.OP_ACCEPT);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><pre class="line-numbers language-none"><code class="language-none">public ChannelFuture bind(SocketAddress localAddress) &#123;validate();return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><pre class="line-numbers language-none"><code class="language-none">private ChannelFuture doBind(final SocketAddress localAddress) &#123;    &#x2F;&#x2F; 负责NioServerSocketChannel和ServerSocketChannel的创建    &#x2F;&#x2F; ServerSocketChannel的注册工作    &#x2F;&#x2F; init由main线程完成，regisetr由NIO线程完成    final ChannelFuture regFuture &#x3D; initAndRegister();    final Channel channel &#x3D; regFuture.channel();    if (regFuture.cause() !&#x3D; null) &#123;        return regFuture;    &#125;    &#x2F;&#x2F; 因为register操作是异步的    &#x2F;&#x2F; 所以要判断主线程执行到这里时，register操作是否已经执行完毕    if (regFuture.isDone()) &#123;        &#x2F;&#x2F; At this point we know that the registration was complete and successful.        ChannelPromise promise &#x3D; channel.newPromise();                &#x2F;&#x2F; 执行doBind0绑定操作        doBind0(regFuture, channel, localAddress, promise);        return promise;    &#125; else &#123;        &#x2F;&#x2F; Registration future is almost always fulfilled already, but just in case it&#39;s not.        &#x2F;&#x2F; 如果register操作还没执行完，就会到这个分支中来        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);                &#x2F;&#x2F; 添加监听器，NIO线程异步进行doBind0操作        regFuture.addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture future) throws Exception &#123;                Throwable cause &#x3D; future.cause();                if (cause !&#x3D; null) &#123;                    &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an                    &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.                    promise.setFailure(cause);                &#125; else &#123;                    &#x2F;&#x2F; Registration was successful, so set the correct executor to use.                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        return promise;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><pre class="line-numbers language-none"><code class="language-none">final ChannelFuture initAndRegister() &#123;    Channel channel &#x3D; null;    try &#123;        channel &#x3D; channelFactory.newChannel();        init(channel);    &#125; catch (Throwable t) &#123;        if (channel !&#x3D; null) &#123;            &#x2F;&#x2F; channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))            channel.unsafe().closeForcibly();            &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);        &#125;        &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);    &#125;    ChannelFuture regFuture &#x3D; config().group().register(channel);    if (regFuture.cause() !&#x3D; null) &#123;        if (channel.isRegistered()) &#123;            channel.close();        &#125; else &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;    &#x2F;&#x2F; If we are here and the promise is not failed, it&#39;s one of the following cases:    &#x2F;&#x2F; 1) If we attempted registration from the event loop, the registration has been completed at this point.    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now because the channel has been registered.    &#x2F;&#x2F; 2) If we attempted registration from the other thread, the registration request has been successfully    &#x2F;&#x2F;    added to the event loop&#39;s task queue for later execution.    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now:    &#x2F;&#x2F;         because bind() or connect() will be executed *after* the scheduled registration task is executed    &#x2F;&#x2F;         because register(), bind(), and connect() are all bound to the same thread.    return regFuture;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre class="line-numbers language-none"><code class="language-none">Channel channel &#x3D; null;try &#123;    &#x2F;&#x2F; 通过反射初始化NioServerSocketChannel    channel &#x3D; channelFactory.newChannel();    init(channel);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newChannel方法</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic T newChannel() &#123;    try &#123;        &#x2F;&#x2F; 通过反射调用NioServerSocketChannel的构造方法        &#x2F;&#x2F; 创建NioServerSocketChannel对象        return constructor.newInstance();    &#125; catch (Throwable t) &#123;        throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NioServerSocketChannel构造方法</p><pre class="line-numbers language-none"><code class="language-none">public NioServerSocketChannel() &#123;    &#x2F;&#x2F; 创建了ServerSocketChannel实例    this(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>newSocket方法</p><pre class="line-numbers language-none"><code class="language-none">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;    try &#123;        &#x2F;&#x2F; ServerSocketChannel.open方法：        &#x2F;&#x2F; SelectorProvider.provider().openServerSocketChannel()    &#x2F;&#x2F; 所以此处相当于ServerSocketChannel.open()        &#x2F;&#x2F; 创建了ServerSocketChannel实例    return provider.openServerSocketChannel();&#125; catch (IOException e) &#123;    throw new ChannelException(&quot;Failed to open a server socket.&quot;, e);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>init方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridevoid init(Channel channel) &#123;   ...    &#x2F;&#x2F; NioSocketChannl的Pipeline        ChannelPipeline p &#x3D; channel.pipeline();    ...    &#x2F;&#x2F; 向Pipeline中添加了一个handler，该handler等待被调用    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;        @Override        &#x2F;&#x2F; register之后才调用该方法        public void initChannel(final Channel ch) &#123;            final ChannelPipeline pipeline &#x3D; ch.pipeline();                        &#x2F;&#x2F; 创建handler并加入到pipeline中            ChannelHandler handler &#x3D; config.handler();            if (handler !&#x3D; null) &#123;                pipeline.addLast(handler);            &#125;            ch.eventLoop().execute(new Runnable() &#123;                @Override                public void run() &#123;                    &#x2F;&#x2F; 添加新的handler，在发生Accept事件后建立连接                    pipeline.addLast(new ServerBootstrapAcceptor(                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));                &#125;            &#125;);        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>init主要完成了以下三个操作</strong></p><ul><li><p>创建NioServerSocketChannel</p></li><li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p></li><li><p>由</p><pre class="line-numbers language-none"><code class="language-none">initChannel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法向NioServerSocketChannel中添加了两个handler，</p><p>添加操作在register之后被执行</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;    ...    &#x2F;&#x2F; 获取EventLoop    AbstractChannel.this.eventLoop &#x3D; eventLoop;   &#x2F;&#x2F; 此处完成了由 主线程 到 NIO线程 的切换    &#x2F;&#x2F; eventLoop.inEventLoop()用于判断当前线程是否为NIO线程    if (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; else &#123;        try &#123;            &#x2F;&#x2F; 向NIO线程中添加任务            eventLoop.execute(new Runnable() &#123;                @Override                public void run() &#123;                    &#x2F;&#x2F; 该方法中会执行doRegister                    &#x2F;&#x2F; 执行真正的注册操作                    register0(promise);                &#125;            &#125;);        &#125; catch (Throwable t) &#123;           ...        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>register0方法</p><pre class="line-numbers language-none"><code class="language-none">private void register0(ChannelPromise promise) &#123;    try &#123;       ...                    &#x2F;&#x2F; 执行真正的注册操作        doRegister();        neverRegistered &#x3D; false;        registered &#x3D; true;        &#x2F;&#x2F; Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the        &#x2F;&#x2F; user may already fire events through the pipeline in the ChannelFutureListener.                &#x2F;&#x2F; 调用init中的initChannel方法        pipeline.invokeHandlerAddedIfNeeded();        ...    &#125; catch (Throwable t) &#123;        ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>doRegister方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doRegister() throws Exception &#123;    boolean selected &#x3D; false;    for (;;) &#123;        try &#123;            &#x2F;&#x2F; javaChannel()即为ServerSocketChannel            &#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector            &#x2F;&#x2F; this为NIOServerSocketChannel，作为附件            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);            return;        &#125; catch (CancelledKeyException e) &#123;            ...                   &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调initChannel</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void initChannel(final Channel ch) &#123;    final ChannelPipeline pipeline &#x3D; ch.pipeline();    ChannelHandler handler &#x3D; config.handler();    if (handler !&#x3D; null) &#123;        pipeline.addLast(handler);    &#125;    &#x2F;&#x2F; 添加新任务，任务负责添加handler    &#x2F;&#x2F; 该handler负责发生Accepet事件后建立连接    ch.eventLoop().execute(new Runnable() &#123;        @Override        public void run() &#123;            pipeline.addLast(new ServerBootstrapAcceptor(                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; javaChannel()即为ServerSocketChannel&#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector&#x2F;&#x2F; this为NIOServerSocketChannel，作为附件selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; initAndRegister为异步方法，会返回ChannelFuture对象final ChannelFuture regFuture &#x3D; initAndRegister();regFuture.addListener(new ChannelFutureListener() &#123;    @Override    public void operationComplete(ChannelFuture future) throws Exception &#123;        Throwable cause &#x3D; future.cause();        if (cause !&#x3D; null) &#123;            &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an            &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.            promise.setFailure(cause);        &#125; else &#123;            &#x2F;&#x2F; Registration was successful, so set the correct executor to use.            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586            promise.registered();            &#x2F;&#x2F; 如果没有异常，则执行绑定操作            doBind0(regFuture, channel, localAddress, promise);        &#125;    &#125;&#125;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><pre class="line-numbers language-none"><code class="language-none">@SuppressJava6Requirement(reason &#x3D; &quot;Usage guarded by java version check&quot;)@Overrideprotected void doBind(SocketAddress localAddress) throws Exception &#123;    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;        &#x2F;&#x2F; 调用ServerSocketChannel的bind方法，绑定端口        javaChannel().bind(localAddress, config.getBacklog());    &#125; else &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><pre class="line-numbers language-none"><code class="language-none">if (!wasActive &amp;&amp; isActive()) &#123;    invokeLater(new Runnable() &#123;        @Override        public void run() &#123;            pipeline.fireChannelActive();        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doBeginRead() throws Exception &#123;    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called    final SelectionKey selectionKey &#x3D; this.selectionKey;    if (!selectionKey.isValid()) &#123;        return;    &#125;    readPending &#x3D; true;    final int interestOps &#x3D; selectionKey.interestOps();    &#x2F;&#x2F; 如果ServerSocketChannel没有关注Accept事件    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 则让其关注Accepet事件        &#x2F;&#x2F; readInterestOp 取值是 16        &#x2F;&#x2F; 在 NioServerSocketChannel 创建时初始化        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><pre class="line-numbers language-none"><code class="language-none">final int interestOps &#x3D; selectionKey.interestOps();  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后再设置其感兴趣的事件</p><pre class="line-numbers language-none"><code class="language-none">selectionKey.interestOps(interestOps | readInterestOp);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>各个事件对应的值</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png" alt="img"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><pre class="line-numbers language-none"><code class="language-none">public final class NioEventLoop extends SingleThreadEventLoop &#123;        ...            &#x2F;&#x2F; selector中的selectedKeys是基于数组的    &#x2F;&#x2F; unwrappedSelector中的selectedKeys是基于HashSet的        private Selector selector;    private Selector unwrappedSelector;    private SelectedSelectionKeySet selectedKeys;        ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Thread与TaskQueue</strong></p><pre class="line-numbers language-none"><code class="language-none">public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor &#123;    &#x2F;&#x2F; 任务队列    private final Queue&lt;Runnable&gt; taskQueue;    &#x2F;&#x2F; 线程    private volatile Thread thread;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><pre class="line-numbers language-none"><code class="language-none">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;            ...                   &#x2F;&#x2F; 初始化selector，初始化过程在openSelector中        final SelectorTuple selectorTuple &#x3D; openSelector();        this.selector &#x3D; selectorTuple.selector;        this.unwrappedSelector &#x3D; selectorTuple.unwrappedSelector;&#125;private SelectorTuple openSelector() &#123;    final Selector unwrappedSelector;    try &#123;        &#x2F;&#x2F; 此处等同于 Selector.open()方法        &#x2F;&#x2F; 创建了unwrappedSelector对象        unwrappedSelector &#x3D; provider.openSelector();    &#125; catch (IOException e) &#123;        throw new ChannelException(&quot;failed to open a new selector&quot;, e);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><pre class="line-numbers language-none"><code class="language-none">unwrappedSelector &#x3D; provider.openSelector();  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><pre class="line-numbers language-none"><code class="language-none">private static final class SelectorTuple &#123;    final Selector unwrappedSelector;    final Selector selector;    SelectorTuple(Selector unwrappedSelector) &#123;        this.unwrappedSelector &#x3D; unwrappedSelector;        this.selector &#x3D; unwrappedSelector;    &#125;    &#x2F;**    * 一般调用的是这个构造方法    *&#x2F;    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;        this.unwrappedSelector &#x3D; unwrappedSelector;        this.selector &#x3D; selector;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><pre class="line-numbers language-none"><code class="language-none">private SelectorTuple openSelector() &#123;    final Selector unwrappedSelector;    try &#123;        unwrappedSelector &#x3D; provider.openSelector();    &#125; catch (IOException e) &#123;        throw new ChannelException(&quot;failed to open a new selector&quot;, e);    &#125;    ...        &#x2F;&#x2F; 获得基于数组的selectedKeySet实现    final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();    Object maybeException &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;        @Override        public Object run() &#123;            try &#123;                &#x2F;&#x2F; 通过反射拿到unwrappedSelector中的selectedKeys属性                Field selectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);                Field publicSelectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);                ...                &#x2F;&#x2F; 暴力反射，修改私有属性                Throwable cause &#x3D; ReflectionUtil.trySetAccessible(selectedKeysField, true);                if (cause !&#x3D; null) &#123;                    return cause;                &#125;                cause &#x3D; ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);                if (cause !&#x3D; null) &#123;                    return cause;                &#125;                &#x2F;&#x2F; 替换为基于数组的selectedKeys实现                selectedKeysField.set(unwrappedSelector, selectedKeySet);                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);                return null;            &#125; catch (NoSuchFieldException e) &#123;                return e;            &#125; catch (IllegalAccessException e) &#123;                return e;            &#125;        &#125;    &#125;);    selectedKeys &#x3D; selectedKeySet;        &#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector    return new SelectorTuple(unwrappedSelector,                             new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得基于数组的selectedKeySet实现final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();SelectedSelectionKeySet() &#123;keys &#x3D; new SelectionKey[1024];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><pre class="line-numbers language-none"><code class="language-none">new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selectorreturn new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><pre class="line-numbers language-none"><code class="language-none">public class TestNioEventLoop &#123;    public static void main(String[] args) &#123;        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();        &#x2F;&#x2F; 使用NioEventLoop执行任务        eventLoop.execute(()-&gt;&#123;            System.out.println(&quot;hello&quot;);        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入<code>execute</code>执行任务</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void execute(Runnable task) &#123;    &#x2F;&#x2F; 检测传入的任务是否为空，为空会抛出NullPointerException    ObjectUtil.checkNotNull(task, &quot;task&quot;);    &#x2F;&#x2F; 执行任务    &#x2F;&#x2F; 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true    execute(task, !(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入上述代码的<code>execute</code>方法</p><pre class="line-numbers language-none"><code class="language-none">private void execute(Runnable task, boolean immediate) &#123;    &#x2F;&#x2F; 判断当前线程是否为NIO线程    &#x2F;&#x2F; 判断方法为 return thread &#x3D;&#x3D; this.thread;    &#x2F;&#x2F; this.thread即为NIO线程，首次执行任务时，其为null    boolean inEventLoop &#x3D; inEventLoop();        &#x2F;&#x2F; 向任务队列taskQueue中添加任务    addTask(task);        &#x2F;&#x2F; 当前线程不是NIO线程，则进入if语句    if (!inEventLoop) &#123;        &#x2F;&#x2F; 启动NIO线程的核心方法        startThread();                ...            &#125;    &#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程    if (!addTaskWakesUp &amp;&amp; immediate) &#123;        wakeup(inEventLoop);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入<code>startThread</code>方法</p><pre class="line-numbers language-none"><code class="language-none">private void startThread() &#123;    &#x2F;&#x2F; 查看NIO线程状态是否为未启动    &#x2F;&#x2F; 该if代码块只会执行一次    &#x2F;&#x2F; state一开始的值就是ST_NOT_STARTED    &#x2F;&#x2F; private volatile int state &#x3D; ST_NOT_STARTED;    if (state &#x3D;&#x3D; ST_NOT_STARTED) &#123;        &#x2F;&#x2F; 通过原子属性更新器将状态更新为启动（ST_STARTED）        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;            boolean success &#x3D; false;            try &#123;                &#x2F;&#x2F; 执行启动线程                doStartThread();                success &#x3D; true;            &#125; finally &#123;                if (!success) &#123;                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><pre class="line-numbers language-none"><code class="language-none">private void doStartThread() &#123;    assert thread &#x3D;&#x3D; null;    &#x2F;&#x2F; 创建NIO线程并执行任务    executor.execute(new Runnable() &#123;        @Override        public void run() &#123;            &#x2F;&#x2F; thread即为NIO线程            thread &#x3D; Thread.currentThread();            if (interrupted) &#123;                thread.interrupt();            &#125;            boolean success &#x3D; false;            updateLastExecutionTime();            try &#123;                &#x2F;&#x2F; 执行内部run方法                SingleThreadEventExecutor.this.run();                success &#x3D; true;            &#125;                         ...    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void run() &#123;    int selectCnt &#x3D; 0;    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行    for (;;) &#123;      &#x2F;&#x2F; 执行各种任务   try &#123;            int strategy;            try &#123;                strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());                switch (strategy) &#123;                case SelectStrategy.CONTINUE:                    continue;                case SelectStrategy.BUSY_WAIT:                    &#x2F;&#x2F; fall-through to SELECT since the busy-wait is not supported with NIO                case SelectStrategy.SELECT:                    long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();                    if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;                        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar                    &#125;                    nextWakeupNanos.set(curDeadlineNanos);                    try &#123;                        if (!hasTasks()) &#123;                            strategy &#x3D; select(curDeadlineNanos);                        &#125;                    &#125; finally &#123;                        &#x2F;&#x2F; This update is just to help block unnecessary selector wakeups                        &#x2F;&#x2F; so use of lazySet is ok (no race condition)                        nextWakeupNanos.lazySet(AWAKE);                    &#125;                    &#x2F;&#x2F; fall through                default:                &#125;       &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void run() &#123;    int selectCnt &#x3D; 0;    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行    for (;;) &#123;      &#x2F;&#x2F; 执行各种任务   ...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><pre class="line-numbers language-none"><code class="language-none">case SelectStrategy.SELECT:long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar    &#125;nextWakeupNanos.set(curDeadlineNanos);try &#123;    if (!hasTasks()) &#123;            &#x2F;&#x2F; 执行select方法            strategy &#x3D; select(curDeadlineNanos);        &#125;    &#125;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><pre class="line-numbers language-none"><code class="language-none">private int select(long deadlineNanos) throws IOException &#123;    &#x2F;&#x2F; 如果没有指定阻塞事件，就调用select()    if (deadlineNanos &#x3D;&#x3D; NONE) &#123;        return selector.select();    &#125;    &#x2F;&#x2F; 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞    &#x2F;&#x2F; Timeout will only be 0 if deadline is within 5 microsecs    long timeoutMillis &#x3D; deadlineToDelayNanos(deadlineNanos + 995000L) &#x2F; 1000000L;    return timeoutMillis &lt;&#x3D; 0 ? selector.selectNow() : selector.select(timeoutMillis);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p><p>唤醒是通过execute最后的if代码块来完成的</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程if (!addTaskWakesUp &amp;&amp; immediate) &#123;    wakeup(inEventLoop);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void wakeup(boolean inEventLoop) &#123;    &#x2F;&#x2F; 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒    &#x2F;&#x2F; 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功    if (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) !&#x3D; AWAKE) &#123;        &#x2F;&#x2F; 唤醒被selector.select方法阻塞的NIO线程        selector.wakeup();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><pre class="line-numbers language-none"><code class="language-none">int strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());switch (strategy) &#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>strategy的值由<code>calculateStrategy</code>方法确定</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;    &#x2F;&#x2F; selectSupplier.get() 底层是 selector.selectNow();    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><pre class="line-numbers language-none"><code class="language-none">private final IntSupplier selectNowSupplier &#x3D; new IntSupplier() &#123;    public int get() throws Exception &#123;        return NioEventLoop.this.selectNow();    &#125;&#125;;int selectNow() throws IOException &#123;    return this.selector.selectNow();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void run() &#123;    ...    for(;;)&#123;        ...        &#x2F;&#x2F; 可能发生空轮询，无法阻塞NIO线程        strategy &#x3D; select(curDeadlineNanos);          ...              if(...) &#123;...     &#125; else if (unexpectedSelectorWakeup(selectCnt) )&#123;            &#x2F;&#x2F; 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector            &#x2F;&#x2F; 并将selectCnt重置为0            selectCnt &#x3D; 0;        &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><pre class="line-numbers language-none"><code class="language-none">if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;    &#x2F;&#x2F; The selector returned prematurely many times in a row.    &#x2F;&#x2F; Rebuild the selector to work around the problem.    logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,selectCnt, selector);    &#x2F;&#x2F; 重建selector，将原selector的配置信息传给新selector    &#x2F;&#x2F; 再用新selector覆盖旧selector    rebuildSelector();    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 处理IO事件时间比例，默认为50%final int ioRatio &#x3D; this.ioRatio;&#x2F;&#x2F; 如果IO事件时间比例设置为100%if (ioRatio &#x3D;&#x3D; 100) &#123;    try &#123;        &#x2F;&#x2F; 如果需要去处理IO事件        if (strategy &gt; 0) &#123;            &#x2F;&#x2F; 先处理IO事件            processSelectedKeys();        &#125;    &#125; finally &#123;        &#x2F;&#x2F; Ensure we always run tasks.        &#x2F;&#x2F; 剩下的时间都去处理普通任务和定时任务        ranTasks &#x3D; runAllTasks();    &#125;&#125; else if (strategy &gt; 0) &#123; &#x2F;&#x2F; 如果需要去处理IO事件    &#x2F;&#x2F; 记录处理IO事件前的时间    final long ioStartTime &#x3D; System.nanoTime();    try &#123;        &#x2F;&#x2F; 去处理IO事件        processSelectedKeys();    &#125; finally &#123;        &#x2F;&#x2F; Ensure we always run tasks.        &#x2F;&#x2F; ioTime为处理IO事件耗费的事件        final long ioTime &#x3D; System.nanoTime() - ioStartTime;        &#x2F;&#x2F; 计算出处理其他任务的事件        &#x2F;&#x2F; 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行        ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);    &#125;&#125; else &#123; &#x2F;&#x2F; 没有IO事件需要处理    &#x2F;&#x2F; This will run the minimum number of tasks    &#x2F;&#x2F; 直接处理普通和定时任务    ranTasks &#x3D; runAllTasks(0); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 没有指定执行任务的时间ranTasks &#x3D; runAllTasks();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 比如ioTime为10s，ioRatio为50&#x2F;&#x2F; 那么通过 10*(100-50)&#x2F;50&#x3D;10 计算出其他任务可用的时间为 10s&#x2F;&#x2F; 处理IO事件占用的事件总比例为50%ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 运行最少数量的任务ranTasks &#x3D; runAllTasks(0);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><pre class="line-numbers language-none"><code class="language-none">private void processSelectedKeys() &#123;    &#x2F;&#x2F; 如果selectedKeys是基于数组的    &#x2F;&#x2F; 一般情况下都走这个分支    if (selectedKeys !&#x3D; null) &#123;        &#x2F;&#x2F; 处理各种IO事件        processSelectedKeysOptimized();    &#125; else &#123;        processSelectedKeysPlain(selector.selectedKeys());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>processSelectedKeysOptimized方法</p><pre class="line-numbers language-none"><code class="language-none">private void processSelectedKeysOptimized() &#123;    for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;        &#x2F;&#x2F; 拿到SelectionKeyec        final SelectionKey k &#x3D; selectedKeys.keys[i];        &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363        selectedKeys.keys[i] &#x3D; null;        &#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel        final Object a &#x3D; k.attachment();        if (a instanceof AbstractNioChannel) &#123;            &#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel            processSelectedKey(k, (AbstractNioChannel) a);        &#125; else &#123;            @SuppressWarnings(&quot;unchecked&quot;)            NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;            processSelectedKey(k, task);        &#125;        if (needsToSelectAgain) &#123;            &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363            selectedKeys.reset(i + 1);            selectAgain();            i &#x3D; -1;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><pre class="line-numbers language-none"><code class="language-none">final SelectionKey k &#x3D; selectedKeys.keys[i];  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannelfinal Object a &#x3D; k.attachment();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果附件继承自AbstractNioChannel，则会调用</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannelprocessSelectedKey(k, (AbstractNioChannel) a);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><pre class="line-numbers language-none"><code class="language-none">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();    if (!k.isValid()) &#123;        final EventLoop eventLoop;        try &#123;            eventLoop &#x3D; ch.eventLoop();        &#125; catch (Throwable ignored) &#123;            &#x2F;&#x2F; If the channel implementation throws an exception because there is no event loop, we ignore this            &#x2F;&#x2F; because we are only trying to determine if ch is registered to this event loop and thus has authority            &#x2F;&#x2F; to close ch.            return;        &#125;        &#x2F;&#x2F; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop        &#x2F;&#x2F; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is        &#x2F;&#x2F; still healthy and should not be closed.        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;5125        if (eventLoop &#x3D;&#x3D; this) &#123;            &#x2F;&#x2F; close the channel if the key is not valid anymore            unsafe.close(unsafe.voidPromise());        &#125;        return;    &#125;    try &#123;        int readyOps &#x3D; k.readyOps();        &#x2F;&#x2F; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise        &#x2F;&#x2F; the NIO JDK channel implementation may throw a NotYetConnectedException.        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;            &#x2F;&#x2F; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;924            int ops &#x3D; k.interestOps();            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;            k.interestOps(ops);            unsafe.finishConnect();        &#125;        &#x2F;&#x2F; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;            &#x2F;&#x2F; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write            ch.unsafe().forceFlush();        &#125;        &#x2F;&#x2F; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead        &#x2F;&#x2F; to a spin loop        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;            unsafe.read();        &#125;    &#125; catch (CancelledKeyException ignored) &#123;        unsafe.close(unsafe.voidPromise());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 阻塞直到事件发生selector.select();Iterator&lt;SelectionKey&gt; iter &#x3D; selector.selectionKeys().iterator();while (iter.hasNext()) &#123;        &#x2F;&#x2F; 拿到一个事件    SelectionKey key &#x3D; iter.next();        &#x2F;&#x2F; 如果是 accept 事件    if (key.isAcceptable()) &#123;                &#x2F;&#x2F; 执行accept，获得SocketChannel        SocketChannel channel &#x3D; serverSocketChannel.accept();        channel.configureBlocking(false);                &#x2F;&#x2F; 将SocketChannel注册到selector中，并关注read事件        channel.register(selector, SelectionKey.OP_READ);    &#125;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><pre class="line-numbers language-none"><code class="language-none">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;unsafe.read();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>NioMessageUnsafe.read</code>方法</p><pre class="line-numbers language-none"><code class="language-none">public void read() &#123;    ...        try &#123;        try &#123;            do &#123;&#x2F;&#x2F; doReadMessages中执行了accept获得了SocketChannel                &#x2F;&#x2F; 并创建NioSocketChannel作为消息放入readBuf                &#x2F;&#x2F; readBuf是一个ArrayList用来缓存消息                &#x2F;&#x2F; private final List&lt;Object&gt; readBuf &#x3D; new ArrayList&lt;Object&gt;();                int localRead &#x3D; doReadMessages(readBuf);                                ...                &#x2F;&#x2F; localRead值为1，就一条消息，即接收一个客户端连接                allocHandle.incMessagesRead(localRead);            &#125; while (allocHandle.continueReading());        &#125; catch (Throwable t) &#123;            exception &#x3D; t;        &#125;        int size &#x3D; readBuf.size();        for (int i &#x3D; 0; i &lt; size; i ++) &#123;            readPending &#x3D; false;            &#x2F;&#x2F; 触发read事件，让pipeline上的handler处理            &#x2F;&#x2F; ServerBootstrapAcceptor.channelRead            pipeline.fireChannelRead(readBuf.get(i));        &#125;                ...            &#125; finally &#123;        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;    &#x2F;&#x2F; 处理accpet事件，获得SocketChannel    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());    try &#123;        if (ch !&#x3D; null) &#123;            &#x2F;&#x2F; 创建了NioSocketChannel，作为消息放在了readBuf中            buf.add(new NioSocketChannel(this, ch));            return 1;        &#125;    &#125; catch (Throwable t) &#123;       ...    &#125;    return 0;&#125;ServerBootstrapAcceptor.channelReadpublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123;    &#x2F;&#x2F; 这时的msg是NioSocketChannel    final Channel child &#x3D; (Channel) msg;    &#x2F;&#x2F; NioSocketChannel添加childHandler，即初始化器    child.pipeline().addLast(childHandler);    &#x2F;&#x2F; 设置选项    setChannelOptions(child, childOptions, logger);    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());    &#125;    try &#123;        &#x2F;&#x2F; 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程        childGroup.register(child).addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture future) throws Exception &#123;                if (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; catch (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><pre class="line-numbers language-none"><code class="language-none">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;        ...    AbstractChannel.this.eventLoop &#x3D; eventLoop;    if (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; else &#123;        try &#123;            &#x2F;&#x2F; 这行代码完成的是nio boss -&gt; nio worker线程的切换            eventLoop.execute(new Runnable() &#123;                @Override                public void run() &#123;                    &#x2F;&#x2F; 真正的注册操作                    register0(promise);                &#125;            &#125;);        &#125; catch (Throwable t) &#123;            ...        &#125;    &#125;&#125;AbstractChannel.AbstractUnsafe.register0private void register0(ChannelPromise promise) &#123;    try &#123;                ...                    &#x2F;&#x2F; 该方法将SocketChannel注册到Selector中        doRegister();                &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail        pipeline.invokeHandlerAddedIfNeeded();        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail        safeSetSuccess(promise);        pipeline.fireChannelRegistered();                if (isActive()) &#123;            if (firstRegistration) &#123;                &#x2F;&#x2F; 触发pipeline上active事件                pipeline.fireChannelActive();            &#125; else if (config().isAutoRead()) &#123;                beginRead();            &#125;        &#125;    &#125; catch (Throwable t) &#123;        closeForcibly();        closeFuture.setClosed();        safeSetFailure(promise, t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doRegister() throws Exception &#123;    boolean selected &#x3D; false;    for (;;) &#123;        try &#123;            &#x2F;&#x2F; 将Selector注册到Selector中            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);            return;        &#125; catch (CancelledKeyException e) &#123;            ...        &#125;    &#125;&#125;HeadContext.channelActivepublic void channelActive(ChannelHandlerContext ctx) &#123;    ctx.fireChannelActive();&#x2F;&#x2F; 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)    readIfIsAutoRead();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><pre class="line-numbers language-none"><code class="language-none">protected void doBeginRead() throws Exception &#123;    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called    final SelectionKey selectionKey &#x3D; this.selectionKey;    if (!selectionKey.isValid()) &#123;        return;    &#125;    readPending &#x3D; true;&#x2F;&#x2F; 这时候 interestOps是0    final int interestOps &#x3D; selectionKey.interestOps();    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 关注read事件        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><pre class="line-numbers language-none"><code class="language-none">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;unsafe.read();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic final void read() &#123;    &#x2F;&#x2F; 获得Channel的配置    final ChannelConfig config &#x3D; config();    if (shouldBreakReadReady(config)) &#123;        clearReadPending();        return;    &#125;    final ChannelPipeline pipeline &#x3D; pipeline();&#x2F;&#x2F; 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）final ByteBufAllocator allocator &#x3D; config.getAllocator();    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();    allocHandle.reset(config);    ByteBuf byteBuf &#x3D; null;    boolean close &#x3D; false;    try &#123;        do &#123;            &#x2F;&#x2F; 创建ByteBuf            byteBuf &#x3D; allocHandle.allocate(allocator);            &#x2F;&#x2F; 读取内容，放入ByteBUf中            allocHandle.lastBytesRead(doReadBytes(byteBuf));            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;                byteBuf.release();                byteBuf &#x3D; null;                close &#x3D; allocHandle.lastBytesRead() &lt; 0;                if (close) &#123;                    readPending &#x3D; false;                &#125;                break;            &#125;            allocHandle.incMessagesRead(1);            readPending &#x3D; false;            &#x2F;&#x2F; 触发read 事件，让pipeline上的handler处理            &#x2F;&#x2F; 这时是处理NioSocketChannel上的handler            pipeline.fireChannelRead(byteBuf);            byteBuf &#x3D; null;        &#125;         &#x2F;&#x2F; 是否要继续循环        while (allocHandle.continueReading());        allocHandle.readComplete();        &#x2F;&#x2F; 触发 read complete事件        pipeline.fireChannelReadComplete();        if (close) &#123;            closeOnRead(pipeline);        &#125;    &#125; catch (Throwable t) &#123;        handleReadException(pipeline, byteBuf, t, close, allocHandle);    &#125; finally &#123;         &#x2F;&#x2F; Check if there is a readPending which was not processed yet.         &#x2F;&#x2F; This could be for two reasons:         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method         &#x2F;&#x2F;         &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2254        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;    return            &#x2F;&#x2F; 一般为true           config.isAutoRead() &amp;&amp;           &#x2F;&#x2F; respectMaybeMoreData默认为true           &#x2F;&#x2F; maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead默认16           totalMessages &lt; maxMessagePerRead &amp;&amp;           &#x2F;&#x2F; 实际读到了数据           totalBytesRead &gt; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记</title>
      <link href="/2021/11/29/springcloud/"/>
      <url>/2021/11/29/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183152316.png" alt="image-20211129183152316"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183232116.png" alt="image-20211129183232116"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183252144.png" alt="image-20211129183252144"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183306276.png" alt="image-20211129183306276"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211129183320178.png" alt="image-20211129183320178"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="SpringBoot父子工程搭建"><a href="#SpringBoot父子工程搭建" class="headerlink" title="SpringBoot父子工程搭建"></a>SpringBoot父子工程搭建</h1><p>参考文档：<a href="https://www.hangge.com/blog/cache/detail_2833.html">https://www.hangge.com/blog/cache/detail_2833.html</a></p><h3 id="1、创建父工程"><a href="#1、创建父工程" class="headerlink" title="1、创建父工程"></a>1、创建父工程</h3><ol><li><p>先使用<strong>Spring Initializr</strong>创建demo的父工程，这边建议使用<a href="https://start.aliyun.com/%E8%80%8C%E4%B8%8D%E6%98%AFhttps://start.spring.io/">https://start.aliyun.com/而不是https://start.spring.io/</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190738996.png"></p><p>在不选择任何依赖的时候，默认的pom文件如下</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-boot.version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-boot.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-boot.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.example.demo.DemoApplication<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按需添加或者删除即可</p></li><li><p>删除工程中不需要的文件，及保留下图对应的文件即可</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121185800439.png" alt="image-20211121185800439"></p><p>只保留：**.idea** 文件夹 、项目 <strong>pom</strong> 文件、以及一个 <em><strong>.iml</strong> 文件，使用git的话，也可保留</em>*.gitignore**文件。</p><p><strong>注意</strong>： 因为父模块只做依赖管理，不需要编写代码，所以 <strong>src</strong> 文件夹可以直接删除。</p></li></ol><h3 id="2、创建子模块"><a href="#2、创建子模块" class="headerlink" title="2、创建子模块"></a>2、创建子模块</h3><ol><li><p>右键父工程，依次创建模块demo-01和demo-02</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211120171956114.png" alt="image-20211120171956114"></p></li><li><p>注意创建的模块所属的父工程</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190038939.png" alt="image-20211121190038939"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190100808.png" alt="image-20211121190100808"></p></li><li><p>删除不需要的文件</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121190007792.png" alt="image-20211121190007792"></p></li></ol><h3 id="3、编辑父工程pom-xml-文件"><a href="#3、编辑父工程pom-xml-文件" class="headerlink" title="3、编辑父工程pom.xml 文件"></a>3、编辑父工程pom.xml 文件</h3><p>将父工程 <strong>pom.xml</strong> 文件修改成如下内容，里面声明该父工程包含的子模块，同时抽取统一的配置信息和依赖版本控制，这样可以方便子 <strong>pom</strong> 直接引用，简化子 <strong>pom</strong> 的配置。</p><blockquote><ul><li>多模块项目中，父模块打包类型必须是pom</li><li>因为开发框架是SpringBoot，夫模块默认继承spring-boot-starter-parent，因此可以删除spring-boot-starter和spring-boot-starter-test（父模块已经包含了）</li></ul></blockquote><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 父模块打包类型必须为pom --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- parent指明继承关系，给出被继承的父项目的具体信息，可以删除spring-boot-starter和spring-boot-starter-test依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 模块说明：这里声明多个子模块 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>demo-01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>demo-02<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--定义版本号的，下面dependencies或者dependencyManagement会引用--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--下面的dependencyManagement引用到的--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-cloud.version</span><span class="token punctuation">></span></span>Hoxton.SR10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-cloud.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--统一父子模块版本用的--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-boot.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--同上--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、编辑子模块pom-xml文件"><a href="#4、编辑子模块pom-xml文件" class="headerlink" title="4、编辑子模块pom.xml文件"></a>4、编辑子模块pom.xml文件</h3><p>子模块的<strong>pom.xml</strong>需要继承本项目的父工程，其中 <strong>parent</strong> 要使用顶层的父模块</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.wzy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 继承本项目的父工程 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--不需要了，引用的父工程的--></span>    &lt;!--<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--引入自己需要的依赖即可--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        ....    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>同上    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-<a href="####%E5%85%B3%E4%BA%8E%E5%AD%90%E5%B7%A5%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E4%BE%9D%E8%B5%96%E4%B8%8D%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9C%AC%E5%8F%B7">关于dependencyManagement和dependencies关系</a></p><h1 id="SpringCloud项目基础搭建"><a href="#SpringCloud项目基础搭建" class="headerlink" title="SpringCloud项目基础搭建"></a>SpringCloud项目基础搭建</h1><h3 id="1、父工程demo-cloud"><a href="#1、父工程demo-cloud" class="headerlink" title="1、父工程demo-cloud"></a>1、父工程demo-cloud</h3><p>创建SpringBoot工程</p><p>删除不需要的文件</p><p>添加配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--依赖的父工程--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-cloud.version</span><span class="token punctuation">></span></span>Hoxton.SR10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-cloud.version</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--先行准备的--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mysql.version</span><span class="token punctuation">></span></span>5.1.47<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mysql.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mybatis.version</span><span class="token punctuation">></span></span>2.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mybatis.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--父工程下的子模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>service-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>service-order<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--必须要的--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- springCloud --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-cloud.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- mysql驱动 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mysql.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!--mybatis--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;mybatis.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、子工程service-user"><a href="#2、子工程service-user" class="headerlink" title="2、子工程service-user"></a>2、子工程service-user</h3><p>创建项目，删除不需要的文件</p><p>添加配置文件，配置文件同service-order</p><p>依次创建包mapper，pojo，service，web包</p><p>pojo.User</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper.UserMapper</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from tb_user where id = #&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>service.UserService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>web.UserController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token comment">/**     * @param id 用户id     * @return 用户     */</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8081spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud_user?charsetEncoding&#x3D;utf8&amp;serverTimeZone&#x3D;UTC&amp;useSSL&#x3D;false    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Drivermybatis:  type-aliases-package: com.wzy.serviceuser.pojo  configuration:    map-underscore-to-camel-case: truelogging:  level:    cn.itcast: debug  pattern:    dateformat: MM-dd HH:mm:ss:SSS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、子工程service-order"><a href="#3、子工程service-order" class="headerlink" title="3、子工程service-order"></a>3、子工程service-order</h3><p>创建项目，删除不需要的文件</p><p>添加配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.wzy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>service-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>service-user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-boot.version</span><span class="token punctuation">></span></span>2.3.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-boot.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--mybatis--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">></span></span>app<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依次创建包mapper，pojo，service，web包</p><p>mapper.OrderMapper</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">OrderMapper</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from tb_order where id = #&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token class-name">Order</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>pojo.Order</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> num<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> userId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">User</span> user<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pojo.User</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>service.OrderService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">OrderMapper</span> orderMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.查询订单</span>        <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.利用RestTemplate发起http请求，查询用户</span>        <span class="token comment">// 2.1.url路径</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/user/"</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.2.发送http请求，实现远程调用</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3.封装user到Order</span>        order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4.返回</span>        <span class="token keyword">return</span> order<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>web.OrderController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"order"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">OrderService</span> orderService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"&#123;orderId&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderByUserId</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"orderId"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 根据id查询订单并返回</span>        <span class="token keyword">return</span> orderService<span class="token punctuation">.</span><span class="token function">queryOrderById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ServiceOrderApplication</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.wzy.serviceorder.mapper"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceOrderApplication</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ServiceOrderApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 创建RestTemplate并注入Spring容器     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//添加负载均衡</span>    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8088spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud_order?charsetEncoding&#x3D;utf8&amp;serverTimeZone&#x3D;UTC&amp;useSSL&#x3D;false    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver  application:    name: service-ordermybatis:  type-aliases-package: com.wzy.serviceorder.pojo  configuration:    map-underscore-to-camel-case: truelogging:  level:    cn.itcast: debug  pattern:    dateformat: MM-dd HH:mm:ss:SSS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="SpringCloud-1"><a href="#SpringCloud-1" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a>.</p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211120141319992.png" alt="image-20211120141319992"></p><h3 id="消费者和提供者"><a href="#消费者和提供者" class="headerlink" title="消费者和提供者"></a>消费者和提供者</h3><ul><li>服务提供者:一次业务中，被其它微服务调用的服务。(提供接口给其它微服务)</li><li>服务消费者:一次业务中，调用其它微服务的服务。(调用其它微服务提供的接口)</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211120163221429.png" alt="image-20211120163221429"></p><blockquote><p>Q:服务A调用服务B，服务B调用服务C，那么服务B是什么角色?</p><p>A:既是服务提供者也是服务消费者</p></blockquote><p><strong>服务调用关系</strong></p><ul><li>服务提供者:暴露接口给其它微服务调用</li><li>服务消费者:调用其它微服务提供的接口</li><li>提供者与消费者角色其实是相对的</li><li>一个服务可以同时是服务提供者和服务消费者</li></ul><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><h3 id="eureka搭建"><a href="#eureka搭建" class="headerlink" title="eureka搭建"></a>eureka搭建</h3><ol><li><p>创建项目</p><p>eureka-server模块</p></li><li><p>导入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--父工程如果引入了cloud的依赖，版本号不用声明--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意cloud和boot版本的对应关系,版本对应不上会出现下面的异常</p><p>Failed to process import candidates for configuration class [com.wzy.EurekaApplication]; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</p></li><li><p>编写启动类，添加@EnableEurekaServer注解</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaApplication.class, args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加application.yml文件，编写下面的配置</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8082spring:  application:    name: eurekaserver # 服务名称，配置文件中的服务名称如果改了，记得改类里面的服务路径eureka:  client:    service-url: #erueka的地址信息      defaultZone: http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;eureka  #自己注册自己，配置集群时，让其他的注册中心发现自己<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>输入<a href="http://127.0.0.1:8082/eureka">http://127.0.0.1:8082/eureka</a></p><p><img src="C:\Users\WZY\AppData\Roaming\Typora\typora-user-images\image-20211121115007279.png" alt="image-20211121115007279"></p></li></ol><h3 id="eureka注册"><a href="#eureka注册" class="headerlink" title="eureka注册"></a>eureka注册</h3><p>将service-order和service-user注册到注册中心</p><ol><li><p>service-order和service-user添加依赖，不同于eureka-server模块的依赖，这里添加的是客户端依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--eureka客户端依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加配置</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  application:    name: eurekaserver # 服务名称eureka:  client:    service-url: #erueka的地址信息      defaultZone: http:&#x2F;&#x2F;127.0.0.1:8082&#x2F;eureka  #向eureka注册中心注册自己的服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动服务就可以在注册中心看到实例了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121120356620.png" alt="image-20211121120356620"></p></li></ol><h3 id="单机模拟多实例"><a href="#单机模拟多实例" class="headerlink" title="单机模拟多实例"></a>单机模拟多实例</h3><p>可以在Services看到web项目</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121134043848.png" alt="image-20211121134043848"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121133834174.png" alt="image-20211121133834174"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121133950988.png" alt="image-20211121133950988"></p><h3 id="eureka拉取服务"><a href="#eureka拉取服务" class="headerlink" title="eureka拉取服务"></a>eureka拉取服务</h3><p>在service-order中完成服务的拉取</p><ol><li><p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡</p><p><code>String url = &quot;http://SERVICE-USER/user/&quot; + order.getUserId();</code></p></li><li><p>在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@LoadBalanced</span> <span class="token comment">//添加负载均衡</span><span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><h3 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a>负载均衡流程</h3><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121141123680.png" alt="image-20211121141123680"></p><p><strong>@LoadBalanced //添加负载均衡</strong>，RestTemplate发起的http请求被Ribbon拦截到</p><p>那么是如何被拦截的呢？</p><p>首先看下面这个拦截器类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadBalancerInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">ClientHttpRequestInterceptor</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个拦截器实现了ClientHttpRequestInterceptor接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 拦截客户端发出的HTTP请求 * Intercepts client-side HTTP requests. Implementations of this interface can be * &#123;@linkplain org.springframework.web.client.RestTemplate#setInterceptors registered&#125; * with the &#123;@link org.springframework.web.client.RestTemplate RestTemplate&#125;, * as to modify the outgoing &#123;@link ClientHttpRequest&#125; and/or the incoming * &#123;@link ClientHttpResponse&#125;. */</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ClientHttpRequestInterceptor</span> <span class="token punctuation">&#123;</span><span class="token class-name">ClientHttpResponse</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span> <span class="token class-name">ClientHttpRequestExecution</span> execution<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoadBalancerInterceptor实现了intercept方法，从而拦截了RestTemplate发起的http请求</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ClientHttpResponse</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">HttpRequest</span> request<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">,</span><span class="token keyword">final</span> <span class="token class-name">ClientHttpRequestExecution</span> execution<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span><span class="token keyword">final</span> <span class="token class-name">URI</span> originalUri <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> serviceName <span class="token operator">=</span> originalUri<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>serviceName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">"Request URI does not contain a valid hostname: "</span> <span class="token operator">+</span> originalUri<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadBalancer<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>requestFactory<span class="token punctuation">.</span><span class="token function">createRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> body<span class="token punctuation">,</span> execution<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>URI处打上断点</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121141719952.png" alt="image-20211121141719952"></p><p>查看request，可以看到RestTemplate发出的请求</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121141856908.png" alt="image-20211121141856908"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142035836.png" alt="image-20211121142035836"></p><p>获取服务名称SERVICE-USER</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142121571.png" alt="image-20211121142121571"></p><p>开始接触Ribbon负载均衡客户端</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142214668.png" alt="image-20211121142214668"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142241897.png" alt="image-20211121142241897"></p><p>获取服务，观察loadBalancer对象，loadBalancer中会有获取到的服务列表。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142621585.png" alt="image-20211121142621585"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//代码解释</span><span class="token class-name">ILoadBalancer</span> loadBalancer <span class="token operator">=</span> <span class="token function">getLoadBalancer</span><span class="token punctuation">(</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>从注册中心获取服务列表<span class="token class-name">Server</span> server <span class="token operator">=</span> <span class="token function">getServer</span><span class="token punctuation">(</span>loadBalancer<span class="token punctuation">,</span> hint<span class="token punctuation">)</span><span class="token punctuation">;</span>做负载均衡，选择一个服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121142833812.png" alt="image-20211121142833812"></p><p>进入方法，可以看见正在选择服务</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143154496.png" alt="image-20211121143154496"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143257174.png" alt="image-20211121143257174"></p><p>开始选择负载均衡的规则，可以看到选择的是ZoneAvoidanceRule</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143341683.png" alt="image-20211121143341683"></p><p>观察这个rule对象，是IRule类型的对象，查看IRule的实现类，可以看见常见的负载均衡策略</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143709371.png" alt="image-20211121143709371"></p><p>继续向下就可以看到拿到8083的服务了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121143843066.png" alt="image-20211121143843066"></p><h4 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a><strong>整体流程图</strong></h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121145253232.png" alt="image-20211121145253232"></p><h3 id="Ribbon负载均衡-1"><a href="#Ribbon负载均衡-1" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h3><h4 id="Ribbon中的负载均衡类"><a href="#Ribbon中的负载均衡类" class="headerlink" title="Ribbon中的负载均衡类"></a>Ribbon中的负载均衡类</h4><p>Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121154441429.png" alt="image-20211121154441429"></p><table><thead><tr><th>内置负载均衡规则类</th><th>规则描述</th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略:<br/>(1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。<br/>(2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<br/><clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>weightedResponseTimeRule</td><td>每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td>zoneAvoidanceRule</td><td>为以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。（平常使用是没有Zone这个概念的，相当于RoundRobin）</td></tr><tr><td>BestAvailableRule</td><td>忽略哪些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><h4 id="调整负载均衡策略"><a href="#调整负载均衡策略" class="headerlink" title="调整负载均衡策略"></a>调整负载均衡策略</h4><p>通过定义IRule实现可以修改负载均衡规则，有两种方式:</p><p>1.代码方式，在service-order中配置类中，定义一个新的IRule</p><p>作用于全局，无论调用那个微服务都是这个策略</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic IRule randomRule() &#123;    return new RandomRule();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.配置文件方式，在application.yml中，添加新的配置来修改规则</p><p>这种是针对某个微服务的</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">userservice:  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbanlancer.RandomRule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Ribbon饥饿加载"><a href="#Ribbon饥饿加载" class="headerlink" title="Ribbon饥饿加载"></a>Ribbon饥饿加载</h3><p>Ribbon默认是采用懒加载，即第一次访问时（请求经过LoadBalancerInterceptor拦截器处理））才会去创建LoadBalanceClient，请求</p><p>时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">ribbon:  eager-load:    enabled: true #开启饥饿加载    clients: SERVICE-USER #指定对SERVICE-USER这个服务饥饿加载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>Nacos官网<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></p><h3 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h3><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161304634.png" alt="image-20211121161304634"></p><h4 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h4><ol><li><p>GitHub下载</p><p><a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161825178.png" alt="image-20211121161825178"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161757603.png" alt="image-20211121161757603"></p><ol start="2"><li><p>解压，目录结构</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121161917330.png" alt="image-20211121161917330"></p></li><li><p>修改配置问价</p><p>如果8848端口被占用，去conf目录下修改配置文件</p></li><li><p>启动</p><ul><li>双击启动</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121162008190.png" alt="image-20211121162008190"></p><ul><li>windwos命令行启动</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">startup.cmd -m standaloner #单机模式启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>启动效果</strong></p><p><img src="C:\Users\WZY\AppData\Roaming\Typora\typora-user-images\image-20211121164825447.png" alt="image-20211121164825447"></p><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p>界面，账号密码都是nacos</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121165215491.png" alt="image-20211121165215491"></p><p>控制台</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121165457590.png" alt="image-20211121165457590"></p></li></ol><blockquote><p>Q:Nacos启动报错：java.io.IOException: java.lang.IllegalArgumentException: db.num is null</p><p>A:：Notepad++打开<code>startup.cmd</code>文件</p><p>修改27行的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span><span class="token string">"cluster"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span><span class="token string">"standalone"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说把启动模式从<strong>集群</strong>改为<strong>单机</strong></p></blockquote><h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><p>Linux或者Mac安装方式与Windows类似。</p><p><strong>安装JDK</strong></p><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xvf jdk-8u144-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重命名为java</p><p>配置环境变量：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;javaexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置环境变量：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">source &#x2F;etc&#x2F;profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>上传安装包</strong></p><p>如图：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210402161102887.png" alt="image-20210402161102887"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402163715580.png" alt="image-20210402163715580"></p><p><strong>解压</strong></p><p>命令解压缩安装包：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xvf nacos-server-1.4.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后删除安装包：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">rm -rf nacos-server-1.4.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录中最终样式：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day01-SpringCloud01\资料\assets\image-20210402164414827.png" alt="image-20210402164414827"></p><p><strong>端口配置</strong></p><p>与windows中类似</p><p><strong>启动</strong></p><p>在nacos/bin目录中，输入命令启动Nacos：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sh startup.sh -m standalone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Nacos使用"><a href="#Nacos使用" class="headerlink" title="Nacos使用"></a>Nacos使用</h3><h4 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a>服务注册到Nacos</h4><ol><li><p>父工程demo-cloud添加spring-cloud-alilbaba的管理依赖:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注释掉service-order和service-user中原有的eureka依赖。</p></li><li><p>添加nacos的客户端依赖:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- nacos客户端依赖包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>service-order和service-user添加配置，注掉eureka的配置，ribbon等配置不需要注掉，因为是通用的</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring: #nacos配置是spring下的  cloud:    nacos:      server-addr: localhost:8848  #nacos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>注册界面</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121171845744.png" alt="image-20211121171845744"></p><h3 id="Nacos服务分级存储模型"><a href="#Nacos服务分级存储模型" class="headerlink" title="Nacos服务分级存储模型"></a>Nacos服务分级存储模型</h3><p><strong>Nacos服务分级</strong></p><ul><li><p>一级是服务，例如service</p></li><li><p>二级是集群，例如杭州或上海</p></li><li><p>三级是实例，例如杭州机房的某台部署了service的服务器</p></li></ul><p>图示</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121194712839.png" alt="image-20211121194712839"></p><h4 id="服务集群调用问题"><a href="#服务集群调用问题" class="headerlink" title="服务集群调用问题"></a>服务集群调用问题</h4><p>服务调用尽可能选择本地集群的服务，跨集群调用延迟较高</p><p>本地集群不可访问时，再去访问其它集群</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121200229569.png" alt="image-20211121200229569"></p><h4 id="服务集群属性"><a href="#服务集群属性" class="headerlink" title="服务集群属性"></a>服务集群属性</h4><p><strong>设置服务集群属性</strong></p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  cloud:nacos:  server-addr: localhost:8848 # nacos服务端地址  discovery:   cluster-name: HZ #配置集群名称，也就是机房位置，例如:HZ，杭州<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Nacos控制台可以看到集群的变化</strong></p><p>这里配置了service-user的集群</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121195759746.png" alt="image-20211121195759746"></p><p>这里配置了service-order的集群</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121203637993.png" alt="image-20211121203637993"></p><p>但是我们多次访问<a href="http://localhost:8088/order/103%EF%BC%8C%E5%8F%91%E7%8E%B0%E4%B8%89%E4%B8%AAservice-user%E5%AE%9E%E4%BE%8B%E9%83%BD%E4%BC%9A%E8%A2%AB%E8%AE%BF%E9%97%AE%E5%88%B0%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82">http://localhost:8088/order/103，发现三个service-user实例都会被访问到，而不是访问本地集群的服务。</a></p><p>这时就需要在service-order中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">userservice:  ribbon:NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRlue#负载均衡规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在多次访问，service-order会在本地集群中找service-user服务随机访问，不是轮询访问。即确定了可用实例列表后，再采用随机负载均衡挑选实例。</p><p>当HZ集群的service-user实例服务全部挂掉，会发生什么呢？红色表示服务已经挂掉</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121204756763.png" alt="image-20211121204756763"></p><p>此时HZ集群的service-order会发生跨集群访问，去存在服务实例的SH集群去调用服务。并且会报警告</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121205021701.png"></p><h4 id="根据权重负载均衡"><a href="#根据权重负载均衡" class="headerlink" title="根据权重负载均衡"></a>根据权重负载均衡</h4><p>实际部署中会出现这样的场景:</p><p>​        服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求</p><p>Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高</p><p><strong>实例的权重控制</strong></p><p>Nacos控制台可以设置实例的权重值，0~1之间</p><p>同集群内的多个实例，权重越高被访问的频率越高</p><p>权重设置为0则完全不会被访问</p><p><strong>Nacos设置权重</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121205804446.png" alt="image-20211121205804446"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121205829508.png" alt="image-20211121205829508"></p><h3 id="Nacos环境隔离"><a href="#Nacos环境隔离" class="headerlink" title="Nacos环境隔离"></a>Nacos环境隔离</h3><p>在微服务体系中，一个系统往往被拆分为多个服务，每个服务都有自己的配置文件，然后每个系统往往还会准备开发环境、测试环境、正</p><p>式环境。</p><p>我们来说算一算，假设某系统有10个微服务，那么至少有10个配置文件吧，三个环境（dev\test\prod），那就有30个配置文件需要进行</p><p>管理。</p><p>这么多的配置文件，要修改一个或者多个的时候，稍有不慎可能就会出现改错了、不生效…等等问题。</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121215104767.png" alt="image-20211121215104767" style="zoom:50%;" /><p>Nacos引入了命名空间(Namespace)的概念来进行多环境配置和服务的管理及隔离</p><p>Namespace也是官方推荐的多环境支持方案。</p><h5 id="如何进行配置和服务的管理、隔离"><a href="#如何进行配置和服务的管理、隔离" class="headerlink" title="如何进行配置和服务的管理、隔离"></a>如何进行配置和服务的管理、隔离</h5><p>当我们的服务达到一定的数量，集中式的管理许多服务会十分不便，</p><p>那我们可以将这些具有相同特征或属性的服务进行分组管理，服务对应的配置也进行分组隔离</p><p>这里的分组就是Namespace的概念，将服务和配置纳入相同的Namespace进行管理</p><p>不同Namespace下的服务和配置之间就隔离开来,<strong>不同namespace下的服务不可见</strong>。</p><h5 id="创建和获取NamespaceID，并配置"><a href="#创建和获取NamespaceID，并配置" class="headerlink" title="创建和获取NamespaceID，并配置"></a>创建和获取NamespaceID，并配置</h5><p>每个namespace都有唯一id</p><p>NamespaceId值是在配置文件配置时必须要填入的配置项，所以需要我们先创建Namespace和Id，步骤如下：</p><ul><li>可以发现默认都在public命名空间下，nacos 的控制台左边功能栏看到有一个命名空间的功能，点击就可以看到新建命名空间的按钮</li></ul><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121214312716.png" alt="image-20211121214312716"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121214236492.png" alt="image-20211121214236492"></p><ul><li><p>新建成功后，可以在命名空间列表中查看到你所创建的Namespace和他生成的ID值<br><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121214341349.png" alt="image-20211121214341349"></p></li><li><p>service-order项目中引入,在application中添加namespace</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">server:  port: 8088spring:  datasource:    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud_order?charsetEncoding&#x3D;utf8&amp;serverTimeZone&#x3D;UTC&amp;useSSL&#x3D;false    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver  application:    name: service-order  cloud:    nacos:      server-addr: localhost:8848  #nacos      discovery:        cluster-name: HZ #配置集群名称，也就是机房位置，例如:HZ，杭州        namespace: 774391eb-8c2d-41a9-bc57-71f913f3c61d #测试用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重启service-order后，我们可以在dev命名空间下看到，此时已经和public命名空间下的服务实例隔离开了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211121215526967.png" alt="image-20211121215526967"></p></li></ul><h3 id="Nacos注册中心细节"><a href="#Nacos注册中心细节" class="headerlink" title="Nacos注册中心细节"></a>Nacos注册中心细节</h3><p><img src="C:\Users\WZY\AppData\Roaming\Typora\typora-user-images\image-20211122141427597.png" alt="image-20211122141427597"></p><h4 id="设置临时实例和非临时实例"><a href="#设置临时实例和非临时实例" class="headerlink" title="设置临时实例和非临时实例"></a>设置临时实例和非临时实例</h4><p>服务注册到Nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  cloud:nacos:    discovery :ephemeral: false #设置为非临时实例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h3><h4 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122143228584.png" alt="image-20211122143228584"></p><h5 id="将配置交给Nacos管理的步骤"><a href="#将配置交给Nacos管理的步骤" class="headerlink" title="将配置交给Nacos管理的步骤"></a>将配置交给Nacos管理的步骤</h5><ol><li>在Nacos中添加配置文件</li><li>在微服务中引入nacos的config依赖</li><li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件</li></ol><h5 id="Nacos创建配置"><a href="#Nacos创建配置" class="headerlink" title="Nacos创建配置"></a>Nacos创建配置</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122153954495.png" alt="image-20211122153954495"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122153933324.png" alt="image-20211122153933324"></p><h5 id="Nacos配置和本地配置的区别"><a href="#Nacos配置和本地配置的区别" class="headerlink" title="Nacos配置和本地配置的区别"></a>Nacos配置和本地配置的区别</h5><p><strong>本地配置</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122143903440.png" alt="image-20211122143903440"></p><p><strong>Nacos配 置</strong></p><p>把读取nacos的流程加入其中</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122143937200.png" alt="image-20211122143937200"></p><p>但是存在问题，Nacos注册中心的配置在本地的application.yml中，怎样发现注册中心呢？</p><p>我们把和Nacos相关的配置放到<strong>bootstrap.yml</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122144233551.png" alt="image-20211122144233551"></p><h5 id="服务添加配置"><a href="#服务添加配置" class="headerlink" title="服务添加配置"></a>服务添加配置</h5><ol><li><p>引入Nacos的配置管理客户端依赖:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在service-user中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml</p><p>注意要将application.yml中的相同配置删除掉</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> serviceuser <span class="token comment"># 服务名称</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev <span class="token comment">#开发环境，这里是dev</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment">#Nacos地址</span>      <span class="token key atrule">config</span><span class="token punctuation">:</span>        <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yaml <span class="token comment">#文件后缀名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加新方法，测试能否读取到我们添加的配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;pattern.dateformat&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/now"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>dateformat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="配置自动更新"><a href="#配置自动更新" class="headerlink" title="配置自动更新"></a>配置自动更新</h4><p>Nacos中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现:·</p><h5 id="方式一-在-Value注入的变量所在类上添加注解-RefreshScope"><a href="#方式一-在-Value注入的变量所在类上添加注解-RefreshScope" class="headerlink" title="方式一:在@Value注入的变量所在类上添加注解@RefreshScope"></a>方式一:在@Value注入的变量所在类上添加注解@RefreshScope</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150454113.png" alt="image-20211122150454113"></p><p>效果如下</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150701932.png" alt="image-20211122150701932"><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150713697.png" alt="image-20211122150713697"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150737481.png" alt="image-20211122150737481"><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122150746134.png" alt="image-20211122150746134"></p><h5 id="方式二-使用-ConfigurationProperties注解"><a href="#方式二-使用-ConfigurationProperties注解" class="headerlink" title="方式二:使用@ConfigurationProperties注解"></a>方式二:使用@ConfigurationProperties注解</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"pattern"</span><span class="token punctuation">)</span><span class="token comment">//prefix和变量名拼接，只要配置文件中有一致的，就自动完成注入</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122151632876.png" alt="image-20211122151632876"></p><h4 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h4><h5 id="微服务启动时会从nacos读取多个配置文件"><a href="#微服务启动时会从nacos读取多个配置文件" class="headerlink" title="微服务启动时会从nacos读取多个配置文件:"></a>微服务启动时会从nacos读取多个配置文件:</h5><ul><li><p>[spring.application.name]-[spring.profiles.active].yaml，例如: userservice-dev.yaml</p></li><li><p>[spring.application.name].yaml，例如: service-user.yaml</p></li></ul><p>无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件。</p><p>这里service-user会读取下面两个nacos配置</p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122154259638.png" alt="image-20211122154259638" style="zoom:50%;" /><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122154411447.png" style="zoom:50%;" /><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122154055151.png" alt="image-20211122154055151"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>service-user中添加要读取的配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"pattern"</span><span class="token punctuation">)</span><span class="token comment">//prefix和变量名拼接，只要配置文件中有一致的，就自动完成注入</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> envSharedValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//UserController</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">PatternProperties</span> <span class="token function">getPatternProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> patternProperties<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别以dev和test环境启动俩个实例</p><p><strong>如何在不修改配置文件的情况下修改启动环境</strong></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122152915159.png" alt="image-20211122152915159"></p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122153018887.png" alt="image-20211122153018887" style="zoom:50%;" /><p>查看启动的两个实例</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122155248715.png" alt="image-20211122155248715"></p><h3 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h3><h4 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h4><p>官方给出的Nacos集群图：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day02-SpringCloud02\资料\assets\image-20210409210621117.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210409211355037.png" alt="image-20210409211355037"></p><h4 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h4><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h5 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h5><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'content'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'md5'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">COMMENT</span> <span class="token string">'source user'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'source ip'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>c_desc<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>c_use<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>effect<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">type</span><span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>c_schema<span class="token punctuation">`</span> <span class="token keyword">text</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfo_datagrouptenant<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_info'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_info_aggr   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info_aggr<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>datum_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'datum_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'内容'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfoaggr_datagrouptenantdatum<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>datum_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'增加租户字段'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_info_beta   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info_beta<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'app_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'content'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>beta_ips<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'betaIps'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'md5'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">COMMENT</span> <span class="token string">'source user'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'source ip'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfobeta_datagrouptenant<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_info_beta'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_info_tag   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_info_tag<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tag_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tag_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'app_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'content'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'md5'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span> <span class="token keyword">COMMENT</span> <span class="token string">'source user'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'source ip'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configinfotag_datagrouptenanttag<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tag_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_info_tag'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = config_tags_relation   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>config_tags_relation<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tag_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tag_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tag_type<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tag_type'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'data_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'group_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>nid<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>nid<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_configtagrelation_configidtag<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tag_name<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tag_type<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_tenant_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'config_tag_relation'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = group_capacity   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>group_capacity<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键ID'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'Group ID，空字符表示整个集群'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>quota<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'配额，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">usage</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'聚合子配置最大个数，，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_history_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'最大变更历史数量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_group_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>group_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'集群、各Group容量信息表'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = his_config_info   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>his_config_info<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>nid<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>data_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>group_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>app_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'app_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">longtext</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>md5<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_user<span class="token punctuation">`</span> <span class="token keyword">text</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>src_ip<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>op_type<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'租户字段'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>nid<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_gmt_create<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_gmt_modified<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_did<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>data_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'多租户改造'</span><span class="token punctuation">;</span><span class="token comment">/******************************************/</span><span class="token comment">/*   数据库全名 = nacos_config   */</span><span class="token comment">/*   表名称 = tenant_capacity   */</span><span class="token comment">/******************************************/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tenant_capacity<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键ID'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'Tenant ID'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>quota<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'配额，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">usage</span><span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'使用量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'聚合子配置最大个数'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_aggr_size<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>max_history_count<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'最大变更历史数量'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_tenant_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'租户容量信息表'</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>tenant_info<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>kp<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'kp'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_id'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_name'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>tenant_desc<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'tenant_desc'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>create_source<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'create_source'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_create<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>gmt_modified<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'修改时间'</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uk_tenant_info_kptenantid<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>kp<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_tenant_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>tenant_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8_bin <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'tenant_info'</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>users<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span><span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>enabled<span class="token punctuation">`</span> <span class="token keyword">boolean</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>roles<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>role<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>idx_user_role<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">ASC</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>role<span class="token punctuation">`</span> <span class="token keyword">ASC</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>permissions<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>role<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>resource<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span><span class="token keyword">action</span><span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>uk_role_permission<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>role<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>resource<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span><span class="token keyword">action</span><span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> enabled<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'nacos'</span><span class="token punctuation">,</span> <span class="token string">'$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu'</span><span class="token punctuation">,</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> roles <span class="token punctuation">(</span>username<span class="token punctuation">,</span> role<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'nacos'</span><span class="token punctuation">,</span> <span class="token string">'ROLE_ADMIN'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h5><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.2版本：</p><p><img src="E:\BaiduNetdiskDownload\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\实用篇\学习资料\day02-SpringCloud02\资料\assets\image-20210409212119411.png" alt="image-20210409212119411"></p><h5 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h5><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122164216637.png" alt="image-20211122164216637"></p><p>然后添加内容：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:8844127.0.0.1.8846127.0.0.1.8848<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后修改application.properties文件，添加数据库配置，去掉注释即可</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">spring.datasource.platform</span><span class="token punctuation">=</span><span class="token attr-value">mysql</span><span class="token attr-name">db.num</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token attr-name">db.url.0</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><span class="token attr-name">db.user.0</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">db.password.0</span><span class="token punctuation">=</span><span class="token attr-value">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h5><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20210409213335538.png" alt="image-20210409213335538"> </p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8844</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nacos2:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8846</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nacos3:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8848</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后分别启动三个nacos节点：</p><pre class="line-numbers language-none"><code class="language-none">startup.cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h5><p> <img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122164804563.png" alt="image-20211122164804563"></p><p>解压到任意非中文目录下：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122164750397.png" alt="image-20211122164750397"> </p><p>修改conf/nginx.conf文件，在http {}下添加，配置如下：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> nacos-cluster</span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8844</span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8846</span><span class="token punctuation">;</span><span class="token directive"><span class="token keyword">server</span> 127.0.0.1:8848</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>    <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">80</span></span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">server_name</span>  localhost</span><span class="token punctuation">;</span>    <span class="token directive"><span class="token keyword">location</span> /nacos</span> <span class="token punctuation">&#123;</span>        <span class="token directive"><span class="token keyword">proxy_pass</span> http://nacos-cluster</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">80</span> <span class="token comment"># Nacos地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h5><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul><h2 id="Nacos和Eureka区别"><a href="#Nacos和Eureka区别" class="headerlink" title="Nacos和Eureka区别"></a>Nacos和Eureka区别</h2><h3 id="Nacos与eureka的共同点"><a href="#Nacos与eureka的共同点" class="headerlink" title="Nacos与eureka的共同点"></a>Nacos与eureka的共同点</h3><p>都支持服务注册和服务拉取</p><p>都支持服务提供者心跳方式做健康检测</p><h3 id="Nacos与Eureka的区别"><a href="#Nacos与Eureka的区别" class="headerlink" title="Nacos与Eureka的区别"></a><strong>Nacos与Eureka的区别</strong></h3><p>Nacos支持服务端主动检测提供者状态:临时实例采用心跳模式，非临时实例采用主动检测模式（会消耗服务器资源）</p><p>临时实例心跳不正常会被剔除，非临时实例则不会被剔除（会等到实例恢复）</p><p>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p><p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式;Eureka采用AP方式</p><h2 id="HTTP客户端Feign"><a href="#HTTP客户端Feign" class="headerlink" title="HTTP客户端Feign"></a>HTTP客户端Feign</h2><h3 id="Feign替代RestTemplate"><a href="#Feign替代RestTemplate" class="headerlink" title="Feign替代RestTemplate"></a>Feign替代RestTemplate</h3><h4 id="RestTemplate方式调用存在的问题"><a href="#RestTemplate方式调用存在的问题" class="headerlink" title="RestTemplate方式调用存在的问题"></a>RestTemplate方式调用存在的问题</h4><p>先来看我们以前利用RestTemplate发起远程调用的代码:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122170842824.png" alt="image-20211122170842824"></p><p>存在下面的问题:</p><ul><li><p>代码可读性差，编程体验不统一</p></li><li><p>参数复杂URL难以维护</p></li></ul><h4 id="Feign介绍"><a href="#Feign介绍" class="headerlink" title="Feign介绍"></a>Feign介绍</h4><p>Feign是一个声明式的http客户端，官方地址: https:/ /github.com/OpenFeign/feign其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122171112369.png" alt="image-20211122171112369"></p><h4 id="定义和使用Feign客户端"><a href="#定义和使用Feign客户端" class="headerlink" title="定义和使用Feign客户端"></a>定义和使用Feign客户端</h4><p>Feign的使用步骤</p><p>1.引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.添加@EnableFeignClients注解</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122185520894.png" alt="image-20211122185520894"></p><p>3.编写FeignClient接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"serviceuser"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/&#123;id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是基于SpringMVC的注解来声明远程调用的信息，比如:</p><ul><li><p>服务名称: userservice</p></li><li><p>请求方式:GET</p></li><li><p>请求路径: /user/{id}</p></li><li><p>请求参数:Long id</p></li><li><p>返回值类型:User</p></li></ul><p>4.使用Feignclient中定义的方法代替RestTemplate</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">UserClient</span> userClient<span class="token punctuation">;</span><span class="token comment">//使用Feign发请求</span><span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 1.查询订单</span>    <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.使用Feign发请求</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3.封装user到Order</span>    order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4.返回</span>    <span class="token keyword">return</span> order<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><h4 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h4><p>Feign运行自定义配置来覆盖默认配置，可以修改的配置如下:</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>feign.Logger.Level</td><td>修改日志级别</td><td>包含四种不同的级别:NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign.Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试，feign底层依赖ribbon</td></tr></tbody></table><h4 id="配置Feign日志"><a href="#配置Feign日志" class="headerlink" title="配置Feign日志"></a>配置Feign日志</h4><p>Feign的自定义配置，用到的最多的就是日志配置</p><p>配置Feign日志有两种方式:</p><ul><li><p>方式一:配置文件方式</p><p>全局生效:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment">#日志级别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>局部生效</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment">#日志级别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置Feign日志的方式二: java代码方式，需要先声明一个Bean:</p><p>bean上没有@Configuration注解，需要按照下面的方式让bean生效</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFeignConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span> <span class="token function">logLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span><span class="token punctuation">.</span>BASIC<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后如果是全局配置，则把它放到@EnableFeignClients这个注解中:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是局部配置，则把它放到@FeignClient这个注解中:这里只针对serviceuser这个服务</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"serviceuser"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="Feign优化使用"><a href="#Feign优化使用" class="headerlink" title="Feign优化使用"></a>Feign优化使用</h3><p>因此优化Feign的性能主要包括</p><p>使用连接池代替默认的URLConnection（使用线程池来减少线程创建和销毁时带来的资源消耗）</p><p>日志级别，最好用basic或none（日志内容太多也会消耗资源）</p><h4 id="Feign客户端优化"><a href="#Feign客户端优化" class="headerlink" title="Feign客户端优化"></a>Feign客户端优化</h4><p><strong>Feign底层的客户端实现:</strong></p><p>URLConnection:默认实现，不支持连接池</p><p>Apache HttpClient :支持连接池</p><p>OKHttp:支持连接池</p><p><strong>使用HttpClient</strong> </p><ol><li><p>引入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--httpClient的依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置连接池</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> BASIC <span class="token comment">#日志级别，BASIC就是基本的请求和响应信息</span>  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#开启feign对HttpClient的支持</span>    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">200</span> <span class="token comment">#最大的连接数</span>    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50</span> <span class="token comment">#每个路径的最大连接数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="方式一（继承）"><a href="#方式一（继承）" class="headerlink" title="方式一（继承）"></a>方式一（继承）</h4><p>给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122200440093.png" alt="image-20211122200440093"></p><h4 id="方式二（抽取"><a href="#方式二（抽取" class="headerlink" title="方式二（抽取)"></a>方式二（抽取)</h4><p>将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122200515495.png" alt="image-20211122200515495" style="zoom:80%;" /><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122200531476.png" alt="image-20211122200531476"></p><p>实现最佳实践方式二的步骤如下:</p><p>1．首先创建一个module，命名为feign-client，然后引入feign的starter依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--feign客户端--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2．将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中,删除掉service-order中的UserClient、User、DefaultFeignConfiguration</p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122203107489.png" alt="image-20211122203107489" style="zoom:67%;" /><p>3．在order-service中引入feign-api的依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--引入feign的统一api--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4．修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包</p><p>5．重启测试</p><p>6．发现问题</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211122204711888.png" alt="image-20211122204711888"></p><p>UserClient属于外部引入的包，Spring默认扫描的是和启动类同级的目录，Spring容器中找不到，我们添加外部的扫描即可；</p><p>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决:</p><p>方式一:指定FeignClient所在包</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.wzy.feign.client"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二︰指定FeignClient字节码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>clients <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token class-name">UserClient</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h2><h3 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h3><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123154958199.png" alt="image-20211123154958199"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123155007912.png" alt="image-20211123155007912"></p><h4 id="网关功能"><a href="#网关功能" class="headerlink" title="网关功能:"></a>网关功能:</h4><ul><li><p>身份认证和权限校验</p></li><li><p>服务路由、负载均衡</p></li><li><p>请求限流，</p></li></ul><h4 id="网关的技术实现"><a href="#网关的技术实现" class="headerlink" title="网关的技术实现"></a>网关的技术实现</h4><p>在SpringCloud中网关的实现包括两种:</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloud Gateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h3 id="Gateway快速入门"><a href="#Gateway快速入门" class="headerlink" title="Gateway快速入门"></a>Gateway快速入门</h3><h4 id="搭建网关服务"><a href="#搭建网关服务" class="headerlink" title="搭建网关服务"></a>搭建网关服务</h4><p>1.创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖（Gateway从nacos拉取服务列表）:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- nacos客户端依赖包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- gateway网关依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.编写路由配置及nacos地址</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10010</span> <span class="token comment">#网关端口</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway <span class="token comment">#服务名称</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span> <span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">80</span> <span class="token comment">#nacos地址</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>user           <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//serviceuser           <span class="token key atrule">predicates</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>         <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>order          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//service<span class="token punctuation">-</span>order          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> Path=/order/<span class="token important">**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置参数routes，可以是数组</p><ul><li>id：路由id，自定义，只要唯一即可</li><li>uri：路由的目标地址<ul><li>http就是固定地址     http:/ /127.0.0.2:8881  </li><li>lb就是负载均街，后面跟服务名称    lb://serviceuser</li></ul></li><li>predicates: 路由断言，也就是判断请求是否符合路由规则的条件<ul><li>Path=/user/** 这个是按照路径匹配，只要以/user/开头就符合要求，就会匹配到//serviceuser/user/**路径下</li></ul></li><li>filters：路由过滤器，对请求或响应做处理</li></ul><h4 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123164245348.png" alt="image-20211123164245348"></p><h3 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h3><h4 id="路由断言工厂Route-Predicate-Factory"><a href="#路由断言工厂Route-Predicate-Factory" class="headerlink" title="路由断言工厂Route Predicate Factory"></a>路由断言工厂Route Predicate Factory</h4><ul><li>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</li><li>例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的</li><li>像这样的断言工厂在SpringCloudGateway还有十几个</li></ul><h4 id="Predicate工厂"><a href="#Predicate工厂" class="headerlink" title="Predicate工厂"></a>Predicate工厂</h4><p>Spring提供了11种基本的Predicate工厂:</p><p>官网：<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories</a></p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>- Before=2031-04-13T15:14:47.433+08:OO[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denverj</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=x-Request-ld,\d+</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名)</td><td>- Host=<em>.somehost.org,”</em>.anotherhost.org</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment}. /blue/*</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=narne,Jack或者- Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1,24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><h3 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h3><h4 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h4><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理:</p><p>请求在网关经历了什么</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123171321338.png" alt="image-20211123171321338"></p><p>过滤器是链式的</p><h4 id="Spring提供的过滤器工厂"><a href="#Spring提供的过滤器工厂" class="headerlink" title="Spring提供的过滤器工厂"></a>Spring提供的过滤器工厂</h4><p>官网：<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories</a></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr></tbody></table><p><strong>示例</strong></p><p>给所有进入serviceuser的请求添加一个请求头:Truth=freaking awesome!</p><p>实现方式:在gateway中修改application.yml文件，给serviceuser的路由添加过滤器:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>user           <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//serviceuser           <span class="token key atrule">predicates</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>           <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment">#过速器</span>              <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span>freaking awesome<span class="token tag">!</span> <span class="token comment">#添加请求头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="默认过滤器DefaultFilter"><a href="#默认过滤器DefaultFilter" class="headerlink" title="默认过滤器DefaultFilter"></a>默认过滤器DefaultFilter</h4><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment">#网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>user           <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//serviceuser           <span class="token key atrule">predicates</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>       <span class="token key atrule">default-filters</span><span class="token punctuation">:</span> <span class="token comment">#默认过滤器，会对所有的路由请求都生效</span>      <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span>freaking awesome<span class="token tag">!</span> <span class="token comment">#添加请求头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>前面了解的都是局部的过滤器和默认过滤器</p><h4 id="全局过滤器GlobalFilter"><a href="#全局过滤器GlobalFilter" class="headerlink" title="全局过滤器GlobalFilter"></a>全局过滤器GlobalFilter</h4><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter默认过滤器的作用一样。</p><p>区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现，做一些业务的判断。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 处理当前请求，有必要的话通过 &#123;@link GatewayFilterChain&#125;     *     * 将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息*     * @param chain 用来把请求委托给下一个过滤器     * @return &#123;@code Mono&lt;Void>&#125;返回标示当前过滤嚣业务结束     */</span>    <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span><span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>过滤authorization不等于admin的用户请求</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorizeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.获取请求</span>        <span class="token class-name">ServerHttpRequest</span> request <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取请求中的authorization参数</span>        <span class="token class-name">MultiValueMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> params <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> auth <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.判断参数值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//4.放行，交由下一个exchange去处理</span>            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//5.设置响应状态码</span>        exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span><span class="token class-name">HttpStatus</span><span class="token punctuation">.</span>UNAUTHORIZED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//6.拦截请求</span>        <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h4><p>请求进入网关会碰到三类过滤器:当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合)中，排序后依次执行每个过滤器</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123190334075.png" alt="image-20211123190334075"></p><ul><li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。<ul><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li></ul></li><li>当过滤器的order值一样时，会按照defaultFilter &gt;路由过滤器&gt;GlobalFilter的顺序执行。</li></ul><p>可以参考下面几个类的源码来查看:</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123192610791.png" alt="image-20211123192610791"></p><p><strong>关于为什么过滤器会放在一个集合里</strong></p><p>按道理一个集合中数据类型应该相同，但是Gateway会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中。这是因为当前路由过滤器和DefaultFilter都是在配置文件中定义，AddRequestHeaderGatewayFilterFactory这个类会加载配置文件，生成真正的路由器，返回的是GatewayFilter。GlobalFilter是通过适配器适配成GatewayFilter的。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123192035213.png" alt="image-20211123192035213"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123192306559.png" alt="image-20211123192306559"></p><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p><a href="###%E4%BD%95%E4%B8%BA%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">跨域问题</a></p><p>跨域:域名不一致就是跨域，主要包括:</p><ul><li><p>域名不同: <a href="http://www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com/">www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com</a></p></li><li><p>域名相同，端口不同: localhost:8080和localhost8081</p></li></ul><p>跨域问题:<strong>浏览器禁止</strong>请求的发起者与服务端发生<strong>跨域ajax请求</strong>，请求被浏览器拦截的问题</p><p>解决方案: <strong><a href="###%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88CORS">CORS</a></strong></p><p>网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现:</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span> <span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span> <span class="token comment">#。。 o</span>      <span class="token key atrule">globalcors</span><span class="token punctuation">:</span> <span class="token comment">#全局的跨域处理</span>        <span class="token key atrule">add-to-simple-url-handler-mapping</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#解决options请求被拦截问题,浏览器会发一个option类型的请求去询问服务器是否可以访问，但是网关是会拦截options请求的，true表示不拦截</span>        <span class="token key atrule">corsConfigurations</span><span class="token punctuation">:</span>          <span class="token key atrule">'[/**]'</span><span class="token punctuation">:</span>  <span class="token comment">#拦截那些请求，这里表示拦截所有</span>            <span class="token key atrule">allowed0rigins</span><span class="token punctuation">:</span> <span class="token comment">#允许哪些网站的跨域请求</span>              <span class="token punctuation">-</span> <span class="token string">"http://localhost:8090"</span>            <span class="token key atrule">allowedMethods</span><span class="token punctuation">:</span> <span class="token comment">#允许的跨域ajax的请求方式</span>            <span class="token punctuation">-</span> <span class="token string">"GET"</span>            <span class="token punctuation">-</span> <span class="token string">"POST"</span>            <span class="token punctuation">-</span> <span class="token string">"DELETE"</span>            <span class="token punctuation">-</span> <span class="token string">"PUT"</span>            <span class="token punctuation">-</span> <span class="token string">"OPTIONS"</span>            <span class="token key atrule">allowedHeaders</span><span class="token punctuation">:</span> “<span class="token important">*"</span> <span class="token comment">#允许在请求中携带的头信息</span>            <span class="token key atrule">allowCredentials</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#是否允许携带cookie</span>            <span class="token key atrule">maxAge</span><span class="token punctuation">:</span> <span class="token number">360000</span> <span class="token comment">#这次跨域检测的有效期,有效期内不校验直接放行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="关于子工程为什么有些依赖不需要添加版本号"><a href="#关于子工程为什么有些依赖不需要添加版本号" class="headerlink" title="关于子工程为什么有些依赖不需要添加版本号"></a>关于子工程为什么有些依赖不需要添加版本号</h3><p>可以参考文章<a href="https://www.jianshu.com/p/c8666474cf9a">https://www.jianshu.com/p/c8666474cf9a</a></p><p><strong>父工程</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- springCloud --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring-cloud.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>子工程</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变</p><p>更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中</p><p>声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p><strong>dependencyManagement与dependencies区别：</strong></p><p>1)Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。</p><p>2)dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继</p><p>承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版</p><p>本号，那么会使用子项目中指定的jar版本。</p><h3 id="何为跨域问题"><a href="#何为跨域问题" class="headerlink" title="何为跨域问题"></a>何为跨域问题</h3><h4 id="一、为什么会出现跨域问题"><a href="#一、为什么会出现跨域问题" class="headerlink" title="一、为什么会出现跨域问题"></a>一、为什么会出现跨域问题</h4><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h4 id="二、什么是跨域"><a href="#二、什么是跨域" class="headerlink" title="二、什么是跨域"></a>二、什么是跨域</h4><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211123205457040.png" alt="image-20211123205457040">)</p><h4 id="三、非同源限制"><a href="#三、非同源限制" class="headerlink" title="三、非同源限制"></a>三、非同源限制</h4><p>【1】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>【2】无法接触非同源网页的 DOM</p><p>【3】无法向非同源地址发送 AJAX 请求</p><h3 id="跨域问题解决方案CORS"><a href="#跨域问题解决方案CORS" class="headerlink" title="跨域问题解决方案CORS"></a>跨域问题解决方案CORS</h3><p>参考文档：<a href="https://zhuanlan.zhihu.com/p/24411090">https://zhuanlan.zhihu.com/p/24411090</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Nacos </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo&amp;Zookeeper</title>
      <link href="/2021/11/18/dubbo-zookeeper/"/>
      <url>/2021/11/18/dubbo-zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>传统项目和互联网项目的区别</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114143831649.png" alt="image-20211114143831649"></p><h3 id="大型互联网项目架构的目标"><a href="#大型互联网项目架构的目标" class="headerlink" title="大型互联网项目架构的目标"></a>大型互联网项目架构的目标</h3><h5 id="衡量网站的性能指标"><a href="#衡量网站的性能指标" class="headerlink" title="衡量网站的性能指标"></a>衡量网站的性能指标</h5><ul><li>响应时间: 指执行一个请求从开始到最后收到响应数据所花费的总体时间。</li><li>并发数:指系统同时能处理的请求数量。<ul><li>并发连接数:指的是客户端向服务器发起请求，并建立了TCP连接。每秒钟服务器连接的总TCP数量（一次链接可能有多个请求，一次链接也可能复用）</li><li>请求数:也称为QPS(Query Per Second)指每秒多少请求.</li><li>并发用户数:单位时间内有多少用户</li></ul></li><li>吞吐量:指单位时间内系统能处理的请求数量。<ul><li>QPS: Query Per Second每秒查询数。</li><li>TPS: Transactions Per Second每秒事务数。</li><li>一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。（比如点击一个链接，当这个链接的全部请求都已经到位时，表示一个事务结束）</li><li>一个页面的一次访问，只会形成一个TPS;但一次页面请求，可能产生多次对服务器的请求，就会有多个QPS<br>QPS &gt;= 并发连接数&gt;=TPS</li></ul></li><li>高性能:提供快速的访问体验。</li><li>高可用:网站服务一直可以正常访问。</li><li>可伸缩:通过硬件增加/减少，提高/降低处理能力。</li><li>高可扩展:系统间耦合低，方便的通过新增/移除方式，增加/减少新的功能/模块。</li><li>安全性:提供网站安全访问和数据加密，安全存储等策略。。</li><li>敏捷性:随需应变，快速响应。</li></ul><h3 id="分布式和集群"><a href="#分布式和集群" class="headerlink" title="分布式和集群"></a>分布式和集群</h3><ul><li><p>集群:很多“人”一起，干一样的事。</p><p>一个业务模块，部署在多台服务器上（完整的一个项目）。</p></li><li><p>分布式:很多“人”一起，干不一样的事。这些不一样的事，合起来是一件大事。</p><p>一个大的业务系统，拆分为小的业务模块，分别部署在不同的机器上。</p></li></ul><p>集群和分布式是并存的</p><p>单机系统</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211110205317868.png" alt="image-20211110205317868"></p><p>集群系统</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211110205430647.png" alt="image-20211110205430647"></p><p>缺点是：不好做扩展，不方便伸缩（配置新的机器）</p><p>集群加分布式</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211110205557256.png" alt="image-20211110205557256"></p><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>官网 ： <a href="https://dubbo.apache.org/zh/">https://dubbo.apache.org/zh/</a></p><p>官方文档：<a href="https://dubbo.apache.org/zh/docs/introduction/">https://dubbo.apache.org/zh/docs/introduction/</a></p><h4 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211111154928311.png" alt="image-20211111154928311"></p><p>节点说明</p><ul><li>Provider:暴露服务的服务提供方.</li><li>Container:服务运行容器</li><li>Consumer:调用远程服务的服务消费方</li><li>Registry:服务注册与发现的注册中心</li><li>Monitor:统计服务的调用次数和调用时间的监控中心</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h4><p> 使用Maven创建SpringMvc项目</p><p>1.创建空项目</p><p>2.创建两个module</p><p>导入相关依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- servlet3.0规范的坐标 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--spring的坐标--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--springmvc的坐标--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;spring.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--日志--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-log4j12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--Dubbo的起步依赖，版本2.7之后统一为rg.apache.dubb --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dubbo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;dubbo.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--ZooKeeper客户端实现 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.curator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>curator-framework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;zookeeper.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--ZooKeeper客户端实现 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.curator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>curator-recipes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>$&#123;zookeeper.version&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--dubbo-web模块需要的依赖--></span>    <span class="token comment">&lt;!--依赖service模块--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.wzy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dubbo-service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--tomcat插件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat.maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat7-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>8000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>path</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-编写配置文件"><a href="#2-编写配置文件" class="headerlink" title="2.编写配置文件"></a>2.编写配置文件</h4><p>log4j属于公共配置</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span><span class="token comment"># Global logging configuration</span><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">info, stdout,file</span><span class="token comment"># My logging configuration...</span><span class="token comment">#log4j.logger.com.tocersoft.school=DEBUG</span><span class="token comment">#log4j.logger.net.sf.hibernate.cache=debug</span><span class="token comment">## Console output...</span><span class="token attr-name">log4j.appender.stdout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%5p %d %C: %m%n</span><span class="token attr-name">log4j.appender.file</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.FileAppender</span><span class="token attr-name">log4j.appender.file.File</span><span class="token punctuation">=</span><span class="token attr-value">../logs/iask.log</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">%d&#123;yyyy-MM-dd HH:mm:ss&#125;  %l  %m%n</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dubbo-service模块</p><p>spring/springmvc.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>dubbo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://dubbo.apache.org/schema/dubbo<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd         http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--开启注解--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dubbo-web模块</p><p>spring/springmvc.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>dubbo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://dubbo.apache.org/schema/dubbo<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd         http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!--开启组件扫描--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wzy.controller<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-编写业务"><a href="#3-编写业务" class="headerlink" title="3.编写业务"></a>3.编写业务</h4><p>dubbo-service模块：业务模块用来提供各种业务，会被打成jar包的形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"hello dubbo"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dubbo-web模块:业务调用模块</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/sayHello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-启动项目"><a href="#4-启动项目" class="headerlink" title="4.启动项目"></a>4.启动项目</h4><p>dubbo-service模块：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211111211013061.png" alt="image-20211111211013061"></p><p>dubbo-web模块:启动使用tomcat插件进行启动</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211111211045941.png" alt="image-20211111211045941"></p><blockquote><p>Q:Failed to execute goal org.apache.tomcat.maven:tomcat7-maven-plugin:2.2:run (default-cli) on project</p><p>A:在pom文件的依赖中，一定要加上scope属性</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211111211251972.png" alt="image-20211111211251972"></p></blockquote><h4 id="5-改造"><a href="#5-改造" class="headerlink" title="5.改造"></a>5.改造</h4><p>当前项目的两个模块仍然是相互以来的，要改造成通过dubbo关联的项目，以下面这种形式。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211112100726397.png" alt="image-20211112100726397"></p><blockquote><p>dubbo-service</p></blockquote><p>引入tomcat插件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--tomcat插件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat.maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat7-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>9000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>path</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加Web配置，同dubbo-web的配置，去掉mvc的配置即可</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- spring --></span><span class="token comment">&lt;!--用来扫描配置文件，加载配置文件--></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath*:spring/applicationContext*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在配置文件中添加dubbo配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--dubbo的配置--></span><span class="token comment">&lt;!--1.配置项目的名称,唯一--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-service<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--2.配置注册中心的地址--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>registry</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zookeeper://127.0.0.1:2181<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--3.配置dubbo包扫描--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>annotation</span> <span class="token attr-name">package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.itheima.service.impl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将impl实现类的@Service注解换位dubbo的@Service注解</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import org.apache.dubbo.config.annotation.Service;&#x2F;&#x2F;dubbo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dubbo-web</p></blockquote><p>controller中的service不再是通过本地的方式调用，而是改为通过rpc的形式调用</p><p>使用@Reference注解</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;注入Service&#x2F;&#x2F;@Autowired&#x2F;&#x2F;本地注入&#x2F;*    1. 从zookeeper注册中心获取userService的访问url    2. 进行远程调用RPC    3. 将结果封装为一个代理对象。给变量赋值 *&#x2F;@Reference&#x2F;&#x2F;远程注入private UserService userService;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>dubbo-interface</p></blockquote><p>将接口提取为公共的api，去掉dubbo-web和dubbo-service的中定义的接口，而是通过导入dubbo-interface模块的方式进行调用声明</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211112104624651.png" alt="image-20211112104624651"></p><h3 id="安装dubbo-admin工具"><a href="#安装dubbo-admin工具" class="headerlink" title="安装dubbo-admin工具"></a>安装dubbo-admin工具</h3><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><p>dubbo-admin管理平台，是图形化的服务管理页面</p><p>从注册中心中获取到所有的提供者/消费者进行配置管理</p><p>路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能</p><p>dubbo-admin是一个前后端分离的项目。前端使用vue，后端使用springboot</p><p>安装 dubbo-admin其实就是部署该项目</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>1、环境准备</p><p>dubbo-admin 是一个前后端分离的项目。前端使用vue，后端使用springboot，安装 dubbo-admin 其实就是部署该项目。我们将dubbo-admin安装到开发环境上。要保证开发环境有jdk，maven，nodejs</p><p>安装node(如果当前机器已经安装请忽略)</p><p>因为前端工程是用vue开发的，所以需要安装node.js，node.js中自带了npm，后面我们会通过npm启动</p><p>2、下载 Dubbo-Admin</p><p>进入github，搜索dubbo-admin</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;dubbo-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1578297063167.png" alt="1578297063167"></p><p>3、把下载的zip包解压到指定文件夹(解压到那个文件夹随意)</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1578297477356.png" alt="1578297477356"></p><p>4、修改配置文件</p><p>解压后我们进入…\dubbo-admin-develop\dubbo-admin-server\src\main\resources目录，找到 application.properties 配置文件 进行配置修改</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/1578297603008.png" alt="1578297603008"></p><p>修改zookeeper地址</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/1578297758655.png" alt="1578297758655"></p><p>admin.registry.address注册中心<br>admin.config-center 配置中心<br>admin.metadata-report.address元数据中心</p><p>5、打包项目</p><p>在 dubbo-admin-develop 目录执行打包命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mvn  clean package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211113135059894.png" alt="image-20211113135059894"></p><p>6、启动后端</p><p>切换到目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">dubbo-Admin-develop\dubbo-admin-distribution\target&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行下面的命令启动 dubbo-admin，dubbo-admin后台由SpringBoot构建。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">java -jar .\dubbo-admin-0.1.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、前台后端</p><p>dubbo-admin-ui 目录下执行命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211113135623086.png" alt="image-20211113135623086"></p><p>8、访问</p><p>浏览器输入。用户名密码都是root</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8081&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211113135647602.png" alt="image-20211113135647602"></p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="先行：在不创建新的模块的情况下，模拟集群"><a href="#先行：在不创建新的模块的情况下，模拟集群" class="headerlink" title="先行：在不创建新的模块的情况下，模拟集群"></a>先行：在不创建新的模块的情况下，模拟集群</h4><p>修改下面两处的端口号即可</p><pre class="line-numbers language-none"><code class="language-none">&lt;dubbo:protocol port&#x3D;&quot;20882&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;dubbo:application name&#x3D;&quot;dubbo-service&quot;&gt;   &lt;dubbo:parameter key&#x3D;&quot;qos.port&quot; value&#x3D;&quot;11111&quot;&#x2F;&gt;&lt;&#x2F;dubbo:application&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p> 创建新的模块dubbo-pojo，模块内容是provider和consumer之间传输的对象，也是comsumer模块和provider模块需要共同依赖的部分。</p><p>必须实现Serializable接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@datapublic</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1.maven的依赖范围 scope<br>共 5 种依赖范围 , compile (编译) , test (测试) , runtime (运行时) , provided , system<br>不指定 , 则依赖范围默认为 compile</p><p>compile : (编译依赖范围) , 在编译 , 测试 , 运行/打包时都会使用这个依赖</p><p>test : (测试依赖范围) , 测试时会使用 , 编译 和 运行/打包 不使用 , 如 Junit</p><p>runtime : (运行时依赖范围) , 测试 和 运行/打包 时需要 , 编译不需要 , 如 JDBC 驱动包</p><p>provided : (已提供依赖范围) , 编译 和 测试时需要 , 运行/打包 时不需要 , 如 servlet-api</p><p>system : (系统依赖范围) , 本地依赖 , 不在 maven 中央仓库 , 从参与度来说也 provided 相同 , 不过被依赖项不会从 maven 仓库抓 , 而是从本地文件系统拿 , 一定需要配合 systemPath 属性使用</p><p>当 maven 依赖本地而非 repository 中的 jar 包 , sytemPath 指明本地 jar 包路径</p><p><strong>依赖传递(Transitive Dependencies)</strong></p><p>依赖传递(Transitive Dependencies)是Maven 2.0开始的提供的特性，依赖传递的好处是不言而喻的，可以让我们不需要去寻找和发现所必须依赖的库，而是将会自动将需要依赖的库帮我们加进来。</p><p>例如A依赖了B，B依赖了C和D，那么你就可以在A中，像主动依赖了C和D一样使用它们。并且传递的依赖是没有数量和层级的限制的，非常方便。</p><p>但依赖传递也不可避免的会带来一些问题，例如：<br>- 当依赖层级很深的时候，可能造成循环依赖(cyclic dependency)<br>- 当依赖的数量很多的时候，依赖树会非常大</p><p><a href="https://zhuanlan.zhihu.com/p/34427614">maven</a></p></blockquote><h4 id="地址缓存"><a href="#地址缓存" class="headerlink" title="地址缓存"></a>地址缓存</h4><p>Q:注册中心挂了，服务是否可以正常访问?</p><ul><li>可以，因为dubbo服务消费者在第一次调用时,会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。</li><li>当服务提供者地址发生变化时，注册中心会通知服务消费者。</li></ul><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211113215035749.png" alt="image-20211113215035749"></p><p>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。</p><p>在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩。</p><p>dubbo利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。使用timeout属性配</p><p>置超时时间，默认值1000，单位毫秒。</p><h5 id="程序模拟请求超时"><a href="#程序模拟请求超时" class="headerlink" title="程序模拟请求超时"></a>程序模拟请求超时</h5><p>dubbo-service(provider)</p><p>模拟请求时长为5秒，超时时长为3秒，重试0次。超时时长和重试次数在@Service注解上定义</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">,</span>retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//超时时长三秒，重试0次public class UserServiceImpl implements UserService &#123;    @Override    public String sayHello() &#123;        return "hello dubbo hello!~";    &#125;    @Override    public User findUserById(int id) &#123;        //模拟超时        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        User user = new User(1, "zhangsan", "123456");        return user;    &#125;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dubbo-web(consumer)</p><p>服务消费方也可以定义超时时长和超时次数，且会覆盖服务提供方定义的超时时长和超时次数。但是推荐在服务提供方处定义，服务提供方是知道请求的大致时长的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Reference</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">(</span>consumer <span class="token operator">></span> provider<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/find"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//开启异步，看看何时会出现异常        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true) &#123;                    System.out.println(i++);                &#125;            &#125;        &#125;).start();        return userService.findUserById(id);    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h4><p>设置了超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</p><p>如果出现网络抖动，则这一次请求就会失败。</p><p>Dubbo提供重试机制来避免类似问题的发生。</p><p>通过retries属性来设置重试次数。默认为2次。</p><h4 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h4><p>老版本</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114133943645.png" alt="image-20211114133943645"></p><p>灰度发布:当出现新功能时，会让一部分用户先使用新功能</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211114134006514.png" alt="image-20211114134006514"></p><p>用户反馈没问题时，再将所有用户迁移到新功能。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114133747272.png" alt="image-20211114133747272"></p><p>dubbo中使用version属性来设置和调用同一个接口的不同版本</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>dubbo-service</p><p>服务提供方添加新的实现，并且定义版本号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"v2.0"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dubbo-web</p><p>服务消费方选择不同版本的实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Reference</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"v2.0"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="复制均衡"><a href="#复制均衡" class="headerlink" title="复制均衡"></a>复制均衡</h4><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 <code>random</code> 随机调用。</p><p>具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出</p><p>需要将请求提交到哪个 Provider 实例。</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/loadbalance/">官方文档</a></p><p>负载均衡策略(4种):</p><ul><li><p>Random:按权重随机，默认值。按权重设置随机概率</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114140324573.png" alt="image-20211114140324573"></p></li><li><p>RoundRobin:按权重轮询。</p><p><img src="D:\Typoramd\Dubbo&zookeeper\Dubbo&zookeeper.assets\image-20211114140324573.png" alt="image-20211114140324573"></p></li><li><p>LeastActive:最少活跃调用数，相同活跃数的随机。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114140249825.png" alt="image-20211114140249825"></p></li><li><p>ConsistentHash:一致性Hash，相同参数的请求<br>总是发到同一提供者。</p><p><img src="D:\Typoramd\Dubbo&zookeeper\Dubbo&zookeeper.assets\image-20211114140113741.png?lastModify=1637231698" alt="image-20211114140113741"></p></li></ul><h4 id="集群容错模式"><a href="#集群容错模式" class="headerlink" title="集群容错模式"></a>集群容错模式</h4><p>集群调用失败时，Dubbo 提供的容错方案</p><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><a href="https://dubbo.apache.org/zh/docs/advanced/fault-tolerent-strategy/">官方文档</a></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114141233035.png" alt="image-20211114141233035"></p><p>集群容错模式</p><p>Failover Cluster</p><p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)。</p><p>Failfast Cluster</p><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><p>Failsafe Cluster</p><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><p>Failback Cluster</p><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><p>Forking Cluster</p><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p><p>Broadcast Cluster</p><p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><p>向注册中心写入动态配置覆盖规则：</p><ul><li><p><code>mock=force:return null</code> 表示消费方对该服务的方法调用都直接返回 null 值，不</p><p>发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</p></li><li><p>还可以改为 <code>mock=fail:return null</code> 表示消费方对该服务的方法调用在失败后，再</p><p>返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Reference</span><span class="token punctuation">(</span>mock <span class="token operator">=</span> <span class="token string">"force:return null"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><p>文档：<a href="https://zookeeper.readthedocs.io/zh/latest/intro.html">https://zookeeper.readthedocs.io/zh/latest/intro.html</a></p><p><a href="http://www.dba.cn/book/zookeeper/ZOOKEEPERZhongWenShouCe/ZOOKEEPERCLI.html">http://www.dba.cn/book/zookeeper/ZOOKEEPERZhongWenShouCe/ZOOKEEPERCLI.html</a></p><p>总结的很好的zookeeper文档：<a href="https://xiaoxiami.gitbook.io/zookeeper/">https://xiaoxiami.gitbook.io/zookeeper/</a></p><h3 id="ZK简介"><a href="#ZK简介" class="headerlink" title="ZK简介"></a>ZK简介</h3><p>Zookeeper是 Apache Hadoop项目下的一个子项目，是一个树形目录服务。</p><p>Zookeeper翻译过来就是动物园管理员，他是用来管Hadoop(大象)、Hive(蜜蜂)、Pig(小猪)的管理员。简称zk</p><p>Zookeeper是一个分布式的、开源的分布式应用程序的协调服务。</p><p>Zookeeper提供的主要功能包括:</p><pre><code>        配置管理        分布式锁        集群管理</code></pre><h3 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h3><h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>1、环境准备</p><p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p><p>2、上传</p><p>将下载的ZooKeeper放到/opt/ZooKeeper目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#打开 opt目录cd &#x2F;opt#创建zooKeeper目录mkdir  zooKeeper#上传zookeeper xftp上传到Linux服务器opt&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.6-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Q:xftp上传出现错误，没有权限向opt目录传文件</p><p>A:修改文件权限即可 chmod 777 zookeeper/</p></blockquote><p>3、解压</p><p>将tar包解压到/opt/zookeeper目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h5><p>1、配置zoo.cfg</p><p>进入到conf目录拷贝一个zoo_sample.cfg并完成配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#进入到conf目录cd &#x2F;opt&#x2F;zooKeeper&#x2F;apache-zooKeeper-3.5.6-bin&#x2F;conf&#x2F;#拷贝cp  zoo_sample.cfg  zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改zoo.cfg</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#打开目录cd &#x2F;opt&#x2F;zooKeeper&#x2F;#创建zooKeeper存储目录mkdir  zkdata#修改zoo.cfgvim &#x2F;opt&#x2F;zooKeeper&#x2F;apache-zooKeeper-3.5.6-bin&#x2F;conf&#x2F;zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1577548250377.png" alt="1577548250377"></p><p>修改存储目录：dataDir=/opt/zookeeper/zkdata</p><p>2、启动ZooKeeper</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;opt&#x2F;zooKeeper&#x2F;apache-zooKeeper-3.5.6-bin&#x2F;bin&#x2F;#启动 .&#x2F;zkServer.sh  start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/kisstt/typora/raw/master/image/1577548052037.png" alt="1577548052037"></p><p>看到上图表示ZooKeeper成功启动</p><p>3、查看ZooKeeper状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.&#x2F;zkServer.sh status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>zookeeper启动成功。standalone代表zk没有搭建集群，现在是单节点</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1577548175232.png" alt="1577548175232"></p><p>zookeeper没有启动</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/1577548112773.png" alt="1577548112773"></p><blockquote><p>Q:./zkServer.sh status</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;&#x2F;usr&#x2F;bin&#x2F;javaZooKeeper JMX enabled by defaultUsing config: &#x2F;opt&#x2F;zookeeper&#x2F;apache-zookeeper-3.7.0-bin&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfgClient port found: 2181. Client address: localhost. Client SSL: false.Error contacting service. It is probably not running.#zookeeper未正常启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;.&#x2F;zkServer.sh start-foreground  查看日志输出<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;Unable to start AdminServer, exiting abnormallyorg.apache.zookeeper.server.admin.AdminServer$AdminServerException: Problem starting AdminServer on address 0.0.0.0, port 8080 and command URL &#x2F;commandsat org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:179)at org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ZooKeeperServerMain.java:155)at org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun(ZooKeeperServerMain.java:113)at org.apache.zookeeper.server.ZooKeeperServerMain.main(ZooKeeperServerMain.java:68)at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(QuorumPeerMain.java:141)at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain.java:91)Caused by: java.io.IOException: Failed to bind to &#x2F;0.0.0.0:8080at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:349)at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:310)at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:234)at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:73)at org.eclipse.jetty.server.Server.doStart(Server.java:401)at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:73)at org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:170)... 5 moreCaused by: java.net.BindException: Address already in useat sun.nio.ch.Net.bind0(Native Method)at sun.nio.ch.Net.bind(Net.java:461)at sun.nio.ch.Net.bind(Net.java:453)at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:222)at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:85)at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:344)... 12 moreUnable to start AdminServer, exiting abnormally#8080端口被占用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是Zookeeper AdminServer，默认使用8080端口，它的配置属性如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12540413-d5924f70213774e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/882/format/webp" alt="img"></p><p>解决办法：修改端口即可</p><p>我们可以修改在zoo.cfg中修改AdminServer的端口：</p><p>保存后，再次启动，Zookeeper启动成功。</p></blockquote><h4 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h4><p>官网下载，解压，使用7-zip解压为tar，再解压一遍即可</p><p>将conf文件夹的配置文件改为zoo.cfg，并做如下配置</p><pre class="line-numbers language-none"><code class="language-none">tickTime&#x3D;2000               # 最小时间单位, 最小的会话超时为两倍 tickTime,建议设置长一些dataDir&#x3D;..&#x2F;data             # 数据目录, 需要存在且开始的时候为空clientPort&#x3D;2181             # 客户端连接的监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入解压后端zookeeper的bin目录，找到zkServer.cmd启动即可</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211112103019426.png" alt="image-20211112103019426"></p><p>使用zkCli.cmd链接zk服务端，出现下面表示链接成功</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114152013152.png" alt="image-20211114152013152"></p><h3 id="ZooKeeper数据模型"><a href="#ZooKeeper数据模型" class="headerlink" title="ZooKeeper数据模型"></a>ZooKeeper数据模型</h3><ul><li><p>ZooKeeper是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114150412939.png" alt="image-20211114150412939"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/zknamespace.jpg" alt="_images/zknamespace.jpg"></p><p>名字是一个用斜杆(/)分隔的路径元素序列, ZK 中每一个节点(znode)都用路径标识。</p></li><li><p>这里面的每一个节点都被称为:ZNode，和文件系统不同, ZK 中的节点可以拥有数据和子节点。ZK 被设计来存储协调数据: 状态信息、配置、位置信息等, 所以数据通常很小(byte 到 kilobyte 之间)。</p></li><li><p>节点可以分为四大类:</p><ul><li>持久节点（PERSISTENT）<br>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。</li><li>持久顺序节点（PERSISTENT_SEQUENTIAL）<br>这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。<br>在创建节点的时候只需要传入节点 “/test_”，这样之后，zookeeper自动会给”test_”后面补充数字。</li><li>临时节点（EPHEMERAL）<br>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。<br>这里还要注意一件事，就是当你客户端会话失效后，所产生的节点也不是一下子就消失了，也要过一段时间，大概是10秒以内，可以试一下，本机操作生成节点，在服务器端用命令来查看当前的节点数目，你会发现客户端已经stop，但是产生的节点还在。</li><li>临时顺序节点（EPHEMERAL_SEQUENTIAL）<br>此节点是属于临时节点，不过带有顺序，客户端会话结束节点就消失。下面是一个利用该特性的分布式锁的案例流程。<br>(1)客户端调用create()方法创建名为“locknode/<br>guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。<br>(2)客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点，注意，这里不注册任何Watcher。<br>(3)客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点序号最小，那么就认为这个客户端获得了锁。<br>(4)如果在步骤3中发现自己并非所有子节点中最小的，说明自己还没有获取到锁。此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时注册事件监听。<br>(5)之后当这个被关注的节点被移除了，客户端会收到相应的通知。这个时候客户端需要再次调用getChildren(“locknode”)方法来获取所有已经创建的子节点，确保自己确实是最小的节点了，然后进入步骤3。</li></ul></li></ul><p>节点更加详细的介绍：<a href="https://zookeeper.readthedocs.io/zh/latest/intro.html#ephemeral-nodes">https://zookeeper.readthedocs.io/zh/latest/intro.html#ephemeral-nodes</a></p><h3 id="Zookeeper命令"><a href="#Zookeeper命令" class="headerlink" title="Zookeeper命令"></a>Zookeeper命令</h3><p>以下是基本操作命令</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115092727992.png" alt="image-20211115092727992"></p><h4 id="Server端命令"><a href="#Server端命令" class="headerlink" title="Server端命令"></a>Server端命令</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 启动服务端$ bin&#x2F;zkServer.sh start# 查看状态$ bin&#x2F;zkServer.sh status# 停止$ bin&#x2F;zkServer.sh stop# 重启$ bin&#x2F;zkServer.sh restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Client端命令"><a href="#Client端命令" class="headerlink" title="Client端命令"></a>Client端命令</h4><p>连接ZooKeeper服务端</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.&#x2F;zkCli.sh -server ip:port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>断开连接</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置节点值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">set &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看命令帮助</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除单个节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">delete &#x2F; 节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示指定目录下节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除带有子节点的节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">deleteall &#x2F;节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取节点值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">get &#x2F;节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建临时节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create -e &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建顺序节点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create -s &#x2F;节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询节点详细信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -s&#x2F;节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>ls可以查看到的节点的信息</p><p><img src="D:\Typoramd\Dubbo&zookeeper\Dubbo&zookeeper.assets\image-20211114191048713.png" alt="image-20211114191048713"></p></blockquote><p>详细命令</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211114190236967.png" alt="image-20211114190236967"></p><h3 id="Zookeeper的ACL权限控制"><a href="#Zookeeper的ACL权限控制" class="headerlink" title="Zookeeper的ACL权限控制"></a>Zookeeper的ACL权限控制</h3><h4 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h4><p>zk做为分布式架构中的重要中间件，通常会在上面以节点的方式存储一些关键信息，默认情况下，所有应用都可以读写任何节点，在复杂的应用中，这不太安全，ZK通过ACL机制来解决访问权限问题，详见官网文档：</p><p><a href="http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html#sc_ZooKeeperAccessControl">http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html#sc_ZooKeeperAccessControl</a></p><p>类似linux针对文件的权限控制</p><p>ACL权限控制使用scheme(身份认证)：id（授权对象）：permission（授予的权限）</p><ol><li><p>身份的认证有4种方式：</p><p>world：world下只有一个id，即只有一个用户，也就是anyone，那么组合的写法就是<code>world:anyone:[permissions]</code></p><p>auth：代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)</p><p>digest：需要对密码加密才能访问，组合形式为<code>digest:username:BASE64(SHA1(password)):[permissions]</code></p><p>ip：当设置为ip指定的ip地址，此时限制ip进行访问，比如<code>ip:192.168.1.1:[permissions]</code></p><p>super：代表超级管理员，拥有所有的权限。</p></li><li><p>id（授权对象）</p></li><li><p>ZK的节点有5种操作权限</p><ul><li>create 简写c 可以创建子结点</li><li>delete 简写d 可以删除子结点（仅下一级）</li><li>read 简写r 可以读取结点数据以及显示子结点</li><li>write 简写w 可以设置结点数据</li><li>admin 简写a 可以设置节点访问控制列表权限</li></ul></li></ol><h4 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h4><p>getAcl：获取某个节点的acl权限信息，语法：<code>getAcl path</code></p><p>setAcl：设置某个节点的acl权限信息,语法：<code>setAcl path</code></p><p>addauth：输入认证权限信息，注册时输入明文密码（登录），但是在zk的系统里，密码是以加密的形式存在的。语法：<code>addauth scheme auth</code></p><h4 id="ACL权限控制四种模式"><a href="#ACL权限控制四种模式" class="headerlink" title="ACL权限控制四种模式"></a>ACL权限控制四种模式</h4><h5 id="world授权模式"><a href="#world授权模式" class="headerlink" title="world授权模式"></a>world授权模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setAcl path world:anyone:&lt;acl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如取消c创建权限，就不能再创建子结点</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118131807231.png" alt="image-20211118131807231"></p><h5 id="ip授权模式"><a href="#ip授权模式" class="headerlink" title="ip授权模式"></a>ip授权模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setAcl path ip:&lt;ip&gt;:&lt;acl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用两个虚拟机</p><h5 id="digest模式"><a href="#digest模式" class="headerlink" title="digest模式"></a>digest模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setAcl path digest:&lt;username&gt;:&lt;BASE64(SHA1(password))&gt;:&lt;acl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>getAcl path</code> 读取权限</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118124529642.png" alt="image-20211118124529642"></p><p>通过getAcl命令可以发现，刚创建的节点，默认是 world,anyone的认证方式，具有cdrwa所有权限</p></li><li><p><code>setAcl path digest:&lt;username&gt;:&lt;BASE64(SHA1(password))&gt;:&lt;acl&gt;</code> 设置权限</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118124939417.png" alt="image-20211118124939417"></p><p>permission是先给/app1增加了user1:+owfoSBn/am19roBPzR1/MfCblE的只读(r)权限控制</p><p>说明：setAcl /test digest:用户名:密码:权限 给节点设置ACL访问权限时，密码必须是加密后的内容，这里的+owfoSBn/am19roBPzR1/MfCblE=，对应的原文是12345 (至于这个密文怎么得来的，后面会讲到，这里先不管这个)，设置完Acl后，可以通过getAcl /节点路径 查看Acl设置然后get /app1时，提示认证无效，说明访问控制起作用了</p></li><li><p><code>addauth digest &lt;user&gt;:&lt;password&gt;</code> 添加认证用户</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118130023454.png" alt="image-20211118130023454"></p><p>addauth digest user1:12345 给”上下文”增加了一个认证用户，即对应刚才setAcl的设置</p><p>然后再 get /app1 就能取到数据了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118130303572.png" alt="image-20211118130303572"></p></li></ul><p>加密</p><p>这里的密码是经过SHA1及BASE64处理的密文</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@hecs-x-medium-2-linux-20211114163803 bin]#  echo -n user1:12345 | openssl dgst -binary -sha1 | openssl base64+owfoSBn&#x2F;am19roBPzR1&#x2F;MfCblE&#x3D;  #加密后端密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="auth模式"><a href="#auth模式" class="headerlink" title="auth模式"></a>auth模式</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">addauth digest &lt;user&gt;:&lt;password&gt; &#96;添加认证用户,password为加密后的密码&#96;setAcl &lt;path&gt; auth:&lt;user&gt;:&lt;acl&gt; &#96; 授权<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚才也提到了，setAcl /path digest这种方式，必须输入密码加密后的值，这在cli控制台上很不方便，所以下面这种方式更常用：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118131342498.png" alt="image-20211118131342498"></p><p>先用addauth digest user1:12345 增加一个认证用户，然后用 setAcl /app1 auth:user1:12345:r 设置权限，跟刚才的效果一样，但是密码这里输入的是明文，控制台模式下手动输入更方便。</p><h5 id="多权限模式"><a href="#多权限模式" class="headerlink" title="多权限模式"></a>多权限模式</h5><p>同一个结点可以使用多种授权模式，用逗号隔开就行，</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141013483.png" alt="image-20211118141013483"></p><h4 id="节点间ACL关系（待补充）"><a href="#节点间ACL关系（待补充）" class="headerlink" title="节点间ACL关系（待补充）"></a>节点间ACL关系（待补充）</h4><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118134147402.png" alt="image-20211118134147402"></p><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211118134207349.png" alt="image-20211118134207349"></p><p>从这张图上可以发现，子节点/test/app1的控制权限范围可以超出父节点的范围（仅限：父节点具有read/admin权限）</p><h4 id="ACL权限小总结"><a href="#ACL权限小总结" class="headerlink" title="ACL权限小总结"></a>ACL权限小总结</h4><p>要修改某个节点的ACL属性，必须具有read、admin二种权限</p><p>要删除某个节点下的子节点，必须具有对父节点的read权限，以及父节点的delete权限</p><blockquote><h4 id="因为没设置权限导致的节点无法删除"><a href="#因为没设置权限导致的节点无法删除" class="headerlink" title="因为没设置权限导致的节点无法删除"></a>因为没设置权限导致的节点无法删除</h4><p>Q:遇到了节点设置了权限，但是没有设置可以删除的权限，导致节点无法删除</p><p>A:假设超级管理员的账号是super:admin，先要为其生成密文：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141306373.png" alt="image-20211118141306373"></p><p>得到密文<code>xQJmxLMiHGwaqBvst5y6rkB6HQs=</code></p><p>在zookeeper目录下/bin/zkServer.sh服务器脚本文件，找到这一行</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141403483.png" alt="image-20211118141403483"></p><p><code>&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</code>加入这一句，这里已经加好了。</p><p>重启zookeeper就可以了</p><p>使用客户端登陆，添加管理员<code>addauth digest super:admin</code>,这样就可以删除了</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211118141611250.png" alt="image-20211118141611250"></p></blockquote><h3 id="Zookeeper-Java-API"><a href="#Zookeeper-Java-API" class="headerlink" title="Zookeeper Java API"></a>Zookeeper Java API</h3><h4 id="Apache-Curator简介"><a href="#Apache-Curator简介" class="headerlink" title="Apache Curator简介"></a>Apache Curator简介</h4><ul><li>Curator是ApacheZooKeeper的Java客户端库。</li><li>常见的ZooKeeper Java APl :<ul><li>原生JavaAPl</li><li>ZkClient</li><li>Curator</li></ul></li><li>Curator项目的目标是简化ZooKeeper客户端的使用，原生JavaAPI不好用。</li><li>Curator最初是Netfix研发的,后来捐献了Apache基金会,目前是Apache的顶级项目。</li><li>官网: <a href="http://curator.apache.orgl/">http://curator.apache.orgl</a></li></ul><h4 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h4><p>两种创建CuratorFramework方式</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115192919579.png" alt="image-20211115192919579"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">CuratorFramework</span> curatorFramework<span class="token punctuation">;</span>    <span class="token operator">/</span>      <span class="token operator">*</span> 建立zk链接     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token comment">//在所有Test方法前执行    @Before    public void test() &#123;        RetryNTimes retryNTimes = new RetryNTimes(3, 3000);        /*         *         * @param connectString       链接地址，链接字符串         * @param sessionTimeoutMs    会话超时时间         * @param connectionTimeoutMs 链接超时时间         * @param retryPolicy         重试策略，像超时时间或者重试次数         */        //第一种方式创建链接        curatorFramework = CuratorFrameworkFactory.newClient("124.70.145.43:2181", retryNTimes);        //第二种方式创建链接        /*CuratorFramework curatorFramework1 = CuratorFrameworkFactory.builder()                .connectString("124.70.145.43:2181")                .sessionTimeoutMs(5000)                .connectionTimeoutMs(5000)                .retryPolicy(retryNTimes)                //统一命名空间，当前会话都会在/wzy这个节点下创建                .namespace("wzy").build();*/        //开启链接        curatorFramework.start();    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>curatorFramework是已经创建好的Client</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 创建节点  create  持久，临时，顺序     <span class="token operator">*</span> <span class="token number">1.</span>基本创建     <span class="token operator">*</span> <span class="token number">2.</span>创建带数据的节点     <span class="token operator">*</span> <span class="token number">3.</span>设置节点的类型     <span class="token operator">*</span> <span class="token number">4.</span>创建多级节点     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">TestCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.基本创建，默认将客户端的ip地址作为默认数据        String path = curatorFramework.create().forPath("/app1");        //2.创建带数据的节点        String path1 = curatorFramework.create().forPath("/app2", "hello".getBytes());        //3.创建临时节点        //withMode(临时节点类型)        String path2 = curatorFramework.create().withMode(CreateMode.CONTAINER).forPath("/app3", "hello".getBytes());        //4.创建多级节点        //creatingParentsIfNeeded()用来创建父级节点        String path4 = curatorFramework.create().creatingParentsIfNeeded().forPath("/app4");    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 获取节点信息     <span class="token operator">*</span> <span class="token number">1.</span>查询节点数据     <span class="token operator">*</span> <span class="token number">2.</span>查询节点链表     <span class="token operator">*</span> <span class="token number">3.</span>查询节点状态     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取节点数据        byte[] bytes = curatorFramework.getData().forPath("/app2");        System.out.println(new String(bytes));    &#125;    @Test    public void get2() throws Exception &#123;        //获取节点的子节点        List&lt;String> list = curatorFramework.getChildren().forPath("/app4");    &#125;    @Test    public void get3() throws Exception &#123;        //节点状态信息        Stat status = new Stat();        System.out.println(status);        curatorFramework.getData().storingStatIn(status).forPath("/app2");        System.out.println(status);    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 修改数据     <span class="token operator">*</span> <span class="token number">1.</span>修改数据     <span class="token operator">*</span> <span class="token number">2.</span>根据版本号来修改     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        curatorFramework<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app2"</span><span class="token punctuation">,</span> <span class="token string">"hi"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//通过判断version来进行修改，毕竟可能不止一个客户端想要修改节点的数据，要保证查询的原子性    @Test    public void setByVersion() throws Exception &#123;        Stat status = new Stat();        //节点的版本是通过查询得到的        curatorFramework.getData().storingStatIn(status).forPath("/app2");        curatorFramework.setData().withVersion(status.getVersion()).forPath("/app2", "hihi".getBytes());    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">/</span>      <span class="token operator">*</span> 删除操作     <span class="token operator">*</span> <span class="token number">1.</span>删除节点     <span class="token operator">*</span> <span class="token number">2.</span>删除带有子节点的     <span class="token operator">*</span> <span class="token number">3.</span>必须删除成功的     <span class="token operator">*</span> <span class="token number">4.</span>带有回调函数的     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//常规删除        curatorFramework.delete().forPath("/app1");        //删除带有子节点的        curatorFramework.delete().deletingChildrenIfNeeded().forPath("/app4");        //必须删除成功的        curatorFramework.delete().guaranteed().forPath("/app1");        //带有回调函数的删除        curatorFramework.delete().inBackground(new BackgroundCallback() &#123;            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception &#123;                System.out.println("已删除");                System.out.println(event);            &#125;        &#125;).forPath("/app1");    &#125;/      * 释放连接资源     */    @After//所有Test单元模块执行完成之后再执行    public void close() &#123;        curatorFramework.close();    &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Watcher事件监听"><a href="#Watcher事件监听" class="headerlink" title="Watcher事件监听"></a>Watcher事件监听</h4><p>ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户</p><p>端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p><p>ZooKeeper中引入了Watcher机制来实现了发布/订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会</p><p>通知所有订阅者。</p><p>ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便，需要开发人员自己反复注册Watcher，比较繁琐。</p><p>Curator引入了Cache来实现对ZooKeeper服务端事件的监听。</p><p>ZooKeeper提供了三种Watcher:</p><ul><li><del>NodeCache:只是监听某一个特定的节点</del></li><li><del>PathChildrenCache:监控一个ZNode的子节点.</del></li><li><del>TreeCache:可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</del></li></ul><p>目前这三个方法在5.0以上版的Gurator中均标识位废弃，新的Watcher类CuratorCache</p><p>通过静态方法获取CuratorCache对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">CuratorCache</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> client<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">Options</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> options<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">builder</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withOptions</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>curatorCache.listenable().addListener()传入的监听器接口，重写event函数即可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterfacepublic</span> <span class="token keyword">interface</span> <span class="token class-name">CuratorCacheListener</span><span class="token punctuation">&#123;</span>    <span class="token operator">/</span>      <span class="token operator">*</span> <span class="token class-name">An</span> enumerated type that describes a change     <span class="token operator">*</span><span class="token operator">/</span>    <span class="token keyword">enum</span> <span class="token class-name">Type</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">/</span>          <span class="token operator">*</span> <span class="token class-name">A</span> <span class="token keyword">new</span> node was added <span class="token keyword">to</span> <span class="token namespace">the</span> cache         <span class="token operator">*</span><span class="token operator">/</span>        NODE_CREATED<span class="token punctuation">,</span>        <span class="token operator">/</span>          <span class="token operator">*</span> <span class="token class-name">A</span> node already in the cache has changed         <span class="token operator">*</span><span class="token operator">/</span>        NODE_CHANGED<span class="token punctuation">,</span>        <span class="token operator">/</span>          <span class="token operator">*</span> <span class="token class-name">A</span> node already in the cache was deleted         <span class="token operator">*</span><span class="token operator">/</span>        NODE_DELETED    <span class="token punctuation">&#125;</span>     <span class="token comment">// 第一个参数：事件类型（枚举）     // 第二个参数：节点更新前的状态、数据     // 第三个参数：节点更新后的状态、数据    void event(Type type, ChildData oldData, ChildData data);    /      * When the cache is started, the initial nodes are tracked and when they are finished loading     * into the cache this method is called.     */    default void initialized()    &#123;        // NOP    &#125;    /      * Returns a builder allowing type specific, and special purpose listeners.     *     * @return builder     */    static CuratorCacheListenerBuilder builder()    &#123;        return new CuratorCacheListenerBuilderImpl();    &#125;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体代码使用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//创建Watcher        CuratorCache curatorCache = CuratorCache.build(curatorFramework, "/app1");        curatorCache.listenable().addListener(new CuratorCacheListener() &#123;            @Override            public void event(Type type, ChildData oldData, ChildData data) &#123;                if ("NODE_CREATED".equals(type.name())) &#123;                    System.out.println("创建了新的节点");                &#125; else if ("NODE_CHANGED".equals(type.name())) &#123;                    System.out.println(oldData);                    System.out.println("节点发生了修改");                    System.out.println(data);                &#125; else if ("NODE_DELETED".equals(type.name())) &#123;                    System.out.println("节点被删除了");                &#125;            &#125;        &#125;);        curatorCache.start();//让测试模块可以长时间运行        while (true) &#123;        &#125; &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分布式锁（重点）"><a href="#分布式锁（重点）" class="headerlink" title="分布式锁（重点）"></a>分布式锁（重点）</h4><h5 id="分布式锁和普通锁"><a href="#分布式锁和普通锁" class="headerlink" title="分布式锁和普通锁"></a>分布式锁和普通锁</h5><p>为什么分布式系统中不能用普通锁呢?普通锁和分布式锁有什么区别吗?</p><p>普通锁</p><ol><li>单一系统找那个, 同一个应用程序是有同一个进程, 然后多个线程并发会造成数据安全问题, 他们是共享同一块内存的, 所以在内存某个地方做标记即可满足需求.</li><li>例如synchronized和volatile+cas一样对具体的代码做标记, 对应的就是在同一个内存区域作了同步的标记.</li></ol><p>分布式锁</p><ol><li><p>分布式系统中, 最大的区别就是不同系统中的应用程序都在各自机器上不同的进程中处理的, 这里的线程不安全可以理解为多进程造成</p><p>的数据安全问题, 他们不会共享同一台机器的同一块内存区域, 因此需要将标记存储在所有进程都能看到的地方.</p></li><li><p>例如zookeeper作分布式锁，就是将锁标记存储在多个进程共同看到的地方，redis作分布式锁，是将其标记公共内存，而不是某个进</p><p>程分配的区域.</p></li></ol><h5 id="目前分布式锁的实现"><a href="#目前分布式锁的实现" class="headerlink" title="目前分布式锁的实现"></a>目前分布式锁的实现</h5><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115153940936.png" alt="image-20211115153940936"></p><h5 id="Zookeeper实现分布式锁的原理"><a href="#Zookeeper实现分布式锁的原理" class="headerlink" title="Zookeeper实现分布式锁的原理"></a>Zookeeper实现分布式锁的原理</h5><p>核心思想:当客户端要获取锁，则创建节点，使用完锁，则删除该节点。</p><ol><li><p>客户端获取锁时，在lock（随便起的）节点下创建临时顺序节点。</p><blockquote><p>Q:为什么创建临时节点</p><p>A:保证锁可以正常释放。当获取锁的client发生宕机，持久化节点所持有的锁就无法释放，而临时节点在链接断开之后就会被删除，同时释放锁资源。</p></blockquote></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115155140706.png" alt="image-20211115155140706"></p><ol start="2"><li><p>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取</p><p>到了锁。使用完锁后，将该节点删除。</p></li><li><p>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时</p><p>对其注册事件监听器，监听删除事件。</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115155454060.png" alt="image-20211115155454060"></p></li><li><p>如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号</p><p>最小的，如果是则获取到了锁,如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</p></li></ol><h3 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h3><h4 id="Zookeeper集群介绍"><a href="#Zookeeper集群介绍" class="headerlink" title="Zookeeper集群介绍"></a>Zookeeper集群介绍</h4><p>Leader选举:</p><ul><li>Serverid:服务器ID<br>比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。.</li><li>Zxid:数据ID<br>服务器中存放的最大数据ID.值越大说明数据越新，在选举算法中数据越新权重越大。<br>在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票,则此ZooKeeper就可以成为Leader了.</li></ul><h4 id="Zookeeper伪集群搭建"><a href="#Zookeeper伪集群搭建" class="headerlink" title="Zookeeper伪集群搭建"></a>Zookeeper伪集群搭建</h4><h5 id="zookeeper集群种类"><a href="#zookeeper集群种类" class="headerlink" title="zookeeper集群种类"></a>zookeeper集群种类</h5><p>1、单节点方式：部署在一台机器上</p><p>2、单IP多节点：部署在同一IP，但是有多个节点，各有自己的端口</p><p>3、多IP多节点：部署在不同IP，各有自己的端口</p><h5 id="伪集群的搭建"><a href="#伪集群的搭建" class="headerlink" title="伪集群的搭建"></a>伪集群的搭建</h5><ol><li><p>基本安装</p><p>在usr/local/zookeeper-cluster创建三个zookeeper文件夹</p><p>对应三个zookeeper</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir zookeeper-clustermkdir zookeeper-1mkdir zookeeper-2mkdir zookeeper-3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将zookeeper文件复制到三个文件夹下，可以是提前解压好的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cp -r apache-zookeeper-3.7.0-bin  &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1cp -r apache-zookeeper-3.7.0-bin  &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2cp -r apache-zookeeper-3.7.0-bin  &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为每个zookeeper创建对应的data目录，并将conf下的zoo_sample.cfg文件改名为zoo.cfg</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;zkdatamkdir &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;zkdatamkdir &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;zkdatamv &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;conf&#x2F;zoo.cfgmv &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;conf&#x2F;zoo.cfgmv &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;conf&#x2F;zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置zookeeper的dataDir和clientPort</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;conf&#x2F;zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cfg" data-language="cfg"><code class="language-cfg">#zoo.cfgdataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdataclientPort&#x3D;2181&#x2F;2182&#x2F;2183<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置完成后，三个zookeeper还是属于单机的状态，不知道其他zookeeper的存在</p></li><li><p>集群配置</p><p>在每个zookeeper的data目录下创建一个myid文件，内容分别是1、2、3。这个文件就是记录每个服务器的ID</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo 1 &gt;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdata&#x2F;myidecho 2 &gt;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdata&#x2F;myidecho 3 &gt;&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;zkdata&#x2F;myid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每一个zookeeper的zoo.cfg配置客户端访问端口(clientPort）和集群服务器IP列表。集群服务器P列表如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-1&#x2F;apache-zookeeper-3.7.0-bin&#x2F;conf&#x2F;zoo.cfgvi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-2&#x2F;apache-zookeeper-3.7.0-bin&#x2F;conf&#x2F;zoo.cfgvi &#x2F;usr&#x2F;local&#x2F;zookeeper-cluster&#x2F;zookeeper-3&#x2F;apache-zookeeper-3.7.0-bin&#x2F;conf&#x2F;zoo.cfgserver.1&#x3D;(服务器ip)124.70.145.43:2881:（）3881<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释: server.服务器ID=服务器IP地址:服务器之间通信端口:服务器之间投票选举端口</p></li><li><p>启动集群</p><p>启动server1</p><p>使用bin/zkServer.sh status查看server1的启动结果：</p><p><img src="https://gitee.com/kisstt/typora/raw/master/image/image-20211115215138963.png" alt="image-20211115215138963"></p><p>此时server2和server3都没有正常启动，因此此时出现失败是正常的，等到2和3启动后就会消失。</p></li></ol><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>同一IP上搭建多个节点的集群时，必须要注意端口问题，端口必须不一致才行；</p><p>创建多个节点集群时，在dataDir目录下必须创建myid文件，myid文件用于zookeeper验证server序号等，myid文件只有一行，并且为当前server的序号，例如server.1的myid就是1，server2的myid就是2等。</p></blockquote><h4 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h4><p>和伪集群配置差不多，只不过需要注意一些点</p><p>注意点参考文章：<a href="https://blog.csdn.net/beitiandijun/article/details/41802835">https://blog.csdn.net/beitiandijun/article/details/41802835</a></p><h4 id="Zookeeper集群角色"><a href="#Zookeeper集群角色" class="headerlink" title="Zookeeper集群角色"></a>Zookeeper集群角色</h4><p>在ZooKeeper集群服中务中有三个角色:</p><ul><li><code>leader</code> 是集群中最重要的角色。负责响应集群的所有对Zookeeper数据状态变更的请求（可以理解为事务请求）。它会将每个状态更新请求进行顺序管理，以便保证整个集群内部消息处理的 FIFO，遵循了顺序一致性（Sequential Consistency）。<ul><li><code>leader</code> 内部维护 session ，来自客户端的连接和断开连接，都会被统一<code>follower</code> 或 <code>observer</code> 转发给<code>leader</code>处理。</li><li><code>leader</code> 内部维护单调递增的 Zxid（<code>ZooKeeper Transaction Id</code>），针对客户端连接，断开连接，节点的写操作都会分配一个全局唯一的Zxid，同时这些操作是原子性的，并且是严格顺序性的，遵循<code>ZAB</code>原子广播一致性协议完成事务（transaction）操作。如果客户端的所有写操作，都会被 <code>follower</code> 统一转发给<code>leader</code>处理。</li></ul></li><li><code>follower</code> <ul><li>具有选举权，参与<code>Leader</code>选举投票。</li><li>负责给<code>leader</code>转发客户端的写服务（事务请求），需要响应<code>leader</code>的提议</li><li>处理客户端非事务请求（读）</li></ul></li><li><code>observer </code><ul><li>没有选举权。</li><li>主要提供给客户端读服务，不提供写服务，也不需要响应<code>leader</code>的提议。</li><li>不需要日志文件，因为没有写服务，没有持久化的需要。</li></ul></li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h2><h4 id="为什么分布式系统中不能用普通锁呢-普通锁和分布式锁有什么区别吗"><a href="#为什么分布式系统中不能用普通锁呢-普通锁和分布式锁有什么区别吗" class="headerlink" title="为什么分布式系统中不能用普通锁呢?普通锁和分布式锁有什么区别吗?"></a>为什么分布式系统中不能用普通锁呢?普通锁和分布式锁有什么区别吗?</h4><p>普通锁</p><ol><li><p>单一系统找那个, 同一个应用程序是有同一个进程, 然后多个线程并发会造成数据安全问题, 他们是共享同一块内存的, 所以在内存某个地方</p></li><li><p>做标记即可满足需求.例如synchronized和volatile+cas一样对具体的代码做标记, 对应的就是在同一个内存区域作了同步的标记.</p></li></ol><p>分布式锁</p><ol><li>分布式系统中, 最大的区别就是不同系统中的应用程序都在各自机器上不同的进程中处理的, 这里的线程不安全可以理解为多进程造成的数据安全问题, 他们不会共享同一台机器的同一块内存区域, 因此需要将标记存储在所有进程都能看到的地方.</li><li>例如zookeeper作分布式锁，就是将锁标记存储在多个进程共同看到的地方，redis作分布式锁，是将其标记公共内存，而不是某个进程分配的区域.</li></ol><h4 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h4><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li><li>高可用的获取锁与释放锁；</li><li>高性能的获取锁与释放锁；</li><li>具备可重入特性；</li><li>具备锁失效机制，防止死锁；</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ul><h4 id="分布式锁的三种实现方式"><a href="#分布式锁的三种实现方式" class="headerlink" title="分布式锁的三种实现方式"></a>分布式锁的三种实现方式</h4><ol><li><p>基于数据库实现分布式锁；</p></li><li><p>基于缓存（Redis等）实现分布式锁；</p></li><li><p>基于Zookeeper实现分布式锁；</p><p>尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！</p></li></ol><h4 id="数据库的分布式锁的实现"><a href="#数据库的分布式锁的实现" class="headerlink" title="数据库的分布式锁的实现"></a>数据库的分布式锁的实现</h4><p>参考博客：<a href="https://blog.csdn.net/weixin_42641909/article/details/106721358">https://blog.csdn.net/weixin_42641909/article/details/106721358</a></p><h5 id="基于表记录实现分布式锁"><a href="#基于表记录实现分布式锁" class="headerlink" title="基于表记录实现分布式锁"></a>基于表记录实现分布式锁</h5><p>基于数据库的实现方式的核心思想是:</p><p>在数据库中创建一个表, 表中包含方法名等字段, 并在方法名字段上创建唯一索引.</p><p>想要执行某个方法, 就使用这个方法名向表中插入数据, 成功插入则获取锁, 执行完成后删除对应的行数据释放锁.</p><ol><li><p>创建一个表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>method_lock<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>method_lock<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>method_name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'锁定的方法名'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span><span class="token keyword">desc</span><span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'备注信息'</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">timestamp</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uidx_method_name<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>method_name<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">'锁定中的方法'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><img src="https://gitee.com/kisstt/typora/raw/master/img/image-20211115190429329.png" alt="image-20211115190429329"></p><ol start="2"><li><p>想要执行某个方法, 就使用这个方法名向表中插入数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> method_lock <span class="token punctuation">(</span>method_name<span class="token punctuation">,</span> <span class="token keyword">desc</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'methodName'</span><span class="token punctuation">,</span> <span class="token string">'测试的methodName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我们对method_name做了唯一性约束, 这里如果有多个请求同事提交到数据库的话, 数据库会保证只有一个操作可以成功, 那么我们就可以认为操作成功的那个现场恒获得了该方法的锁, 可以执行方法体内容.</p></li><li><p>成功插入则获取锁, 执行完成后删除对应的行数据释放锁</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delete</span> <span class="token keyword">from</span> method_lock <span class="token keyword">where</span> method_name <span class="token operator">=</span><span class="token string">'methodName'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>基于表记录实现分布式锁的特点</p><ul><li><p>这种锁没有失效时间, 一旦释放锁的操作失败就会导致锁记录一直在数据库中, 其他线程无法获得锁. 这个缺陷也很好解决, 比如可以做</p><p>一个定时任务去定时清理.</p></li><li><p>这种锁的可靠性依赖于数据库, 建议设置备库, 避免单点, 进一步提高可靠性.</p></li><li><p>这种锁是非阻塞的, 因为插入数据失败之后会直接报错, 想要获得锁就需要再次操作. 如果需要阻塞式的, 可以来个for循环或while循环, </p><p>直至INSERT成功再返回.</p></li><li><p>这种锁也是非可重入的, 因为同一个线程在没有释放锁之前无法再次获得锁, 因为数据库中已经存在同一份记录了. 想要实现可重入锁, </p><p>可以在数据库中添加一些字段, 比如获得锁的主机信息、线程信息等, 那么在再次获得锁的时候可以先查询数据, 如果当前的主机信息</p><p>和线程信息等能被查到的话, 可以直接把锁分配给它.</p></li></ul><h5 id="基于乐观锁实现分布式锁"><a href="#基于乐观锁实现分布式锁" class="headerlink" title="基于乐观锁实现分布式锁"></a>基于乐观锁实现分布式锁</h5><pre><code>    系统认为数据的更新在大多数情况下是不会产生冲突的，只在数据库更新操作提交的时候才对数据作冲突检测。如果检测的结果出现了与预期数据不一致的情况，则返回失败信息.    乐观锁大多数是基于数据版本(version)的记录机制实现的. 即为数据增加一个版本标识.</code></pre><ol><li>在基于数据库表的版本解决方案中, 一般是通过为数据库表添加一个 “version”字段来实现读取出数据时, 将此版本号一同读出, 之后更新时, 对此版本号加1.</li><li>在更新过程中, 会对版本号进行比较, 如果是一致的, 没有发生改变, 则会成功执行本次操作; 如果版本号不一致, 则会更新失败.</li></ol><ul><li><p>基于乐观锁的优点</p><p>在检测数据冲突时并不依赖数据库本身的锁机制, 不会影响请求的性能, 当产生并发且并发量较小的时候只有少部分请求会失败.</p></li><li><p>基于乐观锁的缺点</p><p>需要对表的设计增加额外的字段, 增加了数据库的冗余, 另外, 当应用并发量高的时候, version值在频繁变化, 则会导致大量请求失败, 影响系统的可用性.</p></li></ul><p>  综合数据库乐观锁的优缺点, 乐观锁比较适合并发量不高, 并且写操作不频繁的场景.</p><h5 id="基于悲观锁实现分布式锁"><a href="#基于悲观锁实现分布式锁" class="headerlink" title="基于悲观锁实现分布式锁"></a>基于悲观锁实现分布式锁</h5><pre><code>    除了通过增删操作数据库表中的记录来实现分布式锁, 我们还可以借助数据库中再带的锁来实现分布式锁.    在查询语句后面增加For Update, 数据库会在查询过程中给数据库表增加悲观锁(也成排他锁), 当某条记录被加上悲观锁后, 其他线程</code></pre><p>也就无法再该行上增加悲观锁了.</p><ol><li><p>悲观锁与乐观锁相反, 总是假设最坏的情况, 它认为数据的更新在大多数情况下是会产生冲突的.</p></li><li><p>在使用悲观锁的同时, 我们需要注意一下锁的级别. 搜索引擎的不同也会带了锁级别的不同.</p><p>如果存储引擎是InnoDB, 在加锁的时候只有明确地指定主键(或索引)的才会执行行锁(只锁住被选取的数据), 否则Mysql将会执行表锁(将整个数据表单给锁住).</p></li></ol><p>使用悲观锁实现分布式锁特点</p><ol><li>在悲观锁中, 每一次行数据的访问都是独占的, 只有当正在访问该行数据的请求事务提交以后, 其他请求才能依次访问该数据, 否则将阻塞等待锁的释放.</li><li>悲观锁可以严格保证数据访问的安全.</li><li>但是缺点也明显, 即每次请求都会额产生加锁的开销, 且未获取到锁的请求将会阻塞等待锁的释放, 在高并发环境下, 容易造成大量请求阻塞, 影响系统可用性,</li><li>悲观锁使用不当还可能产生死锁的情况</li></ol><h4 id="Redis的分布式锁"><a href="#Redis的分布式锁" class="headerlink" title="Redis的分布式锁"></a>Redis的分布式锁</h4><p>待补充！！！！！！！！！！！</p><h2 id="二、关于设置图床"><a href="#二、关于设置图床" class="headerlink" title="二、关于设置图床"></a>二、关于设置图床</h2><p><a href="https://www.codenong.com/cs106528795/">https://www.codenong.com/cs106528795/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> dubbo </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
